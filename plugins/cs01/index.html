<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>RhS01 — Braids (Classics + Direct Digital) · Degree Chord Sequencer</title>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Share+Tech+Mono&display=swap');

  :root{
    --bg:#0e0a06;
    --surface:#1a1208;
    --surface2:#231a0d;
    --line:#3a2a15;
    --accent:#e8a030;
    --accent2:#d4601a;
    --text:#f0e0c0;
    --text-dim:#886644;

    --cyan:#5dd4e8;
    --black:#080604;

    --radius:16px;
    --shadow: 0 30px 80px rgba(0,0,0,0.72), inset 0 1px 0 rgba(255,200,100,0.08);
  }

  *{box-sizing:border-box;margin:0;padding:0}
  body{
    min-height:100vh;
    background: var(--bg);
    color: var(--text);
    font-family: 'Rajdhani', sans-serif;
    padding: max(18px, env(safe-area-inset-top)) 14px max(18px, env(safe-area-inset-bottom));
    background-image:
      radial-gradient(ellipse at 20% 0%, rgba(160,80,20,0.12) 0%, transparent 60%),
      radial-gradient(ellipse at 80% 100%, rgba(80,40,10,0.15) 0%, transparent 60%);
    display:flex;
    justify-content:center;
  }

  .app{
    width: min(980px, 100%);
    display:flex;
    flex-direction:column;
    gap: 12px;
  }

  header{
    text-align:center;
    padding: 6px 6px 0;
  }
  header h1{
    font-family:'Share Tech Mono', monospace;
    letter-spacing:0.26em;
    font-size: 18px;
    color: var(--accent);
    text-shadow: 0 0 30px rgba(232,160,48,0.2);
  }
  header .sub{
    margin-top:8px;
    font-size: 11px;
    letter-spacing:0.22em;
    text-transform:uppercase;
    color: var(--text-dim);
  }

  .frame{
    border: 1px solid var(--line);
    border-radius: var(--radius);
    overflow:hidden;
    box-shadow: var(--shadow);
    background: linear-gradient(160deg, #1e1610 0%, #120d08 100%);
  }

  .top{
    display:flex;
    flex-direction:column;
    gap: 10px;
    padding: 14px;
    border-bottom: 1px solid var(--line);
  }

  .row{
    display:flex;
    gap:10px;
    align-items:stretch;
    flex-wrap:wrap;
  }

  .card{
    background: rgba(0,0,0,0.18);
    border: 1px solid rgba(0,0,0,0.35);
    border-radius: 14px;
    padding: 12px;
    flex: 1;
    min-width: 220px;
  }

  .title{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom: 10px;
  }
  .title .label{
    font-family:'Share Tech Mono', monospace;
    color: var(--cyan);
    font-size: 11px;
    letter-spacing: 0.22em;
    text-transform: uppercase;
    white-space:nowrap;
  }
  .title .line{
    flex:1;
    height:1px;
    background: rgba(58,42,21,0.8);
  }

  /* Model buttons */
  .modes{
    display:grid;
    grid-template-columns: repeat(2, minmax(0,1fr));
    gap: 8px;
  }
  .mode-btn{
    border: 1px solid rgba(0,0,0,0.6);
    background: rgba(0,0,0,0.28);
    color: rgba(240,224,192,0.85);
    border-radius: 12px;
    padding: 10px 10px;
    cursor:pointer;
    user-select:none;
    text-align:left;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
  }
  .mode-btn b{
    font-family:'Share Tech Mono', monospace;
    font-size: 12px;
    color: rgba(240,224,192,0.95);
    letter-spacing:0.08em;
  }
  .mode-btn span{
    font-size: 11px;
    color: var(--text-dim);
    letter-spacing:0.08em;
  }
  .mode-btn.active{
    border-color: rgba(93,212,232,0.85);
    box-shadow: 0 0 16px rgba(93,212,232,0.12);
    background: rgba(93,212,232,0.12);
  }
  .mode-btn.active b{ color: var(--cyan); }

  /* Sliders */
  .sliders{
    display:grid;
    grid-template-columns: repeat(2, minmax(0,1fr));
    gap: 10px;
  }
  .ctl{
    display:flex;
    flex-direction:column;
    gap: 6px;
  }
  .ctl .name{
    font-family:'Share Tech Mono', monospace;
    font-size: 10px;
    letter-spacing:0.22em;
    text-transform:uppercase;
    color: rgba(240,224,192,0.75);
    display:flex;
    justify-content:space-between;
    gap: 8px;
  }
  .ctl .val{
    color: var(--accent);
    letter-spacing:0.08em;
    font-size: 11px;
  }

  input[type=range]{
    -webkit-appearance:none;
    width:100%;
    height: 6px;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--accent2) var(--pct,50%), rgba(0,0,0,0.35) var(--pct,50%));
    outline:none;
    cursor:pointer;
  }
  input[type=range]::-webkit-slider-thumb{
    -webkit-appearance:none;
    width: 18px; height: 18px;
    border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #e0b060, #9a6020);
    border: 1px solid rgba(255,200,80,0.35);
    box-shadow: 0 3px 10px rgba(0,0,0,0.55);
  }

  /* Sequencer */
  .seqTop{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    flex-wrap:wrap;
    margin-bottom:10px;
  }
  .pill{
    font-family:'Share Tech Mono', monospace;
    font-size: 10px;
    letter-spacing:0.22em;
    text-transform:uppercase;
    color: rgba(240,224,192,0.85);
    border:1px solid rgba(58,42,21,0.9);
    background: rgba(0,0,0,0.30);
    border-radius: 999px;
    padding: 8px 10px;
    user-select:none;
  }
  .pill b{ color: var(--cyan); font-weight:700; }

  .btnRow{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }
  .btn{
    font-family:'Share Tech Mono', monospace;
    font-size: 11px;
    letter-spacing:0.18em;
    text-transform:uppercase;
    border-radius: 12px;
    padding: 10px 10px;
    cursor:pointer;
    user-select:none;
    border:1px solid rgba(0,0,0,0.65);
    background: rgba(0,0,0,0.28);
    color: rgba(240,224,192,0.92);
  }
  .btn:active{ transform: translateY(1px); }
  .btn.on{
    border-color: rgba(93,212,232,0.85);
    background: rgba(93,212,232,0.12);
    color: var(--cyan);
    box-shadow: 0 0 18px rgba(93,212,232,0.10);
  }
  .btn.warn{
    border-color: rgba(232,160,48,0.45);
    background: rgba(232,160,48,0.08);
  }

  .seg{
    display:flex;
    gap:6px;
    align-items:center;
    flex-wrap:wrap;
    padding: 6px;
    border: 1px solid rgba(58,42,21,0.85);
    background: rgba(0,0,0,0.22);
    border-radius: 14px;
  }
  .seg button{
    border: 1px solid rgba(0,0,0,0.65);
    background: rgba(0,0,0,0.22);
    color: rgba(240,224,192,0.86);
    border-radius: 10px;
    padding: 8px 10px;
    font-family:'Share Tech Mono', monospace;
    font-size: 10px;
    letter-spacing:0.18em;
    text-transform:uppercase;
    cursor:pointer;
  }
  .seg button.active{
    border-color: rgba(93,212,232,0.85);
    background: rgba(93,212,232,0.12);
    color: var(--cyan);
  }

  .select{
    font-family:'Share Tech Mono', monospace;
    font-size: 11px;
    letter-spacing:0.14em;
    color: rgba(240,224,192,0.90);
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(0,0,0,0.65);
    border-radius: 12px;
    padding: 10px 10px;
    outline:none;
  }

  .degGrid{
    display:grid;
    grid-template-columns: repeat(16, minmax(0,1fr));
    gap: 8px;
  }
  .degStep{
    height: 42px;
    border-radius: 12px;
    border:1px solid rgba(0,0,0,0.65);
    background: rgba(0,0,0,0.28);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    user-select:none;
    position:relative;
    overflow:hidden;
  }
  .degStep .txt{
    font-family:'Share Tech Mono', monospace;
    font-size: 12px;
    letter-spacing:0.14em;
    color: rgba(240,224,192,0.92);
  }
  .degStep.off .txt{
    color: rgba(136,102,68,0.85);
  }
  .degStep.on{
    border-color: rgba(232,160,48,0.55);
    background: rgba(232,160,48,0.10);
  }
  .degStep.ph::after{
    content:"";
    position:absolute;
    inset:-2px;
    border-radius: 14px;
    outline:2px solid rgba(93,212,232,0.55);
    background: rgba(93,212,232,0.10);
    pointer-events:none;
  }

  .help{
    margin-top:10px;
    color: var(--text-dim);
    font-size: 11px;
    letter-spacing:0.10em;
    line-height:1.4;
    text-transform:uppercase;
  }
  .help b{ color: rgba(240,224,192,0.90); }

  /* Keyboard */
  .kbd{
    padding: 12px 14px 14px;
    background: rgba(0,0,0,0.16);
  }
  .kbdTop{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    margin-bottom: 10px;
  }
  .brand{
    display:flex;
    flex-direction:column;
    gap: 4px;
  }
  .brand .yam{ font-family:'Share Tech Mono', monospace; font-size: 12px; letter-spacing:0.18em; color: rgba(240,224,192,0.95); }
  .brand .cs01{ font-family:'Share Tech Mono', monospace; font-size: 26px; letter-spacing:-1px; color: var(--accent); }
  .brand .tag{ font-size: 10px; letter-spacing:0.22em; text-transform:uppercase; color: var(--text-dim); }

  .note{
    font-family:'Share Tech Mono', monospace;
    border: 1px solid rgba(93,212,232,0.7);
    color: var(--cyan);
    background: rgba(0,0,0,0.55);
    border-radius: 12px;
    padding: 8px 12px;
    min-width: 84px;
    text-align:center;
  }

  .piano{
    height: 180px;
    position: relative;
    background: var(--black);
    border: 1px solid rgba(58,42,21,0.7);
    border-radius: 14px;
    overflow:hidden;
  }
  .white-keys{
    display:flex;
    height:100%;
    gap: 1px;
    padding: 1px;
  }
  .white-key{
    flex:1;
    background: linear-gradient(180deg,#f5f5f5,#e8e8e8);
    border-radius: 0 0 10px 10px;
    border: 1px solid #ccc;
    cursor:pointer;
    box-shadow: 0 8px 14px rgba(0,0,0,0.28);
  }
  .white-key.active{ background: linear-gradient(180deg,#f7e4c1,#f0d39b); }

  .black-keys{
    position:absolute;
    top:0; left:0; right:0;
    height: 60%;
    pointer-events:none;
  }
  .black-key{
    pointer-events:all;
    position:absolute;
    height:100%;
    background: linear-gradient(180deg,#222,#111);
    border-radius: 0 0 8px 8px;
    border: 1px solid #000;
    box-shadow: 2px 10px 14px rgba(0,0,0,0.55);
    cursor:pointer;
  }
  .black-key.active{ background: linear-gradient(180deg,#3a2a15,#1a1208); }

  .footer{
    text-align:center;
    color: var(--text-dim);
    font-size: 10px;
    letter-spacing:0.22em;
    text-transform:uppercase;
    padding: 8px 0 0;
  }

  /* iPhone-ish */
  @media (max-width: 430px){
    .modes{ grid-template-columns: 1fr; }
    .sliders{ grid-template-columns: 1fr; }
    .piano{ height: 160px; }
    .degGrid{ gap: 6px; }
    .degStep{ height: 38px; border-radius: 11px; }
    .degStep .txt{ font-size: 11px; }
  }
</style>
</head>

<body>
  <div class="app">
    <header>
      <h1>RhS01 · BRAIDS (JS)</h1>
      <div class="sub">Classics + Direct Digital · Degree Chord Sequencer · House / Neo-Soul / Rhodes</div>
    </header>

    <div class="frame">
      <div class="top">

        <div class="card">
          <div class="title"><div class="label">BRAIDS → MODEL</div><div class="line"></div></div>
          <div class="modes" id="modeGrid"></div>
        </div>

        <div class="row">
          <div class="card">
            <div class="title"><div class="label">OSC (BRAIDS STYLE)</div><div class="line"></div></div>
            <div class="sliders">
              <div class="ctl">
                <div class="name">TIMBRE <span class="val" id="v-timbre">0.50</span></div>
                <input type="range" id="timbre" min="0" max="100" value="50">
              </div>
              <div class="ctl">
                <div class="name">COLOR <span class="val" id="v-color">0.35</span></div>
                <input type="range" id="color" min="0" max="100" value="35">
              </div>
              <div class="ctl">
                <div class="name">DETUNE <span class="val" id="v-detune">0.10</span></div>
                <input type="range" id="detune" min="0" max="100" value="10">
              </div>
              <div class="ctl">
                <div class="name">SUB <span class="val" id="v-sub">0.00</span></div>
                <input type="range" id="sub" min="0" max="100" value="0">
              </div>
            </div>
          </div>

          <div class="card">
            <div class="title"><div class="label">FILTER + AMP</div><div class="line"></div></div>
            <div class="sliders">
              <div class="ctl">
                <div class="name">CUTOFF <span class="val" id="v-cutoff">9000</span></div>
                <input type="range" id="cutoff" min="40" max="18000" value="9000">
              </div>
              <div class="ctl">
                <div class="name">RESO <span class="val" id="v-reso">0.90</span></div>
                <input type="range" id="resonance" min="10" max="1800" value="90">
              </div>

              <div class="ctl">
                <div class="name">ATTACK <span class="val" id="v-att">0.01</span></div>
                <input type="range" id="attack" min="1" max="400" value="8">
              </div>
              <div class="ctl">
                <div class="name">RELEASE <span class="val" id="v-rel">0.35</span></div>
                <input type="range" id="release" min="1" max="600" value="35">
              </div>

              <div class="ctl">
                <div class="name">SUSTAIN <span class="val" id="v-sus">0.75</span></div>
                <input type="range" id="sustain" min="0" max="100" value="75">
              </div>
              <div class="ctl">
                <div class="name">LEVEL <span class="val" id="v-level">0.70</span></div>
                <input type="range" id="level" min="0" max="100" value="70">
              </div>
            </div>
          </div>
        </div>

        <!-- DEGREE CHORD SEQUENCER -->
        <div class="card">
          <div class="title"><div class="label">DEGREE CHORD SEQUENCER</div><div class="line"></div></div>

          <div class="seqTop">
            <div class="btnRow">
              <button id="seqPlay" class="btn warn">Play</button>
              <button id="seqStop" class="btn">Stop</button>
              <button id="seqClear" class="btn">Clear</button>
            </div>

            <div class="btnRow">
              <select id="keySel" class="select" title="Key">
                <option value="0">C</option><option value="1">C#</option><option value="2">D</option><option value="3">D#</option>
                <option value="4">E</option><option value="5">F</option><option value="6">F#</option><option value="7">G</option>
                <option value="8">G#</option><option value="9">A</option><option value="10">A#</option><option value="11">B</option>
              </select>

              <div class="seg" title="Scale">
                <button id="scaleMaj" class="active">MAJ</button>
                <button id="scaleMin">MIN</button>
              </div>

              <div class="seg" title="Play mode">
                <button id="pmBlock" class="active">BLOCK</button>
                <button id="pmSmooth">NEO</button>
                <button id="pmRhodes">RHODES</button>
              </div>
            </div>

            <div class="pill" title="Position">
              STEP <b id="seqLed">--</b>
            </div>
          </div>

          <div class="sliders" style="grid-template-columns: repeat(3, minmax(0,1fr));">
            <div class="ctl">
              <div class="name">BPM <span class="val" id="v-bpm">122</span></div>
              <input type="range" id="bpm" min="60" max="180" value="122">
            </div>
            <div class="ctl">
              <div class="name">SWING <span class="val" id="v-swing">55%</span></div>
              <input type="range" id="swing" min="0" max="100" value="55">
            </div>
            <div class="ctl">
              <div class="name">GATE <span class="val" id="v-gate">60%</span></div>
              <input type="range" id="gate" min="20" max="95" value="60">
            </div>
          </div>

          <div style="margin-top:10px;">
            <div class="degGrid" id="degGrid"></div>
            <div class="help">
              TAP steps to cycle: <b>OFF → I/ii/III…</b> (upper = major, lower = minor).<br/>
              <b>NEO</b> = 7/9 voicings + smooth voice-leading · <b>RHODES</b> = wider, drop-2, 10ths.
            </div>
          </div>
        </div>

      </div>

      <div class="kbd">
        <div class="kbdTop">
          <div class="brand">
            <div class="yam">BANTU Ins.</div>
            <div class="cs01">RhS01</div>
            <div class="tag">MONO · BRAIDS MODELS · KEYS/SEQ</div>
          </div>
          <div class="note" id="noteDisplay">---</div>
        </div>

        <div class="piano" id="piano">
          <div class="white-keys" id="whiteKeys"></div>
          <div class="black-keys" id="blackKeys"></div>
        </div>
      </div>
    </div>

    <div class="footer">Braids-style models (subset) · Classics + Direct Digital · Mono synth + chord-degree sequencer</div>
  </div>

<script>
/* ============================================================
   BRAIDS-STYLE OSCILLATOR (subset) via inline AudioWorklet
   - Classics: Sine, Tri, Saw, Square, PWM
   - Direct Digital: WT Morph, FM2OP, Bitcrush Saw
   Notes:
   - This is a "Braids-inspired" subset, not a bit-perfect port.
============================================================ */

let audioCtx = null;
let oscNode = null;
let filterNode = null;
let ampNode = null;
let currentNote = null;

const params = {
  model: 3,        // default: WT MORPH
  timbre: 0.50,    // 0..1
  color: 0.35,     // 0..1
  detune: 0.10,    // 0..1
  sub: 0.00,       // 0..1
  cutoff: 9000,
  resonance: 0.90,
  attack: 0.008,
  release: 0.35,
  sustain: 0.75,
  level: 0.70,
};

const MODELS = [
  // Classics
  { id: 0, group: "CLASSICS", name: "SINE",  hint: "clean", icon: "∿" },
  { id: 1, group: "CLASSICS", name: "TRI",   hint: "soft",  icon: "△" },
  { id: 2, group: "CLASSICS", name: "SAW",   hint: "bright",icon: "⟋" },
  { id: 3, group: "DIRECT",   name: "WT MORPH", hint: "wavetable", icon: "≋" },
  { id: 4, group: "CLASSICS", name: "SQUARE",hint: "hollow",icon: "▢" },
  { id: 5, group: "CLASSICS", name: "PWM",   hint: "pulse", icon: "▥" },
  // Direct Digital
  { id: 6, group: "DIRECT",   name: "FM 2-OP", hint: "keys/bell", icon: "FM" },
  { id: 7, group: "DIRECT",   name: "CRUSH SAW", hint: "lofi", icon: "⌁" },
];

function noteToFreq(midi){ return 440 * Math.pow(2, (midi - 69) / 12); }
function midiToName(midi){
  const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  return names[midi % 12] + Math.floor(midi / 12 - 1);
}

function createBraidsWorkletURL(){
  const code = `
class BraidsOsc extends AudioWorkletProcessor {
  static get parameterDescriptors(){
    return [
      { name: 'freq',    defaultValue: 440, minValue: 0,   maxValue: 20000, automationRate: 'a-rate' },
      { name: 'gain',    defaultValue: 1.0, minValue: 0,   maxValue: 2.0,   automationRate: 'k-rate' },
      { name: 'model',   defaultValue: 3,   minValue: 0,   maxValue: 7,     automationRate: 'k-rate' },
      { name: 'timbre',  defaultValue: 0.5, minValue: 0,   maxValue: 1,     automationRate: 'k-rate' },
      { name: 'color',   defaultValue: 0.35,minValue: 0,   maxValue: 1,     automationRate: 'k-rate' },
      { name: 'detune',  defaultValue: 0.1, minValue: 0,   maxValue: 1,     automationRate: 'k-rate' },
      { name: 'sub',     defaultValue: 0.0, minValue: 0,   maxValue: 1,     automationRate: 'k-rate' },
    ];
  }

  constructor(){
    super();
    this.phase = 0;
    this.subPhase = 0;
    this.fmPhase = 0;

    this.hold = 0;
    this.srCounter = 0;

    // a few band-limited-ish wavetables (small & cheap):
    // 0:sine, 1:tri-ish, 2:saw-ish, 3:square-ish, 4:bright "organ", 5:formant-ish
    this.tables = [];
    const makeTable = (fn) => {
      const N = 2048;
      const t = new Float32Array(N);
      for (let i=0;i<N;i++){
        const ph = i / N;
        t[i] = fn(ph);
      }
      return t;
    };
    const twoPi = 2*Math.PI;

    this.tables.push(makeTable(ph => Math.sin(twoPi*ph))); // sine
    this.tables.push(makeTable(ph => { // tri-ish
      const x = 2*Math.abs(2*(ph - Math.floor(ph+0.5))) - 1;
      return x * 0.9;
    }));
    this.tables.push(makeTable(ph => { // saw-ish
      return (2*(ph - Math.floor(ph+0.5))) * 0.85;
    }));
    this.tables.push(makeTable(ph => { // square-ish
      return ph < 0.5 ? 0.75 : -0.75;
    }));
    this.tables.push(makeTable(ph => { // organ-ish (odd harmonics)
      let s=0;
      for (let k=1;k<=15;k+=2) s += Math.sin(twoPi*k*ph)/k;
      return (s * 0.95);
    }));
    this.tables.push(makeTable(ph => { // formant-ish (two sines)
      return 0.55*Math.sin(twoPi*ph) + 0.45*Math.sin(twoPi*3*ph + 0.35);
    }));
  }

  _wrap(p){ return p - Math.floor(p); }

  _readTable(table, phase){
    const N = table.length;
    const x = phase * N;
    const i = x|0;
    const f = x - i;
    const a = table[i % N];
    const b = table[(i+1) % N];
    return a + (b-a)*f;
  }

  _polyBLEP(t, dt){
    // cheap polyBLEP to soften edges for saw/square/pwm (still not perfect)
    if (t < dt){
      t = t/dt;
      return t + t - t*t - 1.0;
    } else if (t > 1.0 - dt){
      t = (t - 1.0)/dt;
      return t*t + t + t + 1.0;
    }
    return 0.0;
  }

  process(inputs, outputs, parameters){
    const out = outputs[0][0];
    const sr = sampleRate;

    const model = parameters.model.length ? parameters.model[0] : 3;
    const timbre = parameters.timbre.length ? parameters.timbre[0] : 0.5;
    const color = parameters.color.length ? parameters.color[0] : 0.35;
    const detune = parameters.detune.length ? parameters.detune[0] : 0.1;
    const sub = parameters.sub.length ? parameters.sub[0] : 0.0;
    const gain = parameters.gain.length ? parameters.gain[0] : 1.0;

    // detune as cents-ish
    const detCents = (detune * 40) - 20; // -20..+20 cents
    const detRatio = Math.pow(2, detCents / 1200);

    // FM index & crush mapped
    const fmIndex = 0.2 + color * 6.0;
    const fmRatio = 1.0 + timbre * 7.0; // mod ratio

    // crush: lower SR and bit depth
    const crushBits = 4 + Math.floor((1.0 - timbre) * 12); // 4..16
    const crushLevels = Math.pow(2, crushBits);
    const srDiv = 1 + Math.floor((1.0 - color) * 30); // 1..31

    for (let i=0;i<out.length;i++){
      const freq = (parameters.freq.length ? parameters.freq[i] : parameters.freq[0]) * detRatio;
      const dt = Math.min(0.49, freq / sr);

      this.phase = this._wrap(this.phase + dt);
      this.subPhase = this._wrap(this.subPhase + dt*0.5);
      this.fmPhase  = this._wrap(this.fmPhase + dt*fmRatio);

      let y = 0.0;

      if (model === 0){
        // SINE
        y = Math.sin(2*Math.PI*this.phase);
      } else if (model === 1){
        // TRI
        y = 2*Math.abs(2*(this.phase - Math.floor(this.phase+0.5))) - 1;
        y *= 0.95;
      } else if (model === 2){
        // SAW (polyBLEP)
        let s = 2*this.phase - 1;
        s -= this._polyBLEP(this.phase, dt);
        y = s * 0.90;
      } else if (model === 4){
        // SQUARE (polyBLEP)
        let s = this.phase < 0.5 ? 1 : -1;
        s += this._polyBLEP(this.phase, dt);
        s -= this._polyBLEP(this._wrap(this.phase + 0.5), dt);
        y = s * 0.78;
      } else if (model === 5){
        // PWM (polyBLEP), timbre controls width
        const pw = 0.05 + timbre * 0.90;
        let s = this.phase < pw ? 1 : -1;
        // correct both edges
        s += this._polyBLEP(this.phase, dt);
        s -= this._polyBLEP(this._wrap(this.phase - pw), dt);
        y = s * 0.78;
      } else if (model === 3){
        // WT MORPH (direct digital)
        // timbre morph table index, color = bright warp
        const t = timbre * (this.tables.length - 1);
        const i0 = Math.floor(t);
        const i1 = Math.min(this.tables.length - 1, i0 + 1);
        const frac = t - i0;
        const a = this._readTable(this.tables[i0], this.phase);
        const b = this._readTable(this.tables[i1], this.phase);
        let w = a + (b - a) * frac;

        // bright warp (soft fold)
        const drive = 1.0 + color * 3.5;
        w *= drive;
        // tanh-ish soft clip
        w = w / (1.0 + 0.6*Math.abs(w));

        y = w * 0.85;
      } else if (model === 6){
        // FM 2-OP (direct digital)
        const mod = Math.sin(2*Math.PI*this.fmPhase) * fmIndex;
        y = Math.sin(2*Math.PI*(this.phase + mod));
        // bright/tilt with color (cheap waveshape)
        const sh = 1.0 + color * 2.5;
        y = (y * sh) / (1.0 + 0.7*Math.abs(y*sh));
        y *= 0.88;
      } else if (model === 7){
        // CRUSH SAW (direct digital)
        let s = 2*this.phase - 1;
        // soften a bit
        s -= this._polyBLEP(this.phase, dt);
        // downsample hold
        if (this.srCounter++ % srDiv === 0) this.hold = s;
        let q = Math.round(this.hold * crushLevels) / crushLevels;
        y = q * 0.95;
      }

      // SUB (pure sine at 1 octave down)
      if (sub > 0.0001){
        const subSin = Math.sin(2*Math.PI*this.subPhase);
        y = y*(1.0 - sub*0.35) + subSin*(sub*0.35);
      }

      out[i] = y * gain;
    }

    return true;
  }
}

registerProcessor('braids-osc', BraidsOsc);
`;
  return URL.createObjectURL(new Blob([code], { type: "application/javascript" }));
}

async function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  const url = createBraidsWorkletURL();
  await audioCtx.audioWorklet.addModule(url);
  try { URL.revokeObjectURL(url); } catch {}

  oscNode = new AudioWorkletNode(audioCtx, "braids-osc", {
    numberOfInputs: 0,
    numberOfOutputs: 1,
    outputChannelCount: [1],
  });

  filterNode = audioCtx.createBiquadFilter();
  filterNode.type = "lowpass";

  ampNode = audioCtx.createGain();
  ampNode.gain.value = 0;

  oscNode.connect(filterNode);
  filterNode.connect(ampNode);
  ampNode.connect(audioCtx.destination);

  applyAllParams();
}

function oscParam(name){ return oscNode?.parameters?.get(name) || null; }

function applyAllParams() {
  if (!audioCtx) return;

  oscParam("model")?.setValueAtTime(params.model, audioCtx.currentTime);
  oscParam("timbre")?.setValueAtTime(params.timbre, audioCtx.currentTime);
  oscParam("color")?.setValueAtTime(params.color, audioCtx.currentTime);
  oscParam("detune")?.setValueAtTime(params.detune, audioCtx.currentTime);
  oscParam("sub")?.setValueAtTime(params.sub, audioCtx.currentTime);
  oscParam("gain")?.setValueAtTime(1.0, audioCtx.currentTime);

  filterNode.frequency.setValueAtTime(params.cutoff, audioCtx.currentTime);
  filterNode.Q.setValueAtTime(params.resonance, audioCtx.currentTime);
}

function gateOn() {
  const now = audioCtx.currentTime;
  ampNode.gain.cancelScheduledValues(now);
  ampNode.gain.setValueAtTime(ampNode.gain.value, now);
  ampNode.gain.linearRampToValueAtTime(params.level, now + params.attack);
  ampNode.gain.linearRampToValueAtTime(params.level * params.sustain, now + params.attack + 0.10);
}
function gateOff(timeOverride = null) {
  const now = timeOverride ?? audioCtx.currentTime;
  ampNode.gain.cancelScheduledValues(now);
  ampNode.gain.setValueAtTime(ampNode.gain.value, now);
  ampNode.gain.linearRampToValueAtTime(0, now + params.release);
}

async function playNote(midi) {
  await initAudio();
  if (audioCtx.state === "suspended") await audioCtx.resume();

  currentNote = midi;
  document.getElementById("noteDisplay").textContent = midiToName(midi);

  const freq = noteToFreq(midi);
  oscParam("freq")?.setValueAtTime(freq, audioCtx.currentTime);

  gateOn();
}
function stopNote() {
  if (!audioCtx) return;
  gateOff();
  currentNote = null;
  document.getElementById("noteDisplay").textContent = "---";
}

/* ============================================================
   UI: Model buttons
============================================================ */
const modeGrid = document.getElementById("modeGrid");
function renderModes() {
  modeGrid.innerHTML = "";
  MODELS.forEach(m => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "mode-btn" + (params.model === m.id ? " active" : "");
    btn.innerHTML = `<b>${m.icon} ${m.name}</b><span>${m.group} · ${m.hint}</span>`;
    btn.addEventListener("click", async () => {
      params.model = m.id;
      if (audioCtx) oscParam("model")?.setValueAtTime(params.model, audioCtx.currentTime);
      renderModes();
    });
    modeGrid.appendChild(btn);
  });
}
renderModes();

/* ============================================================
   UI: Slider helpers
============================================================ */
function setRangeVisual(el) {
  const v = parseFloat(el.value);
  const min = parseFloat(el.min);
  const max = parseFloat(el.max);
  const pct = ((v - min) / (max - min) * 100).toFixed(1) + "%";
  el.style.setProperty("--pct", pct);
}
function bindRange(id, onChange) {
  const el = document.getElementById(id);
  setRangeVisual(el);
  el.addEventListener("input", () => {
    setRangeVisual(el);
    onChange(parseFloat(el.value));
  });
}

/* Braids params */
bindRange("timbre", (v) => {
  params.timbre = v / 100;
  document.getElementById("v-timbre").textContent = params.timbre.toFixed(2);
  if (audioCtx) oscParam("timbre")?.setValueAtTime(params.timbre, audioCtx.currentTime);
});
bindRange("color", (v) => {
  params.color = v / 100;
  document.getElementById("v-color").textContent = params.color.toFixed(2);
  if (audioCtx) oscParam("color")?.setValueAtTime(params.color, audioCtx.currentTime);
});
bindRange("detune", (v) => {
  params.detune = v / 100;
  document.getElementById("v-detune").textContent = params.detune.toFixed(2);
  if (audioCtx) oscParam("detune")?.setValueAtTime(params.detune, audioCtx.currentTime);
});
bindRange("sub", (v) => {
  params.sub = v / 100;
  document.getElementById("v-sub").textContent = params.sub.toFixed(2);
  if (audioCtx) oscParam("sub")?.setValueAtTime(params.sub, audioCtx.currentTime);
});

/* Filter + amp */
bindRange("cutoff", (v) => {
  params.cutoff = v;
  document.getElementById("v-cutoff").textContent = Math.round(v);
  if (audioCtx) filterNode.frequency.setValueAtTime(params.cutoff, audioCtx.currentTime);
});
bindRange("resonance", (v) => {
  params.resonance = (v / 100).toFixed(2) * 1;
  document.getElementById("v-reso").textContent = params.resonance.toFixed(2);
  if (audioCtx) filterNode.Q.setValueAtTime(params.resonance, audioCtx.currentTime);
});
bindRange("attack", (v) => {
  params.attack = Math.max(0.001, v / 1000);
  document.getElementById("v-att").textContent = params.attack.toFixed(3);
});
bindRange("release", (v) => {
  params.release = Math.max(0.001, v / 100);
  document.getElementById("v-rel").textContent = params.release.toFixed(2);
});
bindRange("sustain", (v) => {
  params.sustain = v / 100;
  document.getElementById("v-sus").textContent = params.sustain.toFixed(2);
});
bindRange("level", (v) => {
  params.level = v / 100;
  document.getElementById("v-level").textContent = params.level.toFixed(2);
});

/* init displayed values */
document.getElementById("v-timbre").textContent = params.timbre.toFixed(2);
document.getElementById("v-color").textContent = params.color.toFixed(2);
document.getElementById("v-detune").textContent = params.detune.toFixed(2);
document.getElementById("v-sub").textContent = params.sub.toFixed(2);
document.getElementById("v-cutoff").textContent = Math.round(params.cutoff);
document.getElementById("v-reso").textContent = params.resonance.toFixed(2);
document.getElementById("v-att").textContent = params.attack.toFixed(3);
document.getElementById("v-rel").textContent = params.release.toFixed(2);
document.getElementById("v-sus").textContent = params.sustain.toFixed(2);
document.getElementById("v-level").textContent = params.level.toFixed(2);

/* ============================================================
   Degree Chord Sequencer (unchanged logic from previous step)
============================================================ */
const DEG_STEPS = 16;

const seq = {
  running:false,
  step:0,
  timer:null,
  bpm:122,
  swing:0.55,
  gate:0.60,
  keyPc:0,
  scale:"maj",
  playMode:"block", // "block" | "neo" | "rhodes"
  steps: Array.from({length: DEG_STEPS}, () => null),
};

let lastVoicing = null;

const SCALE = {
  maj: [0,2,4,5,7,9,11],
  min: [0,2,3,5,7,8,10],
};

function degreeLabel(degIdx, scale){
  if (scale === "maj") return ["I","ii","iii","IV","V","vi","vii°"][degIdx] || "-";
  return ["i","ii°","III","iv","v","VI","VII"][degIdx] || "-";
}
function chordRootMidiForDegree(degIdx){
  const tonic = 60 + seq.keyPc;
  const scaleInts = SCALE[seq.scale];
  return tonic + (scaleInts[degIdx] ?? 0);
}
function getTriadIntervals(degIdx){
  if (seq.scale === "maj"){
    if (degIdx === 0 || degIdx === 3 || degIdx === 4) return [0,4,7];
    if (degIdx === 6) return [0,3,6];
    return [0,3,7];
  } else {
    if (degIdx === 2 || degIdx === 5 || degIdx === 6) return [0,4,7];
    if (degIdx === 1) return [0,3,6];
    return [0,3,7];
  }
}

const VOICE_TARGET_MIDI = 64;

function getNeoSoulChordIntervals(degIdx){
  const tri = getTriadIntervals(degIdx);
  let seventh = 10;
  if (seq.scale === "maj"){
    if (degIdx === 0 || degIdx === 3) seventh = 11;
    else seventh = 10;
  } else {
    if (degIdx === 2 || degIdx === 5) seventh = 11;
    else seventh = 10;
  }
  let intervals = [...tri, seventh];

  const add9 = Math.random() < 0.75;
  if (add9){
    const fifthIdx = intervals.indexOf(7);
    if (fifthIdx !== -1 && Math.random() < 0.70) intervals[fifthIdx] = 14;
    else if (Math.random() < 0.45) intervals[0] = 14;
  }
  if (Math.random() < 0.22){
    const third = tri[1];
    const thirdIdx = intervals.indexOf(third);
    if (thirdIdx !== -1) intervals[thirdIdx] = (Math.random() < 0.5 ? 2 : 5);
  }
  return intervals.map(x => Math.round(x));
}

function normalizeChordToTarget(notes, target){
  let shifted = notes.slice().sort((a,b)=>a-b);
  while (centerOf(shifted) < target - 6) shifted = shifted.map(n => n + 12);
  while (centerOf(shifted) > target + 6) shifted = shifted.map(n => n - 12);
  return shifted.sort((a,b)=>a-b);

  function centerOf(ns){ return (ns[0] + ns[ns.length-1]) / 2; }
}

function voiceLeadingCostFlexible(prev, next){
  const a = prev.slice().sort((x,y)=>x-y);
  const b = next.slice().sort((x,y)=>x-y);
  const n = Math.max(a.length, b.length);
  let cost = 0;
  for (let i = 0; i < n; i++){
    const aa = a[Math.min(i, a.length - 1)];
    const bb = b[Math.min(i, b.length - 1)];
    cost += Math.abs(aa - bb);
  }
  return cost;
}

function getNeoSoulVoicingForDegree(degIdx){
  const rootBase = chordRootMidiForDegree(degIdx);
  const ints = getNeoSoulChordIntervals(degIdx);

  const invs = [0,1,2,3];
  const octs = [-24,-12,0,12,24];
  const drops = [false, true];

  let best = null;
  let bestCost = Infinity;

  for (const inv of invs){
    for (const o of octs){
      for (const doDrop2 of drops){
        let notes = ints.map(x => rootBase + x + o).sort((a,b)=>a-b);

        for (let k = 0; k < inv; k++){
          notes[0] += 12;
          notes.sort((a,b)=>a-b);
        }

        if (doDrop2 && notes.length >= 4){
          const idx = notes.length - 2;
          notes[idx] -= 12;
          notes.sort((a,b)=>a-b);
        }

        notes = normalizeChordToTarget(notes, VOICE_TARGET_MIDI);

        const cost = lastVoicing
          ? voiceLeadingCostFlexible(lastVoicing, notes)
          : Math.abs(((notes[0]+notes[notes.length-1])/2) - VOICE_TARGET_MIDI);

        const spread = notes[notes.length-1] - notes[0];
        const spreadPenalty = Math.max(0, (24 - spread)) * 0.15;
        const finalCost = cost + spreadPenalty;

        if (finalCost < bestCost){
          bestCost = finalCost;
          best = notes;
        }
      }
    }
  }
  return best || ints.map(x => rootBase + x).sort((a,b)=>a-b);
}

function getRhodesVoicingForDegree(degIdx){
  const rootBase = chordRootMidiForDegree(degIdx);
  let ints = getNeoSoulChordIntervals(degIdx).slice();
  const tri = getTriadIntervals(degIdx);

  const hasThird = ints.includes(tri[1]);
  if (!hasThird && Math.random() < 0.65){
    const susIdx = ints.findIndex(x => x === 2 || x === 5);
    if (susIdx !== -1) ints[susIdx] = tri[1];
  }

  const octs = [-24,-12,0,12,24];
  const invs = [0,1,2,3];

  let best = null;
  let bestCost = Infinity;

  for (const o of octs){
    for (const inv of invs){
      let notes = ints.map(x => rootBase + x + o).sort((a,b)=>a-b);

      for (let k = 0; k < inv; k++){
        notes[0] += 12;
        notes.sort((a,b)=>a-b);
      }

      const third = tri[1];
      const thirdIdx = notes.findIndex(n => ((n - (rootBase+o)) % 12 + 12) % 12 === (third % 12));
      if (thirdIdx !== -1 && Math.random() < 0.85){
        notes[thirdIdx] += 12;
        notes.sort((a,b)=>a-b);
      }

      if (notes.length >= 4){
        const idx = notes.length - 2;
        if (Math.random() < 0.80){
          notes[idx] -= 12;
          notes.sort((a,b)=>a-b);
        }
      }

      const target = VOICE_TARGET_MIDI + 2;
      notes = normalizeChordToTarget(notes, target);

      const spread = notes[notes.length-1] - notes[0];
      const wantMin = 19;
      const spreadPenalty = spread < wantMin ? (wantMin - spread) * 1.2 : 0;

      const cost = lastVoicing
        ? voiceLeadingCostFlexible(lastVoicing, notes)
        : Math.abs(((notes[0]+notes[notes.length-1])/2) - target);

      const airyBonus = Math.max(0, 28 - spread) * 0.10;
      const finalCost = cost + spreadPenalty + airyBonus;

      if (finalCost < bestCost){
        bestCost = finalCost;
        best = notes;
      }
    }
  }
  return best || getNeoSoulVoicingForDegree(degIdx);
}

function scheduleNote(midi, tStart, dur){
  if (!audioCtx) return;
  const freq = noteToFreq(midi);
  oscParam("freq")?.setValueAtTime(freq, tStart);

  ampNode.gain.cancelScheduledValues(tStart);
  ampNode.gain.setValueAtTime(ampNode.gain.value, tStart);

  const a = params.attack;
  const rel = params.release;
  const peak = params.level;
  const sus = params.sustain;

  ampNode.gain.linearRampToValueAtTime(peak, tStart + a);
  ampNode.gain.linearRampToValueAtTime(peak * sus, tStart + a + 0.08);

  const tOff = Math.max(tStart + 0.01, tStart + dur);
  ampNode.gain.setValueAtTime(ampNode.gain.value, tOff);
  ampNode.gain.linearRampToValueAtTime(0, tOff + rel);

  document.getElementById("noteDisplay").textContent = midiToName(midi);
}

function stepDurationSec(){
  const spb = 60 / seq.bpm;
  return spb / 4;
}
function swingDelayForStep(stepIdx){
  const base = stepDurationSec();
  const swingAmt = (seq.swing - 0.5) * 0.5;
  return (stepIdx % 2 === 0) ? base * (1 + swingAmt) : base * (1 - swingAmt);
}
function clearSeqHighlights(){
  document.querySelectorAll(".degStep.ph").forEach(el => el.classList.remove("ph"));
}
function setSeqLed(stepIdx){
  document.getElementById("seqLed").textContent = String(stepIdx+1).padStart(2,"0");
}

async function seqTick(){
  if (!seq.running) return;
  await initAudio();
  if (audioCtx.state === "suspended") await audioCtx.resume();

  clearSeqHighlights();
  const stepEl = document.querySelector(\`.degStep[data-step="\${seq.step}"]\`);
  if (stepEl) stepEl.classList.add("ph");
  setSeqLed(seq.step);

  const deg = seq.steps[seq.step];
  const now = audioCtx.currentTime;

  const dur = stepDurationSec();
  const gateDur = dur * seq.gate;

  if (deg !== null){
    if (seq.playMode === "block"){
      const root = chordRootMidiForDegree(deg);
      const tri = getTriadIntervals(deg).map(x => root + x).sort((a,b)=>a-b);
      const gap = Math.max(0.018, dur * 0.10);
      const nd = Math.max(0.04, gateDur * 0.55);
      scheduleNote(tri[0], now + 0*gap, nd);
      scheduleNote(tri[1], now + 1*gap, nd);
      scheduleNote(tri[2], now + 2*gap, nd);
      lastVoicing = tri.slice();
      document.getElementById("noteDisplay").textContent = degreeLabel(deg, seq.scale);
    }
    else if (seq.playMode === "neo"){
      const voicing = getNeoSoulVoicingForDegree(deg);
      const gap  = Math.max(0.02, dur * 0.16);
      const nDur = Math.max(0.04, gateDur * 0.55);
      scheduleNote(voicing[0], now + 0*gap, nDur);
      scheduleNote(voicing[1], now + 1*gap, nDur);
      scheduleNote(voicing[2], now + 2*gap, nDur);
      scheduleNote(voicing[3], now + 3*gap, nDur);
      lastVoicing = voicing.slice();
      document.getElementById("noteDisplay").textContent = degreeLabel(deg, seq.scale);
    }
    else if (seq.playMode === "rhodes"){
      const voicing = getRhodesVoicingForDegree(deg);
      const gap  = Math.max(0.02, dur * 0.17);
      const nDur = Math.max(0.05, gateDur * 0.62);
      scheduleNote(voicing[0], now + 0*gap, nDur);
      scheduleNote(voicing[1], now + 1*gap, nDur);
      scheduleNote(voicing[2], now + 2*gap, nDur);
      scheduleNote(voicing[3], now + 3*gap, nDur);
      lastVoicing = voicing.slice();
      document.getElementById("noteDisplay").textContent = degreeLabel(deg, seq.scale);
    }
  }

  const delay = swingDelayForStep(seq.step);
  seq.step = (seq.step + 1) % DEG_STEPS;
  seq.timer = setTimeout(seqTick, delay * 1000);
}

function seqStartStop(){
  seq.running = !seq.running;
  const btn = document.getElementById("seqPlay");
  if (seq.running){
    seq.step = 0;
    btn.textContent = "Pause";
    btn.classList.add("on");
    seqTick();
  } else {
    clearTimeout(seq.timer);
    btn.textContent = "Play";
    btn.classList.remove("on");
    clearSeqHighlights();
    document.getElementById("seqLed").textContent = "--";
    if (audioCtx) gateOff(audioCtx.currentTime);
  }
}
function seqStop(){
  seq.running = false;
  clearTimeout(seq.timer);
  seq.step = 0;
  document.getElementById("seqPlay").textContent = "Play";
  document.getElementById("seqPlay").classList.remove("on");
  clearSeqHighlights();
  document.getElementById("seqLed").textContent = "--";
  lastVoicing = null;
  if (audioCtx) gateOff(audioCtx.currentTime);
}

function cycleDegree(stepIdx){
  const cur = seq.steps[stepIdx];
  const next = (cur === null) ? 0 : (cur + 1);
  seq.steps[stepIdx] = (next > 6) ? null : next;
  renderDegGrid();
}

function renderDegGrid(){
  const grid = document.getElementById("degGrid");
  grid.innerHTML = "";
  for (let i=0;i<DEG_STEPS;i++){
    const val = seq.steps[i];
    const el = document.createElement("div");
    el.className = "degStep" + (val === null ? " off" : " on");
    el.dataset.step = i;

    const txt = document.createElement("div");
    txt.className = "txt";
    txt.textContent = (val === null) ? "·" : degreeLabel(val, seq.scale);

    el.appendChild(txt);

    el.addEventListener("pointerdown", async (e) => {
      e.preventDefault();
      cycleDegree(i);

      const d = seq.steps[i];
      if (d !== null){
        await initAudio();
        if (audioCtx.state === "suspended") await audioCtx.resume();
        const now = audioCtx.currentTime;

        if (seq.playMode === "block"){
          const root = chordRootMidiForDegree(d);
          const tri = getTriadIntervals(d).map(x => root + x).sort((a,b)=>a-b);
          scheduleNote(tri[0], now, 0.14);
          scheduleNote(tri[1], now + 0.03, 0.14);
          scheduleNote(tri[2], now + 0.06, 0.14);
          lastVoicing = tri.slice();
        } else if (seq.playMode === "neo"){
          const v = getNeoSoulVoicingForDegree(d);
          scheduleNote(v[0], now, 0.16);
          scheduleNote(v[1], now + 0.03, 0.16);
          scheduleNote(v[2], now + 0.06, 0.16);
          scheduleNote(v[3], now + 0.09, 0.16);
          lastVoicing = v.slice();
        } else {
          const v = getRhodesVoicingForDegree(d);
          scheduleNote(v[0], now, 0.18);
          scheduleNote(v[1], now + 0.03, 0.18);
          scheduleNote(v[2], now + 0.06, 0.18);
          scheduleNote(v[3], now + 0.09, 0.18);
          lastVoicing = v.slice();
        }
      }
    }, {passive:false});

    grid.appendChild(el);
  }
}

/* Wire seq controls */
document.getElementById("seqPlay").addEventListener("click", seqStartStop);
document.getElementById("seqStop").addEventListener("click", seqStop);
document.getElementById("seqClear").addEventListener("click", () => {
  seq.steps = Array.from({length:DEG_STEPS}, () => null);
  lastVoicing = null;
  renderDegGrid();
});

bindRange("bpm", (v) => {
  seq.bpm = Math.round(v);
  document.getElementById("v-bpm").textContent = seq.bpm;
});
bindRange("swing", (v) => {
  seq.swing = v / 100;
  document.getElementById("v-swing").textContent = Math.round(v) + "%";
});
bindRange("gate", (v) => {
  seq.gate = v / 100;
  document.getElementById("v-gate").textContent = Math.round(v) + "%";
});

document.getElementById("v-bpm").textContent = seq.bpm;
document.getElementById("v-swing").textContent = Math.round(seq.swing*100) + "%";
document.getElementById("v-gate").textContent = Math.round(seq.gate*100) + "%";

document.getElementById("keySel").addEventListener("change", (e) => {
  seq.keyPc = +e.target.value;
  lastVoicing = null;
});
document.getElementById("scaleMaj").addEventListener("click", () => {
  seq.scale = "maj";
  document.getElementById("scaleMaj").classList.add("active");
  document.getElementById("scaleMin").classList.remove("active");
  lastVoicing = null;
  renderDegGrid();
});
document.getElementById("scaleMin").addEventListener("click", () => {
  seq.scale = "min";
  document.getElementById("scaleMin").classList.add("active");
  document.getElementById("scaleMaj").classList.remove("active");
  lastVoicing = null;
  renderDegGrid();
});

function setPlayMode(m){
  seq.playMode = m;
  document.getElementById("pmBlock").classList.toggle("active", m==="block");
  document.getElementById("pmSmooth").classList.toggle("active", m==="neo");
  document.getElementById("pmRhodes").classList.toggle("active", m==="rhodes");
  lastVoicing = null;
}
document.getElementById("pmBlock").addEventListener("click", () => setPlayMode("block"));
document.getElementById("pmSmooth").addEventListener("click", () => setPlayMode("neo"));
document.getElementById("pmRhodes").addEventListener("click", () => setPlayMode("rhodes"));

renderDegGrid();

/* Default pattern */
(function seedPattern(){
  const prog = [0,5,1,4]; // I vi ii V
  for (let i=0;i<DEG_STEPS;i++){
    if (i % 4 === 0) seq.steps[i] = prog[(i/4)%prog.length];
    else seq.steps[i] = null;
  }
  renderDegGrid();
})();

/* ============================================================
   Keyboard (touch-first)
============================================================ */
const startMidi = 48;
const numOctaves = 3;
const whitePattern = [0,2,4,5,7,9,11];
const blackPattern = [1,3,null,6,8,10,null];

const whiteKeysEl = document.getElementById("whiteKeys");
const blackKeysEl = document.getElementById("blackKeys");
const pianoEl = document.getElementById("piano");

for (let o=0;o<numOctaves;o++){
  for (let i=0;i<7;i++){
    const midi = startMidi + o*12 + whitePattern[i];
    const key = document.createElement("div");
    key.className = "white-key";
    key.dataset.midi = midi;

    const down = (e) => { e.preventDefault(); playNote(midi); key.classList.add("active"); };
    const up   = (e) => { e.preventDefault(); stopNote(); key.classList.remove("active"); };

    key.addEventListener("touchstart", down, {passive:false});
    key.addEventListener("touchend", up, {passive:false});
    key.addEventListener("mousedown", (e)=>{ down(e); });
    key.addEventListener("mouseup", (e)=>{ up(e); });
    key.addEventListener("mouseleave", ()=>{ key.classList.remove("active"); });

    whiteKeysEl.appendChild(key);
  }
}

function buildBlackKeys(){
  blackKeysEl.innerHTML = "";
  const totalWhites = numOctaves * 7;
  const pianoW = pianoEl.clientWidth || 800;
  const whiteW = pianoW / totalWhites;

  let whiteIdx = 0;
  for (let o=0;o<numOctaves;o++){
    for (let i=0;i<7;i++){
      const semi = blackPattern[i];
      if (semi !== null){
        const midi = startMidi + o*12 + semi;
        const leftPct = ((whiteIdx + 0.65) * whiteW / pianoW * 100);
        const widthPct = (whiteW * 0.6 / pianoW * 100);

        const key = document.createElement("div");
        key.className = "black-key";
        key.dataset.midi = midi;
        key.style.left = leftPct + "%";
        key.style.width = widthPct + "%";

        const down = (e)=>{ e.preventDefault(); e.stopPropagation(); playNote(midi); key.classList.add("active"); };
        const up   = (e)=>{ e.preventDefault(); stopNote(); key.classList.remove("active"); };

        key.addEventListener("touchstart", down, {passive:false});
        key.addEventListener("touchend", up, {passive:false});
        key.addEventListener("mousedown", down);
        key.addEventListener("mouseup", up);
        key.addEventListener("mouseleave", ()=>{ key.classList.remove("active"); });

        blackKeysEl.appendChild(key);
      }
      whiteIdx++;
    }
  }
}
window.addEventListener("load", buildBlackKeys);
window.addEventListener("resize", buildBlackKeys);

const keyMap = {
  'a': 48, 'w': 49, 's': 50, 'e': 51, 'd': 52, 'f': 53,
  't': 54, 'g': 55, 'y': 56, 'h': 57, 'u': 58, 'j': 59,
  'k': 60, 'o': 61, 'l': 62, 'p': 63, ';': 64
};
document.addEventListener("keydown", e => {
  if (e.repeat) return;
  if (e.key === " "){
    e.preventDefault();
    seqStartStop();
    return;
  }
  const midi = keyMap[e.key.toLowerCase()];
  if (midi !== undefined) playNote(midi);
});
document.addEventListener("keyup", e => {
  const midi = keyMap[e.key.toLowerCase()];
  if (midi !== undefined && currentNote === midi) stopNote();
});
</script>
</body>
</html>
