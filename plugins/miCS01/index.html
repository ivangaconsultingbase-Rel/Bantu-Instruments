async function addWorkletModuleSafe(ctx, code) {
  // 1) Try Blob URL
  try {
    const blob = new Blob([code], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    try {
      await ctx.audioWorklet.addModule(blobUrl);
      return { ok: true, method: 'blob' };
    } finally {
      URL.revokeObjectURL(blobUrl);
    }
  } catch (e1) {
    console.warn('[Worklet] Blob URL failed, trying data URL…', e1);
  }

  // 2) Try data URL (often works on iOS where blob fails)
  try {
    const dataUrl =
      'data:application/javascript;charset=utf-8,' +
      encodeURIComponent(code);
    await ctx.audioWorklet.addModule(dataUrl);
    return { ok: true, method: 'data' };
  } catch (e2) {
    console.error('[Worklet] Data URL failed too.', e2);
    throw e2;
  }
}

async function initAudio() {
  if (audioCtx) return;
  setStatus('init…');

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Worklet load (robust)
  setStatus('worklet…');
  await addWorkletModuleSafe(audioCtx, WORKLET_CODE);

  // Create node
  workletNode = new AudioWorkletNode(audioCtx, 'plaits-processor', {
    numberOfOutputs: 1,
    outputChannelCount: [1],
  });

  masterGain = audioCtx.createGain();
  masterGain.gain.value = P.volume;

  fxOutputGain = audioCtx.createGain();
  fxOutputGain.gain.value = 1.0;

  // VU analyser (post FX)
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0.85;

  // --- FX graph ---
  tapeInputGain = audioCtx.createGain();
  tapeInputGain.gain.value = FX.tapeDrive;

  tapeWaveshaper = audioCtx.createWaveShaper();
  tapeWaveshaper.curve = makeSatCurve(FX.tapeDrive * 8);
  tapeWaveshaper.oversample = '4x';

  tapeToneFilter = audioCtx.createBiquadFilter();
  tapeToneFilter.type = 'lowpass';
  tapeToneFilter.frequency.value = FX.tapeTone;

  tapeWowOsc = audioCtx.createOscillator();
  tapeWowOsc.type = 'sine';
  tapeWowOsc.frequency.value = 0.8;

  tapeWowGain = audioCtx.createGain();
  tapeWowGain.gain.value = FX.tapeWow * 5;

  tapeWowOsc.connect(tapeWowGain);
  tapeWowGain.connect(tapeToneFilter.frequency);
  tapeWowOsc.start();

  tapeDryGain = audioCtx.createGain();
  tapeDryGain.gain.value = FX.tapeOn ? (1 - FX.tapeMix) : 1;

  tapeWetGain = audioCtx.createGain();
  tapeWetGain.gain.value = FX.tapeOn ? FX.tapeMix : 0;

  tapeOutGain = audioCtx.createGain();
  tapeOutGain.gain.value = 0.7;

  // Delay
  delayNode = audioCtx.createDelay(2.0);
  delayNode.delayTime.value = FX.echoTime;

  delayFeedGain = audioCtx.createGain();
  delayFeedGain.gain.value = FX.echoFeedback;

  delayDryGain = audioCtx.createGain();
  delayDryGain.gain.value = 1;

  delayWetGain = audioCtx.createGain();
  delayWetGain.gain.value = FX.echoOn ? FX.echoMix : 0;

  // Reverb
  reverbNode = audioCtx.createConvolver();
  reverbNode.buffer = buildReverbIR(FX.reverbSize);

  reverbDryGain = audioCtx.createGain();
  reverbDryGain.gain.value = 1 - (FX.echoOn ? FX.reverbMix : 0);

  reverbWetGain = audioCtx.createGain();
  reverbWetGain.gain.value = FX.echoOn ? FX.reverbMix : 0;

  // --- Wiring ---
  workletNode.connect(masterGain);

  masterGain.connect(tapeDryGain);

  masterGain.connect(tapeInputGain);
  tapeInputGain.connect(tapeWaveshaper);
  tapeWaveshaper.connect(tapeToneFilter);
  tapeToneFilter.connect(tapeWetGain);

  tapeDryGain.connect(tapeOutGain);
  tapeWetGain.connect(tapeOutGain);

  tapeOutGain.connect(delayDryGain);
  tapeOutGain.connect(delayNode);

  delayNode.connect(delayFeedGain);
  delayFeedGain.connect(delayNode);

  delayNode.connect(delayWetGain);

  const delayMix = audioCtx.createGain();
  delayMix.gain.value = 1;

  delayDryGain.connect(delayMix);
  delayWetGain.connect(delayMix);

  delayMix.connect(reverbDryGain);
  delayMix.connect(reverbNode);
  reverbNode.connect(reverbWetGain);

  reverbDryGain.connect(fxOutputGain);
  reverbWetGain.connect(fxOutputGain);

  fxOutputGain.connect(analyser);
  analyser.connect(audioCtx.destination);

  // Send params
  sendAllParams();

  setStatus(audioCtx.state);
}
