<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Yamaha CS01 — Plaits Engines</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Share+Tech+Mono&display=swap');
*{box-sizing:border-box;margin:0;padding:0;}
body{background:#111;display:flex;justify-content:center;align-items:flex-start;min-height:100vh;font-family:'Rajdhani',sans-serif;padding:20px 14px;}
.synth-wrapper{display:flex;flex-direction:column;gap:0;width:100%;max-width:1160px;}

/* TOP PANEL */
.synth-body{background:linear-gradient(180deg,#6b7272 0%,#5c6060 60%,#505555 100%);border-radius:10px 10px 0 0;padding:13px 14px;border:2px solid #3a3f3f;border-bottom:none;box-shadow:inset 0 1px 0 rgba(255,255,255,0.18);}
.top-panel{display:flex;gap:7px;align-items:stretch;}
.section{background:rgba(0,0,0,0.18);border:1px solid rgba(0,0,0,0.35);border-radius:4px;padding:7px 9px 9px;display:flex;flex-direction:column;}
.section-label{color:#5dd4e8;font-size:9px;font-weight:700;letter-spacing:2px;text-transform:uppercase;margin-bottom:6px;text-align:center;}

/* Ribbon */
.pitch-mod-section{width:118px;flex-shrink:0;}
.pitch-mod-inner{display:flex;gap:7px;flex:1;}
.ribbon-container{flex:1;display:flex;flex-direction:column;align-items:center;gap:3px;}
.ribbon{width:32px;flex:1;min-height:68px;background:linear-gradient(180deg,#888 0%,#6a6a6a 100%);border-radius:3px;border:1px solid #333;position:relative;cursor:ns-resize;}
.ribbon::after{content:'';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:20px;height:3px;background:rgba(255,255,255,0.45);border-radius:2px;}
.vco-vcf-switch{margin-top:6px;display:flex;justify-content:center;}
.toggle-switch{display:flex;background:rgba(0,0,0,0.4);border-radius:3px;overflow:hidden;border:1px solid #333;}
.toggle-opt{padding:2px 7px;font-size:8px;color:#888;cursor:pointer;transition:all 0.1s;user-select:none;}
.toggle-opt.active{background:#5dd4e8;color:#000;}

/* Sliders */
.sliders-row{display:flex;gap:5px;align-items:flex-end;flex:1;}
.slider-col{display:flex;flex-direction:column;align-items:center;gap:3px;}
.slider-col label{color:#bbb;font-size:6.5px;letter-spacing:0.3px;text-transform:uppercase;text-align:center;line-height:1.2;}
.vslider-track{width:15px;height:82px;background:linear-gradient(180deg,#1e1e1e 0%,#141414 100%);border-radius:3px;border:1px solid #0a0a0a;position:relative;cursor:pointer;box-shadow:inset 0 2px 5px rgba(0,0,0,0.7);}
.vslider-handle{position:absolute;left:-5px;right:-5px;height:13px;background:linear-gradient(180deg,#c8c8c8 0%,#888 50%,#a8a8a8 100%);border-radius:2px;border:1px solid #555;box-shadow:0 2px 4px rgba(0,0,0,0.6);cursor:ns-resize;}
.vslider-handle::after{content:'';position:absolute;left:2px;right:2px;top:50%;transform:translateY(-50%);height:2px;background:#5dd4e8;border-radius:1px;}
.wave-btn{background:rgba(0,0,0,0.32);border:1px solid #444;color:#bbb;font-size:8px;padding:2px 4px;border-radius:2px;cursor:pointer;text-align:center;font-family:'Share Tech Mono',monospace;transition:all 0.1s;user-select:none;}
.wave-btn.active,.wave-btn:hover{background:#5dd4e8;color:#000;border-color:#5dd4e8;}
.led{width:7px;height:7px;border-radius:50%;background:#333;border:1px solid #222;cursor:pointer;}
.led.on{background:#5dd4e8;box-shadow:0 0 5px #5dd4e8;}

/* PLAITS ENGINE PANEL */
.plaits-section{flex:1.5;}
.engine-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:3px;margin-bottom:7px;}
.eng-btn{background:rgba(0,0,0,0.35);border:1px solid #444;color:#bbb;font-size:7.5px;padding:3px 4px;border-radius:2px;cursor:pointer;text-align:center;font-family:'Rajdhani',sans-serif;font-weight:600;letter-spacing:0.5px;text-transform:uppercase;transition:all 0.1s;user-select:none;line-height:1.2;}
.eng-btn:hover{border-color:#e8c44a;color:#e8c44a;}
.eng-btn.active{background:rgba(232,196,74,0.2);border-color:#e8c44a;color:#e8c44a;box-shadow:0 0 4px rgba(232,196,74,0.3);}
.eng-desc{color:#666;font-size:7px;letter-spacing:0.5px;margin-top:3px;text-align:center;font-style:italic;}

/* SEQ PANEL */
.seq-panel{background:linear-gradient(180deg,#2e3232 0%,#252929 100%);border-radius:0 0 10px 10px;border:2px solid #1a1e1e;border-top:1px solid #3a3f3f;display:flex;overflow:hidden;}
.brand-panel{width:165px;flex-shrink:0;background:linear-gradient(180deg,#3e4444 0%,#313636 100%);border-right:2px solid #1a1e1e;padding:11px 13px;display:flex;flex-direction:column;gap:9px;}
.brand-yamaha{color:#fff;font-size:12px;font-weight:700;letter-spacing:1px;}
.brand-synth{color:#aaa;font-size:7px;letter-spacing:3px;text-transform:uppercase;}
.brand-cs01{font-size:28px;font-weight:900;color:#eee;font-family:'Share Tech Mono',monospace;letter-spacing:-1px;line-height:1;}
.knob-group{display:flex;flex-direction:column;align-items:center;gap:4px;}
.knob-label{color:#5dd4e8;font-size:7px;letter-spacing:1px;text-transform:uppercase;text-align:center;line-height:1.3;}
.knob{width:42px;height:42px;border-radius:50%;background:radial-gradient(circle at 35% 35%,#555 0%,#1e1e1e 100%);border:2px solid #0e0e0e;box-shadow:0 4px 10px rgba(0,0,0,0.7),inset 0 1px 0 rgba(255,255,255,0.1);position:relative;cursor:pointer;user-select:none;}
.knob::after{content:'';position:absolute;width:3px;height:12px;background:#5dd4e8;border-radius:2px;left:50%;top:5px;transform-origin:50% calc(100% + 9px);transform:translateX(-50%);}
.note-display{background:rgba(0,0,0,0.7);border:1px solid #5dd4e8;border-radius:3px;padding:3px 8px;color:#5dd4e8;font-family:'Share Tech Mono',monospace;font-size:12px;text-align:center;letter-spacing:1px;}
.sequencer{flex:1;display:flex;flex-direction:column;padding:9px 13px 11px;gap:7px;min-width:0;}
.seq-controls{display:flex;align-items:center;gap:7px;flex-wrap:wrap;}
.seq-btn{background:rgba(0,0,0,0.5);border:1px solid #555;color:#ccc;font-family:'Rajdhani',sans-serif;font-size:11px;font-weight:700;letter-spacing:1px;padding:4px 12px;border-radius:3px;cursor:pointer;transition:all 0.12s;text-transform:uppercase;user-select:none;}
.seq-btn:hover{border-color:#5dd4e8;color:#5dd4e8;}
.seq-btn.playing{background:#5dd4e8;color:#000;border-color:#5dd4e8;}
.seq-ctrl-group{display:flex;align-items:center;gap:5px;}
.seq-ctrl-label{color:#5dd4e8;font-size:9px;letter-spacing:1px;text-transform:uppercase;}
.bpm-display{background:#000;border:1px solid #5dd4e8;color:#5dd4e8;font-family:'Share Tech Mono',monospace;font-size:17px;padding:2px 9px;border-radius:3px;min-width:54px;text-align:center;cursor:ns-resize;user-select:none;}
.icon-btn{background:rgba(0,0,0,0.4);border:1px solid #444;color:#aaa;width:21px;height:21px;border-radius:3px;cursor:pointer;font-size:13px;line-height:1;display:flex;align-items:center;justify-content:center;transition:all 0.1s;user-select:none;}
.icon-btn:hover{border-color:#5dd4e8;color:#5dd4e8;}
.steps-select{background:rgba(0,0,0,0.5);border:1px solid #444;color:#ccc;font-family:'Rajdhani',sans-serif;font-size:11px;padding:3px 6px;border-radius:3px;cursor:pointer;outline:none;}
.steps-select option{background:#222;}
input[type=range].slider-h{-webkit-appearance:none;height:4px;background:#333;border-radius:2px;outline:none;cursor:pointer;width:68px;}
input[type=range].slider-h::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:50%;background:#5dd4e8;cursor:pointer;}
.pat-btn{background:rgba(0,0,0,0.4);border:1px solid #444;color:#888;font-family:'Share Tech Mono',monospace;font-size:9px;padding:3px 7px;border-radius:3px;cursor:pointer;transition:all 0.1s;user-select:none;}
.pat-btn.active{background:rgba(93,212,232,0.2);border-color:#5dd4e8;color:#5dd4e8;}
.seq-step-headers{display:flex;align-items:center;gap:2px;padding-left:34px;user-select:none;}
.seq-step-num{flex:1;color:#444;font-size:7px;font-family:'Share Tech Mono',monospace;text-align:center;}
.seq-step-num.beat{color:#5dd4e8;}
.seq-grid-wrapper{flex:1;display:flex;flex-direction:column;gap:2px;overflow-y:auto;max-height:250px;scrollbar-width:thin;scrollbar-color:#333 #1a1a1a;}
.seq-row{display:flex;align-items:center;gap:2px;height:20px;}
.seq-row-label{width:32px;flex-shrink:0;color:#666;font-family:'Share Tech Mono',monospace;font-size:9px;text-align:right;padding-right:4px;user-select:none;}
.seq-row-label.is-c{color:#5dd4e8;font-weight:bold;}
.seq-row-label.is-sharp{color:#555;font-size:8px;}
.seq-cells{display:flex;gap:2px;flex:1;}
.seq-cell{flex:1;height:19px;border-radius:2px;background:rgba(255,255,255,0.035);border:1px solid rgba(255,255,255,0.055);cursor:pointer;transition:background 0.04s;position:relative;}
.seq-cell.beat-gap{margin-left:4px;}
.seq-cell:hover{background:rgba(93,212,232,0.18);border-color:rgba(93,212,232,0.35);}
.seq-cell.active{background:#2a7a8a;border-color:#4dc8dc;box-shadow:0 0 4px rgba(77,200,220,0.35);}
.seq-cell.playing{outline:2px solid rgba(255,255,255,0.8);outline-offset:-1px;z-index:1;}
.seq-cell.active.playing{background:#5dd4e8;border-color:#8de8f8;box-shadow:0 0 10px rgba(93,212,232,0.7);}

/* FX PANEL */
.fx-panel{background:linear-gradient(180deg,#1e2222 0%,#181c1c 100%);border:2px solid #1a1e1e;border-top:1px solid #2a2e2e;display:flex;overflow:hidden;}
.fx-unit{flex:1;display:flex;flex-direction:column;padding:11px 16px 13px;border-right:1px solid #1a1e1e;}
.fx-unit:last-child{border-right:none;}
.fx-unit-header{display:flex;align-items:center;gap:10px;margin-bottom:12px;}
.fx-unit-name{font-family:'Share Tech Mono',monospace;font-size:12px;font-weight:700;letter-spacing:2px;text-transform:uppercase;}
.fx-tape .fx-unit-name{color:#e8a44a;}
.fx-echo .fx-unit-name{color:#7ab8e8;}
.fx-bypass-btn{background:rgba(0,0,0,0.5);border:1px solid #444;border-radius:3px;padding:2px 10px;font-family:'Rajdhani',sans-serif;font-size:9px;font-weight:700;letter-spacing:1px;color:#888;cursor:pointer;transition:all 0.12s;text-transform:uppercase;user-select:none;margin-left:auto;}
.fx-tape .fx-bypass-btn.active{background:rgba(232,164,74,0.18);border-color:#e8a44a;color:#e8a44a;}
.fx-echo .fx-bypass-btn.active{background:rgba(122,184,232,0.18);border-color:#7ab8e8;color:#7ab8e8;}
.fx-controls{display:flex;gap:16px;align-items:flex-end;}
.fx-knob-group{display:flex;flex-direction:column;align-items:center;gap:5px;}
.fx-knob-label{font-size:7px;letter-spacing:1px;text-transform:uppercase;text-align:center;line-height:1.3;}
.fx-tape .fx-knob-label{color:#b87a30;}
.fx-echo .fx-knob-label{color:#5090b8;}
.fx-knob{width:46px;height:46px;border-radius:50%;position:relative;cursor:pointer;user-select:none;box-shadow:0 4px 12px rgba(0,0,0,0.7),inset 0 1px 0 rgba(255,255,255,0.08);}
.fx-knob-dot{position:absolute;width:4px;height:14px;border-radius:2px;left:50%;top:5px;transform-origin:50% calc(100%+9px);transform:translateX(-50%) rotate(-140deg);}
.fx-tape .fx-knob{background:radial-gradient(circle at 35% 35%,#5a3a18 0%,#1e1208 100%);border:2px solid #0a0805;}
.fx-tape .fx-knob-dot{background:#e8a44a;box-shadow:0 0 4px rgba(232,164,74,0.5);}
.fx-echo .fx-knob{background:radial-gradient(circle at 35% 35%,#1a3050 0%,#080d1a 100%);border:2px solid #050810;}
.fx-echo .fx-knob-dot{background:#7ab8e8;box-shadow:0 0 4px rgba(122,184,232,0.5);}
.fx-knob-val{font-family:'Share Tech Mono',monospace;font-size:9px;text-align:center;}
.fx-tape .fx-knob-val{color:#a87038;}
.fx-echo .fx-knob-val{color:#5090b8;}
.echo-viz{width:88px;height:58px;background:rgba(0,0,0,0.4);border:1px solid #1a3050;border-radius:3px;overflow:hidden;margin-left:auto;}
.synth-footer{text-align:center;color:#2a2a2a;font-size:9px;letter-spacing:2px;margin-top:5px;text-transform:uppercase;}

/* START OVERLAY (iPhone-safe) */
.overlay{
  position:fixed; inset:0;
  display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,0.75);
  backdrop-filter: blur(6px);
  z-index:9999;
  padding: max(18px, env(safe-area-inset-top)) 16px max(18px, env(safe-area-inset-bottom));
}
.overlay-card{
  width:min(520px, 100%);
  border:1px solid rgba(93,212,232,0.35);
  border-radius:16px;
  background:linear-gradient(160deg, rgba(20,24,24,0.95), rgba(0,0,0,0.65));
  box-shadow:0 30px 80px rgba(0,0,0,0.75);
  padding:16px 16px 14px;
  color:#e8f7ff;
}
.overlay-title{
  font-family:'Share Tech Mono',monospace;
  letter-spacing:0.18em;
  font-size:14px;
  color:#5dd4e8;
  margin-bottom:10px;
}
.overlay-text{
  font-size:12px;
  color:rgba(240,240,240,0.85);
  line-height:1.4;
}
.overlay-row{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; align-items:center;}
.overlay-btn{
  border:1px solid rgba(93,212,232,0.6);
  background:rgba(93,212,232,0.12);
  color:#5dd4e8;
  border-radius:12px;
  padding:10px 12px;
  font-family:'Share Tech Mono',monospace;
  font-size:11px;
  letter-spacing:0.12em;
  text-transform:uppercase;
  cursor:pointer;
  user-select:none;
}
.overlay-btn:active{transform:translateY(1px);}
.overlay-pill{
  font-family:'Share Tech Mono',monospace;
  font-size:10px;
  letter-spacing:0.12em;
  color:rgba(240,240,240,0.55);
}
.vu-wrap{
  display:flex; align-items:center; gap:10px; margin-top:12px;
  border:1px solid rgba(255,255,255,0.08);
  border-radius:12px;
  padding:10px 10px;
  background:rgba(0,0,0,0.25);
}
.vu-label{
  font-family:'Share Tech Mono',monospace;
  font-size:10px;
  letter-spacing:0.12em;
  color:rgba(240,240,240,0.65);
}
.vu{
  flex:1;
  height:10px;
  border-radius:999px;
  background:rgba(255,255,255,0.08);
  overflow:hidden;
  position:relative;
}
.vu > div{
  height:100%;
  width:0%;
  background:linear-gradient(90deg, rgba(93,212,232,0.7), rgba(232,196,74,0.7), rgba(255,80,80,0.7));
  border-radius:999px;
  transition:width 60ms linear;
}
.small-link{
  color:#5dd4e8;
  text-decoration:none;
}
.small-link:hover{text-decoration:underline;}
</style>
</head>

<body>
<div class="overlay" id="startOverlay">
  <div class="overlay-card">
    <div class="overlay-title">CS01 · AUDIO START</div>
    <div class="overlay-text">
      Pour que le son fonctionne sur Chrome / iOS, il faut démarrer l’audio via un geste utilisateur.
      <br/>Ensuite tu peux jouer en lançant <b>PLAY</b> ou en cliquant des notes dans la grille.
    </div>

    <div class="overlay-row">
      <button class="overlay-btn" id="btnStartAudio">START AUDIO</button>
      <button class="overlay-btn" id="btnPanicOverlay" style="border-color:rgba(255,120,120,0.55);color:rgba(255,200,200,0.9);background:rgba(255,80,80,0.08);">PANIC</button>
      <div class="overlay-pill">Status: <span id="audioStatus">idle</span></div>
    </div>

    <div class="vu-wrap">
      <div class="vu-label">VU</div>
      <div class="vu"><div id="vuBar"></div></div>
      <div class="overlay-pill" id="vuTxt">— dB</div>
    </div>

    <div class="overlay-text" style="margin-top:10px;color:rgba(240,240,240,0.55);">
      Astuce: si tu ne vois pas le VU bouger quand tu joues, regarde la console.
    </div>
  </div>
</div>

<div class="synth-wrapper">

  <!-- ══ TOP SYNTH PANEL ══ -->
  <div class="synth-body">
    <div class="top-panel">

      <!-- PITCH BEND / MOD -->
      <div class="section pitch-mod-section">
        <div class="section-label" style="display:flex;gap:6px;justify-content:center;font-size:8px;"><span>PITCH</span><span style="color:#555">|</span><span>MOD</span></div>
        <div class="pitch-mod-inner">
          <div class="ribbon-container">
            <div class="ribbon" id="pitchRibbon"></div>
            <span style="color:#888;font-size:7px;">0</span>
          </div>
          <div class="ribbon-container">
            <div class="ribbon" id="modRibbon"></div>
            <span style="color:#888;font-size:7px;">0</span>
          </div>
        </div>
        <div class="vco-vcf-switch">
          <div class="toggle-switch">
            <div class="toggle-opt active" id="sw-vco" onclick="setSwitch('vco')">VCO</div>
            <div class="toggle-opt" id="sw-vcf" onclick="setSwitch('vcf')">VCF</div>
          </div>
        </div>
      </div>

      <!-- LFO -->
      <div class="section" style="width:65px;">
        <div class="section-label">LFO</div>
        <div class="sliders-row" style="justify-content:center;">
          <div class="slider-col">
            <label>SPEED</label>
            <div class="vslider-track" data-param="lfoSpeed" data-min="0.1" data-max="20" data-val="3"><div class="vslider-handle"></div></div>
          </div>
        </div>
      </div>

      <!-- ◈ PLAITS OSCILLATOR SECTION ◈ -->
      <div class="section plaits-section">
        <div class="section-label" style="display:flex;align-items:center;gap:5px;justify-content:center;">
          <span style="color:#e8c44a;">◈</span> OSCILLATOR <span style="color:#888;font-size:8px;">MUTABLE INSTRUMENTS PLAITS</span> <span style="color:#e8c44a;">◈</span>
        </div>
        <div style="display:flex;gap:8px;flex:1;">
          <!-- Engine selector -->
          <div style="display:flex;flex-direction:column;gap:0;">
            <div style="color:#e8c44a;font-size:7px;letter-spacing:1px;margin-bottom:4px;text-align:center;">ENGINE</div>
            <div id="engineBtns" class="engine-grid" style="grid-template-columns:1fr 1fr;">
              <div class="eng-btn active" onclick="setEngine(0,this)" data-desc="VA dual — detuned saw/sq">VA</div>
              <div class="eng-btn" onclick="setEngine(1,this)" data-desc="Wavefolder triangle">FOLD</div>
              <div class="eng-btn" onclick="setEngine(2,this)" data-desc="2-op FM + feedback">FM</div>
              <div class="eng-btn" onclick="setEngine(3,this)" data-desc="VOSIM/Grainlet formant">GRAIN</div>
              <div class="eng-btn" onclick="setEngine(4,this)" data-desc="24 harmonics additive">ADDTV</div>
              <div class="eng-btn" onclick="setEngine(5,this)" data-desc="8×8 wavetable morph">WAVTBL</div>
              <div class="eng-btn" onclick="setEngine(6,this)" data-desc="Supersaw 7 voices">SWARM</div>
              <div class="eng-btn" onclick="setEngine(7,this)" data-desc="Chord 4-voice poly">CHORD</div>
            </div>
            <div id="engDesc" class="eng-desc">VA dual — detuned saw/sq</div>
          </div>
          <!-- Plaits params + classic params -->
          <div class="sliders-row" style="justify-content:space-around;flex:1;align-items:flex-end;">
            <div class="slider-col">
              <label>GLISS</label>
              <div class="led on" id="led-gliss" onclick="toggleGliss()"></div>
              <div class="vslider-track" data-param="glissTime" data-min="0.01" data-max="0.5" data-val="0.08"><div class="vslider-handle"></div></div>
            </div>
            <div class="slider-col">
              <label>PITCH</label>
              <div class="vslider-track" data-param="pitchSemi" data-min="-12" data-max="12" data-val="0"><div class="vslider-handle"></div></div>
            </div>
            <div class="slider-col">
              <label>FEET</label>
              <div style="display:flex;flex-direction:column;gap:3px;">
                <div class="wave-btn" onclick="setFeet(4,this)">4'</div>
                <div class="wave-btn active" onclick="setFeet(8,this)">8'</div>
                <div class="wave-btn" onclick="setFeet(16,this)">16'</div>
                <div class="wave-btn" onclick="setFeet(32,this)">32'</div>
              </div>
            </div>
            <!-- HARMONICS -->
            <div class="slider-col">
              <label id="lbl-harm" style="color:#e8c44a;">HARMO</label>
              <div class="vslider-track" data-param="harmonics" data-min="0" data-max="1" data-val="0.5"><div class="vslider-handle"></div></div>
            </div>
            <!-- TIMBRE -->
            <div class="slider-col">
              <label id="lbl-timb" style="color:#e8c44a;">TIMBRE</label>
              <div class="vslider-track" data-param="timbre" data-min="0" data-max="1" data-val="0.5"><div class="vslider-handle"></div></div>
            </div>
            <!-- MORPH -->
            <div class="slider-col">
              <label id="lbl-morph" style="color:#e8c44a;">MORPH</label>
              <div class="vslider-track" data-param="morph" data-min="0" data-max="1" data-val="0.5"><div class="vslider-handle"></div></div>
            </div>
          </div>
        </div>
      </div>

      <!-- VCF -->
      <div class="section" style="flex:0.75;">
        <div class="section-label">VCF</div>
        <div class="sliders-row" style="justify-content:space-around;">
          <div class="slider-col">
            <label>CUT</label>
            <div class="vslider-track" data-param="cutoff" data-min="20" data-max="18000" data-val="8000"><div class="vslider-handle"></div></div>
          </div>
          <div class="slider-col">
            <label>RES</label>
            <div class="vslider-track" data-param="resonance" data-min="0.01" data-max="20" data-val="1"><div class="vslider-handle"></div></div>
          </div>
          <div class="slider-col">
            <label>EG</label>
            <div class="vslider-track" data-param="filterEgDepth" data-min="0" data-max="1" data-val="0"><div class="vslider-handle"></div></div>
          </div>
        </div>
      </div>

      <!-- VCA -->
      <div class="section" style="width:65px;">
        <div class="section-label">VCA</div>
        <div class="sliders-row" style="justify-content:center;">
          <div class="slider-col">
            <label>DEPTH</label>
            <div class="vslider-track" data-param="vcaDepth" data-min="0.05" data-max="1" data-val="0.8"><div class="vslider-handle"></div></div>
          </div>
        </div>
      </div>

      <!-- EG -->
      <div class="section" style="flex:0.9;">
        <div class="section-label">EG</div>
        <div class="sliders-row" style="justify-content:space-around;">
          <div class="slider-col">
            <label>ATK</label>
            <div class="vslider-track" data-param="attack" data-min="0.001" data-max="4" data-val="0.01"><div class="vslider-handle"></div></div>
          </div>
          <div class="slider-col">
            <label>DEC</label>
            <div class="vslider-track" data-param="decay" data-min="0.001" data-max="4" data-val="0.3"><div class="vslider-handle"></div></div>
          </div>
          <div class="slider-col">
            <label>SUS</label>
            <div class="vslider-track" data-param="sustain" data-min="0" data-max="1" data-val="0.7"><div class="vslider-handle"></div></div>
          </div>
          <div class="slider-col">
            <label>REL</label>
            <div class="vslider-track" data-param="release" data-min="0.001" data-max="6" data-val="0.5"><div class="vslider-handle"></div></div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- ══ SEQUENCER ══ -->
  <div class="seq-panel">
    <div class="brand-panel">
      <div>
        <div class="brand-yamaha">YAMAHA</div>
        <div class="brand-synth">SYNTHESIZER</div>
        <div class="brand-cs01">CS01</div>
      </div>

      <div class="knob-group">
        <div class="knob-label">VOLUME</div>
        <div class="knob" id="knob-vol" data-param="volume" data-min="0" data-max="1" data-val="0.7"
          style="background:radial-gradient(circle at 35% 35%,#444 0%,#111 100%);">
          <div style="position:absolute;width:6px;height:6px;background:#cc0000;border-radius:50%;top:4px;left:50%;transform:translateX(-50%);box-shadow:0 0 5px #f00;"></div>
        </div>
        <div class="note-display" id="noteDisplay">---</div>
      </div>

      <div>
        <div style="color:#5dd4e8;font-size:8px;letter-spacing:1px;margin-bottom:4px;">PATTERN</div>
        <div style="display:flex;gap:4px;" id="patternBtns">
          <div class="pat-btn active" onclick="loadPattern(0,this)">A</div>
          <div class="pat-btn" onclick="loadPattern(1,this)">B</div>
          <div class="pat-btn" onclick="loadPattern(2,this)">C</div>
          <div class="pat-btn" onclick="loadPattern(3,this)">D</div>
        </div>
      </div>
    </div>

    <div class="sequencer">
      <div class="seq-controls">
        <button class="seq-btn" id="btnPlay" onclick="seqToggle()">▶ PLAY</button>
        <button class="seq-btn" onclick="seqStop()">■ STOP</button>
        <button class="seq-btn" onclick="panic()" style="border-color:rgba(255,120,120,0.55);color:rgba(255,200,200,0.9);">PANIC</button>

        <div class="seq-ctrl-group">
          <span class="seq-ctrl-label">BPM</span>
          <div class="icon-btn" onmousedown="startBpmChange(-1)" onmouseup="stopBpmChange()" onmouseleave="stopBpmChange()">−</div>
          <div class="bpm-display" id="bpmDisplay">120</div>
          <div class="icon-btn" onmousedown="startBpmChange(1)" onmouseup="stopBpmChange()" onmouseleave="stopBpmChange()">+</div>
        </div>
        <div class="seq-ctrl-group">
          <span class="seq-ctrl-label">STEPS</span>
          <select class="steps-select" onchange="setNumSteps(+this.value)">
            <option value="8">8</option><option value="12">12</option>
            <option value="16" selected>16</option><option value="24">24</option><option value="32">32</option>
          </select>
        </div>
        <div class="seq-ctrl-group">
          <span class="seq-ctrl-label">SWING</span>
          <input type="range" class="slider-h" id="swingSlider" min="0" max="100" value="50" oninput="swing=this.value/100">
        </div>
        <div class="seq-ctrl-group">
          <span class="seq-ctrl-label">OCT</span>
          <div class="icon-btn" onclick="scrollOctave(1)">▲</div>
          <div style="color:#ccc;font-family:'Share Tech Mono',monospace;font-size:10px;min-width:26px;text-align:center;" id="octLabel">C3</div>
          <div class="icon-btn" onclick="scrollOctave(-1)">▼</div>
        </div>
        <div class="seq-ctrl-group" style="margin-left:auto;gap:5px;">
          <button class="seq-btn" onclick="clearGrid()">CLEAR</button>
          <button class="seq-btn" onclick="randomize()">RAND</button>
        </div>
      </div>

      <div class="seq-step-headers" id="stepHeaders"></div>
      <div class="seq-grid-wrapper" id="seqGrid"></div>
    </div>
  </div>

  <!-- ══ FX PANEL ══ -->
  <div class="fx-panel">
    <!-- TAPE SATURATION -->
    <div class="fx-unit fx-tape">
      <div class="fx-unit-header">
        <div class="fx-unit-name">⊛ Tape Saturation</div>
        <button class="fx-bypass-btn active" id="tapeBypass" onclick="toggleFx('tape')">ON</button>
      </div>
      <div class="fx-controls">
        <div class="fx-knob-group">
          <div class="fx-knob-label">DRIVE</div>
          <div class="fx-knob" data-param="tapeDrive" data-min="1" data-max="30" data-val="4"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-tapeDrive">4.0</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">TONE</div>
          <div class="fx-knob" data-param="tapeTone" data-min="200" data-max="8000" data-val="3000"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-tapeTone">3k</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">WOW<br>FLUTTER</div>
          <div class="fx-knob" data-param="tapeWow" data-min="0" data-max="1" data-val="0.2"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-tapeWow">20%</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">MIX</div>
          <div class="fx-knob" data-param="tapeMix" data-min="0" data-max="1" data-val="0.6"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-tapeMix">60%</div>
        </div>
        <canvas id="tapeReel" width="76" height="76" style="margin-left:auto;opacity:0.8;"></canvas>
      </div>
    </div>
    <!-- SPACE ECHO -->
    <div class="fx-unit fx-echo">
      <div class="fx-unit-header">
        <div class="fx-unit-name">◎ Space Echo</div>
        <button class="fx-bypass-btn active" id="echoBypass" onclick="toggleFx('echo')">ON</button>
      </div>
      <div class="fx-controls">
        <div class="fx-knob-group">
          <div class="fx-knob-label">DELAY</div>
          <div class="fx-knob" data-param="echoTime" data-min="0.05" data-max="1.2" data-val="0.375"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-echoTime">375ms</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">FDBK</div>
          <div class="fx-knob" data-param="echoFeedback" data-min="0" data-max="0.92" data-val="0.4"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-echoFeedback">40%</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">SPACE</div>
          <div class="fx-knob" data-param="reverbSize" data-min="0.1" data-max="6" data-val="2.5"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-reverbSize">2.5s</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">REV<br>MIX</div>
          <div class="fx-knob" data-param="reverbMix" data-min="0" data-max="1" data-val="0.3"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-reverbMix">30%</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">ECHO<br>MIX</div>
          <div class="fx-knob" data-param="echoMix" data-min="0" data-max="1" data-val="0.4"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-echoMix">40%</div>
        </div>
        <div class="echo-viz"><canvas id="echoCanvas" width="88" height="58"></canvas></div>
      </div>
    </div>
  </div>

  <div class="synth-footer">Yamaha CS01 · Plaits-inspired Engines (MIT-style) · Web Audio API</div>
</div>

<script>
// ════════════════════════════════════════════════════════
//  PLAITS DSP — AudioWorklet code (runs in audio thread)
// ════════════════════════════════════════════════════════
const WORKLET_CODE = `
// ── Utilities ──
function clamp(x, lo, hi) { return x < lo ? lo : x > hi ? hi : x; }
function lerp(a, b, t) { return a + (b - a) * t; }
function polyblep(phase, dt) {
  if (phase < dt) { const t = phase / dt; return t+t - t*t - 1; }
  if (phase > 1 - dt) { const t = (phase - 1) / dt; return t*t + t+t + 1; }
  return 0;
}

// ── Engines (0..7) ──
class VirtualAnalogEngine {
  constructor(sr) { this.sr = sr; this.phase1 = 0; this.phase2 = 0; }
  reset() { this.phase1 = Math.random(); this.phase2 = Math.random(); }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const detuneSemitones = harmonics * 1.0;
    const f1 = clamp(freq / sr, 0.00001, 0.499);
    const f2 = clamp(freq * Math.pow(2, detuneSemitones / 12) / sr, 0.00001, 0.499);
    const pw = clamp(timbre, 0.05, 0.95);
    const mix = morph;
    for (let i = 0; i < size; i++) {
      this.phase1 += f1; if (this.phase1 >= 1) this.phase1 -= 1;
      this.phase2 += f2; if (this.phase2 >= 1) this.phase2 -= 1;
      let s1 = this.phase1 < pw ? 1 : -1;
      s1 += polyblep(this.phase1, f1);
      s1 -= polyblep((this.phase1 + 1 - pw) % 1, f1);
      s1 = s1 - pw * 2 + 1;
      let s2 = this.phase2 < pw ? 1 : -1;
      s2 += polyblep(this.phase2, f2);
      s2 -= polyblep((this.phase2 + 1 - pw) % 1, f2);
      s2 = s2 - pw * 2 + 1;
      out[i] += lerp(s1, s2, mix) * 0.5;
    }
  }
}

class WaveshapingEngine {
  constructor(sr) { this.sr = sr; this.phase = 0; }
  reset() { this.phase = Math.random(); }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const f = clamp(freq / sr, 0.00001, 0.499);
    for (let i = 0; i < size; i++) {
      this.phase += f; if (this.phase >= 1) this.phase -= 1;
      const skew = clamp(0.05 + morph * 0.9, 0.05, 0.95);
      let tri = this.phase < skew ? this.phase / skew * 2 - 1 : (1 - this.phase) / (1 - skew) * 2 - 1;
      const shape = harmonics;
      const folded = shape < 0.5
        ? lerp(tri, Math.sin(Math.PI * tri), shape * 2)
        : lerp(Math.sin(Math.PI * tri), Math.sin(Math.PI * 3 * tri) * 0.33 + Math.sin(Math.PI * tri) * 0.67, (shape - 0.5) * 2);
      let fold = folded;
      const foldAmt = timbre * 4;
      fold = fold * (1 + foldAmt);
      fold = fold - 2 * Math.round(fold / 2);
      if (fold > 1) fold = 2 - fold;
      if (fold < -1) fold = -2 - fold;
      out[i] += lerp(folded, fold, timbre) * 0.7;
    }
  }
}

class FMEngine {
  constructor(sr) { this.sr = sr; this.phase_m = 0; this.phase_c = 0; this.fb = 0; }
  reset() { this.phase_m = 0; this.phase_c = 0; this.fb = 0; }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const ratios = [0.5, 1, 1.5, 2, 3, 4, 5, 7, 8];
    const ri = harmonics * (ratios.length - 1);
    const r0 = ratios[Math.floor(ri)], r1 = ratios[Math.min(Math.ceil(ri), ratios.length-1)];
    const ratio = lerp(r0, r1, ri - Math.floor(ri));
    const fc = clamp(freq / sr, 0.00001, 0.45);
    const fm = clamp(freq * ratio / sr, 0.00001, 0.49);
    const modIdx = timbre * 8;
    const fbAmt = morph;
    for (let i = 0; i < size; i++) {
      const fbSample = this.fb * fbAmt * 4;
      this.phase_m += fm; if (this.phase_m >= 1) this.phase_m -= 1;
      const modSin = Math.sin(2 * Math.PI * (this.phase_m + fbSample));
      this.fb = modSin;
      this.phase_c += fc; if (this.phase_c >= 1) this.phase_c -= 1;
      out[i] += Math.sin(2 * Math.PI * this.phase_c + modIdx * modSin) * 0.6;
    }
  }
}

class GrainletEngine {
  constructor(sr) { this.sr = sr; this.carrierPhase = 0; this.formantPhase = 0; }
  reset() { this.carrierPhase = Math.random(); this.formantPhase = 0; }
  grainlet(cp, fp, shape, bleed) {
    const carrier = Math.sin(2 * Math.PI * fp);
    const window_ = Math.max(0, Math.cos(Math.PI * cp - Math.PI * 0.5));
    const grain = carrier * window_ * window_;
    return lerp(carrier, grain, shape) + cp * bleed;
  }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const fc = clamp(freq / sr, 0.00001, 0.4);
    const formantRatio = 1 + harmonics * 8;
    const ff = clamp(fc * formantRatio, 0.00001, 0.499);
    const shape = timbre;
    const bleed = morph * 0.1;
    for (let i = 0; i < size; i++) {
      this.carrierPhase += fc;
      let reset = false;
      if (this.carrierPhase >= 1) { this.carrierPhase -= 1; this.formantPhase = 0; reset = true; }
      this.formantPhase += ff; if (this.formantPhase >= 1) this.formantPhase -= 1;
      const s = this.grainlet(this.carrierPhase, this.formantPhase, shape, bleed);
      let blep = 0;
      if (reset) blep = polyblep(this.carrierPhase, fc) * 0.5;
      out[i] += (s + blep) * 0.65;
    }
  }
}

class AdditiveEngine {
  constructor(sr) { this.sr = sr; this.phases = new Float32Array(24); for (let i = 0; i < 24; i++) this.phases[i] = Math.random(); }
  reset() { for (let i = 0; i < 24; i++) this.phases[i] = 0; }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr, numH = 24;
    const centroid = 1 + harmonics * (numH - 1);
    const width = 0.5 + timbre * numH * 0.5;
    const peak = morph;
    const gains = new Float32Array(numH);
    let totalGain = 0;
    for (let h = 0; h < numH; h++) {
      const n = h + 1;
      const dist = Math.abs(n - centroid);
      const g = Math.exp(-dist * dist / (width * width + 0.1));
      gains[h] = Math.pow(g, 1 + peak * 4);
      totalGain += gains[h];
    }
    if (totalGain < 0.001) totalGain = 1;
    for (let i = 0; i < size; i++) {
      let s = 0;
      for (let h = 0; h < numH; h++) {
        if (gains[h] < 0.001) continue;
        const n = h + 1;
        const f = clamp(freq * n / sr, 0.00001, 0.499);
        this.phases[h] += f; if (this.phases[h] >= 1) this.phases[h] -= 1;
        s += Math.sin(2 * Math.PI * this.phases[h]) * gains[h] / totalGain;
      }
      out[i] += s * 0.7;
    }
  }
}

class WavetableEngine {
  constructor(sr) {
    this.sr = sr; this.phase = 0;
    this.WT_SIZE = 256; this.WT_COUNT = 8; this.tables = [];
    for (let t = 0; t < this.WT_COUNT; t++) {
      const tbl = new Float32Array(this.WT_SIZE);
      for (let s = 0; s < this.WT_SIZE; s++) {
        const ph = s / this.WT_SIZE;
        switch(t) {
          case 0: tbl[s] = Math.sin(2*Math.PI*ph); break;
          case 1: tbl[s] = ph < 0.5 ? ph*4-1 : 3-ph*4; break;
          case 2: tbl[s] = ph < 0.5 ? 1 : -1; break;
          case 3: tbl[s] = ph * 2 - 1; break;
          case 4: tbl[s] = 1 - ph * 2; break;
          case 5: tbl[s] = Math.sin(2*Math.PI*ph) + Math.sin(4*Math.PI*ph)*0.5 + Math.sin(6*Math.PI*ph)*0.25; break;
          case 6: tbl[s] = Math.sin(2*Math.PI*ph)*Math.sin(4*Math.PI*ph); break;
          case 7: tbl[s] = Math.sin(2*Math.PI*ph + Math.sin(4*Math.PI*ph)*1.5); break;
        }
      }
      let mx = 0; for (let s=0;s<this.WT_SIZE;s++) mx = Math.max(mx,Math.abs(tbl[s]));
      if (mx>0.001) for (let s=0;s<this.WT_SIZE;s++) tbl[s]/=mx;
      this.tables.push(tbl);
    }
  }
  reset() { this.phase = Math.random(); }
  readWT(tblIdx, phase) {
    const tbl = this.tables[Math.floor(tblIdx) % this.WT_COUNT];
    const pos = phase * this.WT_SIZE;
    const i0 = Math.floor(pos) % this.WT_SIZE;
    const i1 = (i0 + 1) % this.WT_SIZE;
    return lerp(tbl[i0], tbl[i1], pos - Math.floor(pos));
  }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const f = clamp(freq / sr, 0.00001, 0.499);
    const wtPos = timbre * (this.WT_COUNT - 1);
    const wt0 = Math.floor(wtPos);
    const wt1 = Math.min(wt0 + 1, this.WT_COUNT - 1);
    const wtFrac = wtPos - wt0;
    const distort = morph;
    const hFreq = f * (1 + Math.floor(harmonics * 3));
    for (let i = 0; i < size; i++) {
      this.phase += clamp(hFreq, 0.00001, 0.499);
      if (this.phase >= 1) this.phase -= 1;
      let ph = this.phase;
      if (distort > 0.01) {
        ph = ph < 0.5 ? ph * (0.5 + distort * 0.5) * 2 : 0.5 + (ph - 0.5) * (0.5 + (1 - distort) * 0.5) * 2;
        ph = clamp(ph, 0, 0.9999);
      }
      const s0 = this.readWT(wt0, ph);
      const s1 = this.readWT(wt1, ph);
      out[i] += lerp(s0, s1, wtFrac) * 0.7;
    }
  }
}

class SwarmEngine {
  constructor(sr) {
    this.sr = sr; this.N = 8;
    this.phases = new Float32Array(this.N);
    this.detunes = new Float32Array(this.N);
    for (let i = 0; i < this.N; i++) { this.phases[i] = Math.random(); this.detunes[i] = (i / (this.N - 1) - 0.5); }
  }
  reset() { for (let i = 0; i < this.N; i++) this.phases[i] = Math.random(); }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const spread = harmonics * 0.5;
    const pw = clamp(0.05 + timbre * 0.9, 0.05, 0.95);
    const sqMix = morph;
    for (let i = 0; i < size; i++) {
      let s = 0;
      for (let v = 0; v < this.N; v++) {
        const detuneST = this.detunes[v] * spread * 2;
        const f = clamp(freq * Math.pow(2, detuneST / 12) / sr, 0.00001, 0.499);
        this.phases[v] += f; if (this.phases[v] >= 1) this.phases[v] -= 1;
        let saw = this.phases[v] * 2 - 1;
        saw -= polyblep(this.phases[v], f);
        let sq = this.phases[v] < pw ? 1 : -1;
        sq += polyblep(this.phases[v], f);
        sq -= polyblep((this.phases[v] + 1 - pw) % 1, f);
        s += lerp(saw, sq, sqMix);
      }
      out[i] += s / this.N * 0.7;
    }
  }
}

class ChordEngine {
  constructor(sr) {
    this.sr = sr; this.N = 4;
    this.phases = new Float32Array(this.N);
    this.chords = [
      [0, 7, 12, 19],[0, 4, 7, 12],[0, 3, 7, 12],[0, 4, 7, 11],
      [0, 3, 7, 10],[0, 4, 8, 12],[0, 3, 6, 12],[0, 5, 7, 12],
      [0, 2, 7, 12],[0, 4, 7, 14],
    ];
  }
  reset() { for (let i = 0; i < this.N; i++) this.phases[i] = Math.random(); }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const chordIdx = Math.floor(harmonics * (this.chords.length - 1));
    const chord = this.chords[clamp(chordIdx, 0, this.chords.length-1)];
    const pw = clamp(0.05 + timbre * 0.9, 0.05, 0.95);
    const detune = morph * 0.005;
    for (let i = 0; i < size; i++) {
      let s = 0;
      for (let v = 0; v < this.N; v++) {
        const st = chord[v];
        const f = clamp(freq * Math.pow(2, (st + (v * detune * 12)) / 12) / sr, 0.00001, 0.499);
        this.phases[v] += f; if (this.phases[v] >= 1) this.phases[v] -= 1;
        let sq = this.phases[v] < pw ? 1 : -1;
        sq += polyblep(this.phases[v], f);
        sq -= polyblep((this.phases[v] + 1 - pw) % 1, f);
        s += sq;
      }
      out[i] += s / this.N * 0.65;
    }
  }
}

class PlaitsVoice {
  constructor(sr, midi, engineIdx) {
    this.sr = sr;
    this.midi = midi;
    this.freq = 440 * Math.pow(2, (midi - 69) / 12);
    this.alive = true;
    this.env = 0;
    this.envPhase = 'attack';
    this.filterState = 0;
    const engines = [VirtualAnalogEngine, WaveshapingEngine, FMEngine, GrainletEngine, AdditiveEngine, WavetableEngine, SwarmEngine, ChordEngine];
    const E = engines[clamp(engineIdx, 0, engines.length-1)];
    this.engine = new E(sr);
    this.engine.reset();
  }
  noteOff() { this.envPhase = 'release'; }
  processADSR(attack, decay, sustain, release) {
    const sr = this.sr;
    switch (this.envPhase) {
      case 'attack':
        this.env += 1 / (attack * sr + 1);
        if (this.env >= 1) { this.env = 1; this.envPhase = 'decay'; }
        break;
      case 'decay':
        this.env += (sustain - this.env) / (decay * sr * 0.3 + 1);
        if (Math.abs(this.env - sustain) < 0.001) { this.env = sustain; this.envPhase = 'sustain'; }
        break;
      case 'sustain':
        this.env = sustain;
        break;
      case 'release':
        this.env *= 1 - 1 / (release * sr * 0.3 + 1);
        if (this.env < 0.0001) { this.env = 0; this.alive = false; }
        break;
    }
    return this.env;
  }
  render(params, output, size) {
    const tmpBuf = new Float32Array(size);
    const freq = this.freq * params.octaveMult * Math.pow(2, params.pitchSemi / 12);
    this.engine.render(freq, params.harmonics, params.timbre, params.morph, tmpBuf, size);
    for (let i = 0; i < size; i++) {
      const env = this.processADSR(params.attack, params.decay, params.sustain, params.release);
      // params.cutoff in Hz -> normalize here
      const cutoffNorm = clamp(params.cutoff / (this.sr * 0.5), 0.001, 0.999);
      const cutEg = cutoffNorm * (1 + params.filterEgDepth * env * 4);
      const coeff = clamp(1 - Math.exp(-2 * Math.PI * clamp(cutEg, 0.001, 0.499)), 0, 1);
      this.filterState += coeff * (tmpBuf[i] - this.filterState);
      output[i] += this.filterState * env * params.vcaDepth;
    }
  }
}

class PlaitsProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.voices = new Map();
    this.params = {
      engineIdx: 0,
      harmonics: 0.5, timbre: 0.5, morph: 0.5,
      attack: 0.01, decay: 0.3, sustain: 0.7, release: 0.5,
      cutoff: 8000, // Hz !
      resonance: 0.1, filterEgDepth: 0,
      vcaDepth: 0.8,
      octaveMult: 1, pitchSemi: 0,
    };
    this.port.onmessage = (e) => {
      const { type, midi } = e.data;
      if (type === 'noteOn') {
        const old = this.voices.get(midi);
        if (old) old.alive = false;
        const voice = new PlaitsVoice(sampleRate, midi, this.params.engineIdx);
        this.voices.set(midi, voice);
      } else if (type === 'noteOff') {
        const v = this.voices.get(midi);
        if (v) v.noteOff();
      } else if (type === 'allOff') {
        const immediate = e.data.immediate;
        if (immediate) this.voices.clear();
        else this.voices.forEach(v => v.noteOff());
      } else if (type === 'setEngine') {
        this.params.engineIdx = e.data.engineIdx;
      } else if (type === 'setParam') {
        this.params[e.data.name] = e.data.value;
      }
    };
  }

  process(inputs, outputs) {
    const output = outputs[0][0];
    if (!output) return true;
    const size = output.length;
    const buf = new Float32Array(size);
    for (const [midi, voice] of this.voices) {
      if (!voice.alive) { this.voices.delete(midi); continue; }
      voice.render(this.params, buf, size);
    }
    for (let i = 0; i < size; i++) output[i] = clamp(buf[i], -1, 1);
    return true;
  }
}

registerProcessor('plaits-processor', PlaitsProcessor);
`;

// ════════════════════════════════════════════════════════
//  MAIN AUDIO CONTEXT + FX CHAIN
// ════════════════════════════════════════════════════════
let audioCtx = null;
let workletNode = null;
let masterGain = null;

// FX nodes
let tapeInputGain, tapeWaveshaper, tapeToneFilter, tapeDryGain, tapeWetGain, tapeOutGain;
let tapeWowOsc, tapeWowGain;
let delayNode, delayFeedGain, delayWetGain, delayDryGain;
let reverbNode, reverbWetGain, reverbDryGain;
let fxOutputGain;

// VU meter nodes
let analyser = null;
let vuTimer = null;

const P = {
  engineIdx: 0,
  harmonics: 0.5, timbre: 0.5, morph: 0.5,
  attack: 0.01, decay: 0.3, sustain: 0.7, release: 0.5,
  cutoff: 8000, resonance: 1, filterEgDepth: 0,
  vcaDepth: 0.8,
  octaveMult: 1, pitchSemi: 0,
  lfoSpeed: 3,
  volume: 0.7,
  gliss: true, glissTime: 0.08,
};

const FX = {
  tapeOn: true, echoOn: true,
  tapeDrive: 4, tapeTone: 3000, tapeWow: 0.2, tapeMix: 0.6,
  echoTime: 0.375, echoFeedback: 0.4,
  reverbSize: 2.5, reverbMix: 0.3, echoMix: 0.4,
};

function setStatus(txt){
  const el = document.getElementById('audioStatus');
  if (el) el.textContent = txt;
}

function makeSatCurve(drive) {
  const n = 512, curve = new Float32Array(n), k = drive;
  for (let i = 0; i < n; i++) {
    const x = (i * 2) / n - 1;
    curve[i] = (Math.PI + k) * x / (Math.PI + k * Math.abs(x));
  }
  return curve;
}

function buildReverbIR(duration) {
  const rate = audioCtx.sampleRate;
  const length = Math.floor(rate * duration);
  const ir = audioCtx.createBuffer(2, length, rate);
  for (let ch = 0; ch < 2; ch++) {
    const d = ir.getChannelData(ch);
    for (let i = 0; i < length; i++) {
      const env = Math.pow(1 - i / length, 2.5);
      d[i] = (Math.random() * 2 - 1) * env;
    }
  }
  return ir;
}

async function initAudio() {
  if (audioCtx) return;
  setStatus('init…');

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Register worklet
  const blob = new Blob([WORKLET_CODE], { type: 'application/javascript' });
  const url = URL.createObjectURL(blob);
  await audioCtx.audioWorklet.addModule(url);

  workletNode = new AudioWorkletNode(audioCtx, 'plaits-processor', {
    numberOfOutputs: 1,
    outputChannelCount: [1],
  });

  masterGain = audioCtx.createGain();
  masterGain.gain.value = P.volume;

  fxOutputGain = audioCtx.createGain();
  fxOutputGain.gain.value = 1.0;

  // VU analyser (post FX)
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0.85;

  // --- FX graph (same as yours, but with proper ordering) ---
  // Tape saturation chain
  tapeInputGain = audioCtx.createGain();
  tapeInputGain.gain.value = FX.tapeDrive;

  tapeWaveshaper = audioCtx.createWaveShaper();
  tapeWaveshaper.curve = makeSatCurve(FX.tapeDrive * 8);
  tapeWaveshaper.oversample = '4x';

  tapeToneFilter = audioCtx.createBiquadFilter();
  tapeToneFilter.type = 'lowpass';
  tapeToneFilter.frequency.value = FX.tapeTone;

  tapeWowOsc = audioCtx.createOscillator();
  tapeWowOsc.type = 'sine';
  tapeWowOsc.frequency.value = 0.8;

  tapeWowGain = audioCtx.createGain();
  tapeWowGain.gain.value = FX.tapeWow * 5;

  tapeWowOsc.connect(tapeWowGain);
  tapeWowGain.connect(tapeToneFilter.frequency);
  tapeWowOsc.start();

  tapeDryGain = audioCtx.createGain();
  tapeDryGain.gain.value = FX.tapeOn ? (1 - FX.tapeMix) : 1;

  tapeWetGain = audioCtx.createGain();
  tapeWetGain.gain.value = FX.tapeOn ? FX.tapeMix : 0;

  tapeOutGain = audioCtx.createGain();
  tapeOutGain.gain.value = 0.7;

  // Delay chain
  delayNode = audioCtx.createDelay(2.0);
  delayNode.delayTime.value = FX.echoTime;

  delayFeedGain = audioCtx.createGain();
  delayFeedGain.gain.value = FX.echoFeedback;

  delayDryGain = audioCtx.createGain();
  delayDryGain.gain.value = 1;

  delayWetGain = audioCtx.createGain();
  delayWetGain.gain.value = FX.echoOn ? FX.echoMix : 0;

  // Reverb
  reverbNode = audioCtx.createConvolver();
  reverbNode.buffer = buildReverbIR(FX.reverbSize);

  reverbDryGain = audioCtx.createGain();
  reverbDryGain.gain.value = 1 - (FX.echoOn ? FX.reverbMix : 0);

  reverbWetGain = audioCtx.createGain();
  reverbWetGain.gain.value = FX.echoOn ? FX.reverbMix : 0;

  // --- Wiring ---
  // Worklet -> masterGain -> tape split -> tapeOut -> delay -> reverb -> analyser -> destination
  workletNode.connect(masterGain);

  // tape dry path
  masterGain.connect(tapeDryGain);
  // tape wet path
  masterGain.connect(tapeInputGain);
  tapeInputGain.connect(tapeWaveshaper);
  tapeWaveshaper.connect(tapeToneFilter);
  tapeToneFilter.connect(tapeWetGain);

  tapeDryGain.connect(tapeOutGain);
  tapeWetGain.connect(tapeOutGain);

  // delay split
  tapeOutGain.connect(delayDryGain);
  tapeOutGain.connect(delayNode);

  // feedback
  delayNode.connect(delayFeedGain);
  delayFeedGain.connect(delayNode);

  // wet
  delayNode.connect(delayWetGain);

  // sum delay
  const delayMix = audioCtx.createGain();
  delayMix.gain.value = 1;

  delayDryGain.connect(delayMix);
  delayWetGain.connect(delayMix);

  // reverb split
  delayMix.connect(reverbDryGain);
  delayMix.connect(reverbNode);
  reverbNode.connect(reverbWetGain);

  // sum reverb
  reverbDryGain.connect(fxOutputGain);
  reverbWetGain.connect(fxOutputGain);

  // post FX -> analyser -> out
  fxOutputGain.connect(analyser);
  analyser.connect(audioCtx.destination);

  // Send all params to worklet (IMPORTANT: cutoff in Hz)
  sendAllParams();

  setStatus(audioCtx.state);
}

async function ensureAudioRunning() {
  await initAudio();
  if (audioCtx && audioCtx.state === 'suspended') {
    await audioCtx.resume();
  }
  setStatus(audioCtx ? audioCtx.state : 'noctx');
}

function sendAllParams() {
  if (!workletNode) return;

  // IMPORTANT: cutoff en Hz (pas normalisé)
  workletNode.port.postMessage({ type: 'setParam', name: 'cutoff', value: P.cutoff });

  [
    'harmonics','timbre','morph','attack','decay','sustain','release',
    'filterEgDepth','vcaDepth','octaveMult','pitchSemi'
  ].forEach(k => {
    workletNode.port.postMessage({ type: 'setParam', name: k, value: P[k] });
  });

  workletNode.port.postMessage({ type: 'setEngine', engineIdx: P.engineIdx });
}

function sendParam(name, value) {
  if (!workletNode) return;
  // IMPORTANT: cutoff en Hz
  workletNode.port.postMessage({ type: 'setParam', name, value });
}

function playNote(midi) {
  if (!workletNode) return;
  workletNode.port.postMessage({ type: 'noteOn', midi });
  document.getElementById('noteDisplay').textContent = midiToName(midi);
}
function stopNote(midi) {
  if (!workletNode) return;
  workletNode.port.postMessage({ type: 'noteOff', midi });
}
function stopAllNotes(immediate = false) {
  if (!workletNode) return;
  workletNode.port.postMessage({ type: 'allOff', immediate });
  document.getElementById('noteDisplay').textContent = '---';
}

function panic(){
  // coupe le séquenceur et stoppe tout
  try { seqStop(); } catch {}
  stopAllNotes(true);
  if (masterGain && audioCtx) {
    const now = audioCtx.currentTime;
    masterGain.gain.cancelScheduledValues(now);
    masterGain.gain.setTargetAtTime(P.volume, now, 0.02);
  }
}

function midiToName(midi) {
  const ns = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  return ns[midi % 12] + (Math.floor(midi / 12) - 1);
}

// ════════════════════════════════════════════════════════
//  SEQUENCER ENGINE
// ════════════════════════════════════════════════════════
const MAX_STEPS = 32, NUM_ROWS = 25;
let viewBase = 48;
let patterns = [new Map(), new Map(), new Map(), new Map()];
let currentPatIdx = 0;
function getGrid() { return patterns[currentPatIdx]; }
function cellOn(midi, step) { const g = getGrid(); return g.has(midi) && g.get(midi)[step]; }
function toggleCell(midi, step, forceVal) {
  const g = getGrid();
  if (!g.has(midi)) g.set(midi, new Array(MAX_STEPS).fill(false));
  g.get(midi)[step] = (forceVal !== undefined) ? forceVal : !g.get(midi)[step];
  refreshCell(midi, step);
}

let numSteps = 16, bpm = 120, swing = 0.5;
let seqRunning = false, currentStep = 0, stepTimer = null, bpmInterval = null;

function seqToggle() {
  if (seqRunning) {
    seqRunning = false; clearTimeout(stepTimer); stopAllNotes(false);
    document.getElementById('btnPlay').textContent = '▶ PLAY';
    document.getElementById('btnPlay').classList.remove('playing');
    clearStepHighlights();
  } else {
    ensureAudioRunning().then(() => {
      seqRunning = true; currentStep = 0;
      document.getElementById('btnPlay').textContent = '⏸ PAUSE';
      document.getElementById('btnPlay').classList.add('playing');
      tick();
    }).catch(err => {
      console.error('Audio init failed:', err);
      setStatus('error');
    });
  }
}

function seqStop() {
  seqRunning = false; clearTimeout(stepTimer); currentStep = 0;
  stopAllNotes(true);
  document.getElementById('btnPlay').textContent = '▶ PLAY';
  document.getElementById('btnPlay').classList.remove('playing');
  clearStepHighlights();
}

function tick() {
  if (!seqRunning) return;
  clearStepHighlights();
  highlightStep(currentStep);
  const notesOn = [];
  getGrid().forEach((row, midi) => { if (row[currentStep]) notesOn.push(midi); });

  // mono: on coupe puis on relance
  stopAllNotes(true);
  notesOn.forEach(m => playNote(m));
  if (!notesOn.length) document.getElementById('noteDisplay').textContent = '---';

  const s16 = 60000 / bpm / 4;
  const sw = (swing - 0.5) * 0.6;
  const delay = currentStep % 2 === 0 ? s16 * (1 + sw) : s16 * (1 - sw);
  currentStep = (currentStep + 1) % numSteps;
  stepTimer = setTimeout(tick, delay);
}

function clearStepHighlights() { document.querySelectorAll('.seq-cell.playing').forEach(c => c.classList.remove('playing')); }
function highlightStep(step) {
  getViewNotes().forEach(midi => {
    const el = document.getElementById(\`c-\${midi}-\${step}\`);
    if (el) el.classList.add('playing');
  });
}
function getViewNotes() { const a=[]; for(let i=NUM_ROWS-1;i>=0;i--) a.push(viewBase+i); return a; }

function buildGrid() {
  const gridEl = document.getElementById('seqGrid'), headersEl = document.getElementById('stepHeaders');
  gridEl.innerHTML = ''; headersEl.innerHTML = '';
  for (let s = 0; s < numSteps; s++) {
    const el = document.createElement('div');
    el.className = 'seq-step-num' + (s%4===0?' beat':'') + (s%4===0&&s>0?' beat-gap':'');
    el.textContent = s%4===0 ? String(s/4+1) : '·';
    headersEl.appendChild(el);
  }
  getViewNotes().forEach(midi => {
    const name = midiToName(midi), isSharp = name.includes('#'), isC = name.startsWith('C') && !isSharp;
    const row = document.createElement('div'); row.className = 'seq-row';
    const lbl = document.createElement('div');
    lbl.className = 'seq-row-label' + (isC?' is-c':'') + (isSharp?' is-sharp':'');
    lbl.textContent = isSharp ? '♯' : name;
    row.appendChild(lbl);
    const cells = document.createElement('div'); cells.className = 'seq-cells';
    let dragVal = null;
    for (let s = 0; s < numSteps; s++) {
      const cell = document.createElement('div');
      cell.className = 'seq-cell' + (s%4===0&&s>0?' beat-gap':'');
      cell.id = `c-${midi}-${s}`;
      if (cellOn(midi,s)) cell.classList.add('active');
      cell.addEventListener('mousedown', e => { e.preventDefault(); dragVal = !cellOn(midi,s); toggleCell(midi,s,dragVal); });
      cell.addEventListener('mouseenter', e => { if(e.buttons===1 && dragVal!==null) toggleCell(midi,s,dragVal); });
      // click note audition (optionnel)
      cell.addEventListener('dblclick', async () => {
        await ensureAudioRunning();
        playNote(midi);
        setTimeout(()=>stopNote(midi), 160);
      });
      cells.appendChild(cell);
    }
    window.addEventListener('mouseup', () => { dragVal = null; }, { passive: true });
    row.appendChild(cells); gridEl.appendChild(row);
  });
  document.getElementById('octLabel').textContent = midiToName(viewBase);
}

function refreshCell(midi, step) { const el = document.getElementById(`c-${midi}-${step}`); if(el) el.classList.toggle('active', cellOn(midi,step)); }
function scrollOctave(dir) { viewBase = Math.max(12, Math.min(72, viewBase + dir*12)); buildGrid(); }
function setNumSteps(n) { numSteps = n; if(currentStep>=n) currentStep=0; buildGrid(); }
function clearGrid() { getGrid().clear(); buildGrid(); }
function randomize() {
  getGrid().clear();
  const penta = [0,2,4,7,9];
  const notes = penta.map(i=>viewBase+i).concat(penta.map(i=>viewBase+12+i));
  for (let s=0;s<numSteps;s++) {
    if (Math.random()<0.38) {
      const midi = notes[Math.floor(Math.random()*notes.length)];
      const g = getGrid(); if(!g.has(midi)) g.set(midi,new Array(MAX_STEPS).fill(false));
      g.get(midi)[s] = true;
    }
  }
  buildGrid();
}
const savedPats = [null,null,null,null];
function loadPattern(idx,el) {
  savedPats[currentPatIdx] = new Map([...patterns[currentPatIdx]].map(([k,v])=>[k,[...v]]));
  currentPatIdx = idx;
  if(savedPats[idx]) patterns[idx] = new Map([...savedPats[idx]].map(([k,v])=>[k,[...v]]));
  document.querySelectorAll('.pat-btn').forEach((b,i) => b.classList.toggle('active', i===idx));
  buildGrid();
}

function startBpmChange(d) { changeBpm(d); bpmInterval = setInterval(()=>changeBpm(d),100); }
function stopBpmChange() { clearInterval(bpmInterval); }
function changeBpm(d) { bpm = Math.max(20,Math.min(300,bpm+d)); document.getElementById('bpmDisplay').textContent = bpm; }

// ════════════════════════════════════════════════════════
//  SLIDERS
// ════════════════════════════════════════════════════════
function initSliders() {
  document.querySelectorAll('.vslider-track').forEach(track => {
    const handle = track.querySelector('.vslider-handle');
    const param = track.dataset.param;
    const min = parseFloat(track.dataset.min);
    const max = parseFloat(track.dataset.max);
    const initVal = parseFloat(track.dataset.val);
    const H = 73;
    let pos = ((initVal-min)/(max-min))*H;
    handle.style.bottom = pos + 'px';
    P[param] = initVal;

    let dragging = false, startY, startPos;
    handle.addEventListener('mousedown', e => { dragging=true; startY=e.clientY; startPos=pos; e.preventDefault(); });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      pos = Math.max(0,Math.min(H, startPos+(startY-e.clientY)));
      handle.style.bottom = pos+'px';
      const val = min+(pos/H)*(max-min);
      applyParam(param, val);
    });
    window.addEventListener('mouseup', () => { dragging=false; });
    handle.addEventListener('touchstart', e => { dragging=true; startY=e.touches[0].clientY; startPos=pos; e.preventDefault(); },{passive:false});
    window.addEventListener('touchmove', e => {
      if (!dragging) return;
      pos = Math.max(0,Math.min(H, startPos+(startY-e.touches[0].clientY)));
      handle.style.bottom = pos+'px';
      applyParam(param, min+(pos/H)*(max-min));
    },{passive:false});
    window.addEventListener('touchend', ()=>{ dragging=false; });

    // apply initial (will send once audio is ready; harmless if node null)
    sendParam(param, initVal);
  });
}

function applyParam(param, val) {
  P[param] = val;
  sendParam(param, val);
}

// Volume knob
function initVolumeKnob() {
  const knob = document.getElementById('knob-vol');
  let val = 0.7, startY;
  const setRot = v => { knob.style.transform = `rotate(${-140+v*280}deg)`; };
  setRot(val);
  knob.addEventListener('mousedown', e => { startY=e.clientY; e.preventDefault(); });
  window.addEventListener('mousemove', e => {
    if (!e.buttons) return;
    val = Math.max(0,Math.min(1,val+(startY-e.clientY)*0.006));
    startY=e.clientY; setRot(val); P.volume=val;
    if(masterGain) masterGain.gain.value=val;
  });
}

// ════════════════════════════════════════════════════════
//  ENGINE SELECTION
// ════════════════════════════════════════════════════════
const ENGINE_LABELS = {
  0: { harm:'DETUNE', timb:'PULSE W', morph:'MIX' },
  1: { harm:'SHAPE', timb:'FOLD AMT', morph:'ASYM' },
  2: { harm:'RATIO', timb:'MOD IDX', morph:'FDBK' },
  3: { harm:'FORM RAT', timb:'SHAPE', morph:'BLEED' },
  4: { harm:'CENTROID', timb:'WIDTH', morph:'PEAK' },
  5: { harm:'WT BANK', timb:'WT POS', morph:'DISTORT' },
  6: { harm:'SPREAD', timb:'PULSE W', morph:'SAW↔SQ' },
  7: { harm:'CHORD', timb:'PULSE W', morph:'DETUNE' },
};

function setEngine(idx, el) {
  P.engineIdx = idx;
  document.querySelectorAll('.eng-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('engDesc').textContent = el.dataset.desc || '';
  const lbl = ENGINE_LABELS[idx];
  if (lbl) {
    document.getElementById('lbl-harm').textContent = lbl.harm;
    document.getElementById('lbl-timb').textContent = lbl.timb;
    document.getElementById('lbl-morph').textContent = lbl.morph;
  }
  if (workletNode) workletNode.port.postMessage({ type: 'setEngine', engineIdx: idx });
}

function setFeet(feet, el) {
  P.octaveMult = {4:2, 8:1, 16:0.5, 32:0.25}[feet];
  document.querySelectorAll('[onclick*="setFeet"]').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  sendParam('octaveMult', P.octaveMult);
}

let glissOn = true;
function toggleGliss() { glissOn = !glissOn; P.gliss = glissOn; document.getElementById('led-gliss').classList.toggle('on', glissOn); }
function setSwitch(sw) { document.getElementById('sw-vco').classList.toggle('active',sw==='vco'); document.getElementById('sw-vcf').classList.toggle('active',sw==='vcf'); }

// ════════════════════════════════════════════════════════
//  FX CONTROLS
// ════════════════════════════════════════════════════════
function toggleFx(type) {
  if (type==='tape') {
    FX.tapeOn = !FX.tapeOn;
    const btn = document.getElementById('tapeBypass');
    btn.textContent = FX.tapeOn ? 'ON' : 'OFF';
    btn.classList.toggle('active', FX.tapeOn);
    if (tapeDryGain && tapeWetGain) {
      tapeDryGain.gain.value = FX.tapeOn ? (1 - FX.tapeMix) : 1;
      tapeWetGain.gain.value = FX.tapeOn ? FX.tapeMix : 0;
    }
  } else {
    FX.echoOn = !FX.echoOn;
    const btn = document.getElementById('echoBypass');
    btn.textContent = FX.echoOn ? 'ON' : 'OFF';
    btn.classList.toggle('active', FX.echoOn);
    if (delayWetGain && reverbWetGain && reverbDryGain) {
      delayWetGain.gain.value = FX.echoOn ? FX.echoMix : 0;
      reverbWetGain.gain.value = FX.echoOn ? FX.reverbMix : 0;
      reverbDryGain.gain.value = 1 - (FX.echoOn ? FX.reverbMix : 0);
    }
  }
}

function fmtFxVal(p,v) {
  if (p==='tapeDrive') return v.toFixed(1);
  if (p==='tapeTone') return v>=1000 ? (v/1000).toFixed(1)+'k' : Math.round(v)+'Hz';
  if (['tapeWow','tapeMix','echoFeedback','echoMix','reverbMix'].includes(p)) return Math.round(v*100)+'%';
  if (p==='echoTime') return Math.round(v*1000)+'ms';
  if (p==='reverbSize') return v.toFixed(1)+'s';
  return v.toFixed(2);
}

function applyFxParam(p, v) {
  FX[p] = v;
  if (!audioCtx) return;
  switch(p) {
    case 'tapeDrive':
      tapeInputGain.gain.value=v;
      tapeWaveshaper.curve=makeSatCurve(v*8);
      break;
    case 'tapeTone':
      tapeToneFilter.frequency.value=v;
      break;
    case 'tapeWow':
      tapeWowGain.gain.value=v*5;
      break;
    case 'tapeMix':
      if (tapeDryGain && tapeWetGain) {
        if (FX.tapeOn) { tapeDryGain.gain.value=1-v; tapeWetGain.gain.value=v; }
        else { tapeDryGain.gain.value=1; tapeWetGain.gain.value=0; }
      }
      break;
    case 'echoTime':
      delayNode.delayTime.setTargetAtTime(v,audioCtx.currentTime,0.05);
      break;
    case 'echoFeedback':
      delayFeedGain.gain.value=v;
      break;
    case 'echoMix':
      if (delayWetGain) delayWetGain.gain.value = FX.echoOn ? v : 0;
      break;
    case 'reverbSize':
      reverbNode.buffer=buildReverbIR(v);
      break;
    case 'reverbMix':
      if (reverbWetGain && reverbDryGain) {
        reverbWetGain.gain.value = FX.echoOn ? v : 0;
        reverbDryGain.gain.value = 1 - (FX.echoOn ? v : 0);
      }
      break;
  }
}

function initFxKnobs() {
  document.querySelectorAll('.fx-knob').forEach(knob => {
    const p = knob.dataset.param;
    const min = parseFloat(knob.dataset.min);
    const max = parseFloat(knob.dataset.max);
    let val = parseFloat(knob.dataset.val);
    const dot = knob.querySelector('.fx-knob-dot');
    const valEl = document.getElementById('val-'+p);
    let startY;

    const set = v => {
      val = Math.max(min,Math.min(max,v));
      const pct = (val-min)/(max-min);
      dot.style.transform = `translateX(-50%) rotate(${-140+pct*280}deg)`;
      if(valEl) valEl.textContent = fmtFxVal(p,val);
      applyFxParam(p,val);
    };
    set(val);

    knob.addEventListener('mousedown', e => { startY=e.clientY; e.preventDefault(); });
    window.addEventListener('mousemove', e => {
      if (!e.buttons||startY===undefined) return;
      set(val+(startY-e.clientY)*(max-min)/160); startY=e.clientY;
    });
    knob.addEventListener('wheel', e => { e.preventDefault(); set(val+(e.deltaY<0?1:-1)*(max-min)/40); },{passive:false});
  });
}

// Tape reel animation
function initTapeReel() {
  const cv = document.getElementById('tapeReel'); if(!cv) return;
  const ctx = cv.getContext('2d'); let angle = 0;
  function draw() {
    const w=cv.width, h=cv.height, cx=w/2, cy=h/2, r=w*0.38;
    ctx.clearRect(0,0,w,h);
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.strokeStyle = seqRunning?'#a07030':'#4a3a20'; ctx.lineWidth=2; ctx.stroke();
    for (let i=0;i<6;i++) {
      const a = angle+(i/6)*Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(cx+Math.cos(a)*r*0.25, cy+Math.sin(a)*r*0.25);
      ctx.lineTo(cx+Math.cos(a)*r*0.85, cy+Math.sin(a)*r*0.85);
      ctx.strokeStyle = seqRunning?'#c08040':'#3a2a10'; ctx.lineWidth=2; ctx.stroke();
    }
    ctx.beginPath(); ctx.arc(cx,cy,r*0.22,0,Math.PI*2);
    ctx.fillStyle = seqRunning?'#8a5820':'#2a1a08'; ctx.fill();
    if(seqRunning && FX.tapeOn) angle+=0.04;
    requestAnimationFrame(draw);
  }
  draw();
}

// Echo visualizer
function initEchoViz() {
  const cv = document.getElementById('echoCanvas'); if(!cv) return;
  const ctx = cv.getContext('2d'); let phase=0;
  function draw() {
    const w=cv.width, h=cv.height;
    ctx.clearRect(0,0,w,h);
    if(FX.echoOn) {
      for (let e=0;e<4;e++) {
        const x = ((phase*20+e*w/4)%w);
        const alpha = (1-e/4)*0.7*FX.echoMix;
        const ht = h*0.5*(1-e/4)*(seqRunning?1:0.2);
        ctx.beginPath(); ctx.moveTo(x,h/2-ht); ctx.lineTo(x,h/2+ht);
        ctx.strokeStyle = `rgba(122,184,232,${alpha})`; ctx.lineWidth=2; ctx.stroke();
      }
      const g = ctx.createLinearGradient(0,0,w,0);
      g.addColorStop(0,'rgba(122,184,232,0)');
      g.addColorStop(0.5,`rgba(122,184,232,${FX.reverbMix*0.15})`);
      g.addColorStop(1,'rgba(122,184,232,0)');
      ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
    }
    if(seqRunning && FX.echoOn) phase+=0.015;
    requestAnimationFrame(draw);
  }
  draw();
}

// ════════════════════════════════════════════════════════
//  VU METER (post-FX analyser)
// ════════════════════════════════════════════════════════
function startVu() {
  if (!analyser) return;
  const bar = document.getElementById('vuBar');
  const txt = document.getElementById('vuTxt');
  const buf = new Float32Array(analyser.fftSize);

  const tick = () => {
    if (!analyser) return;
    analyser.getFloatTimeDomainData(buf);
    let sum = 0;
    for (let i=0;i<buf.length;i++) sum += buf[i]*buf[i];
    const rms = Math.sqrt(sum / buf.length);
    const db = 20 * Math.log10(Math.max(1e-6, rms));
    // map -60..0 dB to 0..100%
    const pct = Math.max(0, Math.min(1, (db + 60) / 60));
    if (bar) bar.style.width = (pct*100).toFixed(1) + '%';
    if (txt) txt.textContent = (isFinite(db) ? db.toFixed(1) : '—') + ' dB';
    vuTimer = requestAnimationFrame(tick);
  };
  if (vuTimer) cancelAnimationFrame(vuTimer);
  tick();
}

// ════════════════════════════════════════════════════════
//  START OVERLAY
// ════════════════════════════════════════════════════════
async function startAudioFromOverlay() {
  try {
    await ensureAudioRunning();
    // ping test: play a short note so you SEE the VU bouger
    playNote(60);
    setTimeout(()=>stopAllNotes(true), 120);
    startVu();
    document.getElementById('startOverlay').style.display = 'none';
  } catch (e) {
    console.error(e);
    setStatus('error');
  }
}

// Also ensure any user gesture tries to resume (safety net)
function bindGlobalResumeGestures() {
  const resume = () => { ensureAudioRunning().catch(()=>{}); };
  window.addEventListener('pointerdown', resume, { passive: true });
  window.addEventListener('touchstart', resume, { passive: true });
  window.addEventListener('keydown', resume, { passive: true });
}

// ════════════════════════════════════════════════════════
//  INIT
// ════════════════════════════════════════════════════════
window.addEventListener('DOMContentLoaded', () => {
  buildGrid();
  initSliders();
  initVolumeKnob();
  initFxKnobs();
  initTapeReel();
  initEchoViz();
  bindGlobalResumeGestures();

  const lbl = ENGINE_LABELS[0];
  document.getElementById('lbl-harm').textContent = lbl.harm;
  document.getElementById('lbl-timb').textContent = lbl.timb;
  document.getElementById('lbl-morph').textContent = lbl.morph;

  // Overlay buttons
  document.getElementById('btnStartAudio').addEventListener('click', startAudioFromOverlay);
  document.getElementById('btnPanicOverlay').addEventListener('click', () => { panic(); });

  // BPM wheel
  document.getElementById('bpmDisplay').addEventListener('wheel', e => {
    e.preventDefault();
    changeBpm(e.deltaY<0?1:-1);
  }, { passive:false });

  // default bpm display
  document.getElementById('bpmDisplay').textContent = bpm;
});
</script>
</body>
</html>
