<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />
<title>Bantu Ins. miCS01 — Plaits Engines</title>
<style>
/* NOTE:
   - Pas de Google Fonts (offline-friendly). Si tu veux les fonts, remets ton @import. */
*{box-sizing:border-box;margin:0;padding:0;}
:root{
  --vh: 1vh; /* iOS-safe viewport unit */
  --bg:#111;
  --cyan:#5dd4e8;
  --gold:#e8c44a;
  --panel:#6b7272;
  --panel2:#2e3232;
  --ink:#0a0a0a;
}
html,body{height:100%;}
body{
  background:var(--bg);
  display:flex;
  justify-content:center;
  align-items:flex-start;
  min-height: calc(var(--vh, 1vh) * 100);
  min-height: 100dvh;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  padding: max(18px, env(safe-area-inset-top)) 14px max(18px, env(safe-area-inset-bottom));
  color:#ddd;
  -webkit-text-size-adjust:100%;
  touch-action:manipulation;
  overflow-x:hidden;
  overscroll-behavior-y: none;
}
.synth-wrapper{display:flex;flex-direction:column;gap:0;width:100%;max-width:1160px;}

/* TOP PANEL */
.synth-body{
  background:linear-gradient(180deg,#6b7272 0%,#5c6060 60%,#505555 100%);
  border-radius:10px 10px 0 0;
  padding:13px 14px;
  border:2px solid #3a3f3f;
  border-bottom:none;
  box-shadow:inset 0 1px 0 rgba(255,255,255,0.18);
}
.top-panel{display:flex;gap:7px;align-items:stretch;}
.section{
  background:rgba(0,0,0,0.18);
  border:1px solid rgba(0,0,0,0.35);
  border-radius:4px;
  padding:7px 9px 9px;
  display:flex;
  flex-direction:column;
}
.section-label{
  color:var(--cyan);
  font-size:9px;
  font-weight:700;
  letter-spacing:2px;
  text-transform:uppercase;
  margin-bottom:6px;
  text-align:center;
}

/* Ribbon */
.pitch-mod-section{width:118px;flex-shrink:0;}
.pitch-mod-inner{display:flex;gap:7px;flex:1;}
.ribbon-container{flex:1;display:flex;flex-direction:column;align-items:center;gap:3px;}
.ribbon{
  width:32px;flex:1;min-height:68px;
  background:linear-gradient(180deg,#888 0%,#6a6a6a 100%);
  border-radius:3px;border:1px solid #333;
  position:relative;cursor:ns-resize;
}
.ribbon::after{
  content:'';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
  width:20px;height:3px;background:rgba(255,255,255,0.45);border-radius:2px;
}
.vco-vcf-switch{margin-top:6px;display:flex;justify-content:center;}
.toggle-switch{display:flex;background:rgba(0,0,0,0.4);border-radius:3px;overflow:hidden;border:1px solid #333;}
.toggle-opt{padding:2px 7px;font-size:8px;color:#888;cursor:pointer;transition:all 0.1s;user-select:none;}
.toggle-opt.active{background:var(--cyan);color:#000;}

/* Sliders */
.sliders-row{display:flex;gap:5px;align-items:flex-end;flex:1;}
.slider-col{display:flex;flex-direction:column;align-items:center;gap:3px;}
.slider-col label{color:#bbb;font-size:6.5px;letter-spacing:0.3px;text-transform:uppercase;text-align:center;line-height:1.2;}
.vslider-track{
  width:15px;height:82px;
  background:linear-gradient(180deg,#1e1e1e 0%,#141414 100%);
  border-radius:3px;border:1px solid #0a0a0a;
  position:relative;cursor:pointer;
  box-shadow:inset 0 2px 5px rgba(0,0,0,0.7);
}
.vslider-handle{
  position:absolute;left:-5px;right:-5px;height:13px;
  background:linear-gradient(180deg,#c8c8c8 0%,#888 50%,#a8a8a8 100%);
  border-radius:2px;border:1px solid #555;
  box-shadow:0 2px 4px rgba(0,0,0,0.6);
  cursor:ns-resize;
}
.vslider-handle::after{
  content:'';position:absolute;left:2px;right:2px;top:50%;transform:translateY(-50%);
  height:2px;background:var(--cyan);border-radius:1px;
}
.wave-btn{
  background:rgba(0,0,0,0.32);border:1px solid #444;color:#bbb;
  font-size:8px;padding:2px 4px;border-radius:2px;cursor:pointer;
  text-align:center;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  transition:all 0.1s;user-select:none;
}
.wave-btn.active,.wave-btn:hover{background:var(--cyan);color:#000;border-color:var(--cyan);}
.led{width:7px;height:7px;border-radius:50%;background:#333;border:1px solid #222;cursor:pointer;}
.led.on{background:var(--cyan);box-shadow:0 0 5px var(--cyan);}

/* PLAITS ENGINE PANEL */
.plaits-section{flex:1.5;}
.engine-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:3px;margin-bottom:7px;}
.eng-btn{
  background:rgba(0,0,0,0.35);border:1px solid #444;color:#bbb;
  font-size:7.5px;padding:3px 4px;border-radius:2px;cursor:pointer;text-align:center;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  font-weight:600;letter-spacing:0.5px;text-transform:uppercase;
  transition:all 0.1s;user-select:none;line-height:1.2;
}
.eng-btn:hover{border-color:var(--gold);color:var(--gold);}
.eng-btn.active{
  background:rgba(232,196,74,0.2);
  border-color:var(--gold);
  color:var(--gold);
  box-shadow:0 0 4px rgba(232,196,74,0.3);
}
.eng-desc{color:#666;font-size:7px;letter-spacing:0.5px;margin-top:3px;text-align:center;font-style:italic;}

/* SEQ PANEL */
.seq-panel{
  background:linear-gradient(180deg,#2e3232 0%,#252929 100%);
  border-radius:0 0 10px 10px;border:2px solid #1a1e1e;border-top:1px solid #3a3f3f;
  display:flex;overflow:hidden;
}
.brand-panel{
  width:165px;flex-shrink:0;
  background:linear-gradient(180deg,#3e4444 0%,#313636 100%);
  border-right:2px solid #1a1e1e;
  padding:11px 13px;
  display:flex;flex-direction:column;gap:9px;
}
.brand-yamaha{color:#fff;font-size:12px;font-weight:800;letter-spacing:1px;}
.brand-synth{color:#aaa;font-size:7px;letter-spacing:3px;text-transform:uppercase;}
.brand-cs01{
  font-size:28px;font-weight:900;color:#eee;
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  letter-spacing:-1px;line-height:1;
}
.knob-group{display:flex;flex-direction:column;align-items:center;gap:4px;}
.knob-label{color:var(--cyan);font-size:7px;letter-spacing:1px;text-transform:uppercase;text-align:center;line-height:1.3;}
.knob{
  width:42px;height:42px;border-radius:50%;
  background:radial-gradient(circle at 35% 35%,#555 0%,#1e1e1e 100%);
  border:2px solid #0e0e0e;
  box-shadow:0 4px 10px rgba(0,0,0,0.7),inset 0 1px 0 rgba(255,255,255,0.1);
  position:relative;cursor:pointer;user-select:none;
}
.knob::after{
  content:'';position:absolute;width:3px;height:12px;background:var(--cyan);
  border-radius:2px;left:50%;top:5px;transform-origin:50% calc(100% + 9px);
  transform:translateX(-50%);
}
.note-display{
  background:rgba(0,0,0,0.7);
  border:1px solid var(--cyan);
  border-radius:3px;padding:3px 8px;color:var(--cyan);
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size:12px;text-align:center;letter-spacing:1px;
}
.sequencer{flex:1;display:flex;flex-direction:column;padding:9px 13px 11px;gap:7px;min-width:0;}
.seq-controls{display:flex;align-items:center;gap:7px;flex-wrap:wrap;}
.seq-btn{
  background:rgba(0,0,0,0.5);border:1px solid #555;color:#ccc;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  font-size:11px;font-weight:800;letter-spacing:1px;padding:4px 12px;border-radius:3px;
  cursor:pointer;transition:all 0.12s;text-transform:uppercase;user-select:none;
}
.seq-btn:hover{border-color:var(--cyan);color:var(--cyan);}
.seq-btn.playing{background:var(--cyan);color:#000;border-color:var(--cyan);}
.seq-ctrl-group{display:flex;align-items:center;gap:5px;}
.seq-ctrl-label{color:var(--cyan);font-size:9px;letter-spacing:1px;text-transform:uppercase;}
.bpm-display{
  background:#000;border:1px solid var(--cyan);color:var(--cyan);
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size:17px;padding:2px 9px;border-radius:3px;min-width:54px;text-align:center;
  cursor:ns-resize;user-select:none;
}
.icon-btn{
  background:rgba(0,0,0,0.4);border:1px solid #444;color:#aaa;
  width:21px;height:21px;border-radius:3px;cursor:pointer;font-size:13px;line-height:1;
  display:flex;align-items:center;justify-content:center;transition:all 0.1s;user-select:none;
}
.icon-btn:hover{border-color:var(--cyan);color:var(--cyan);}
.steps-select{
  background:rgba(0,0,0,0.5);border:1px solid #444;color:#ccc;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  font-size:11px;padding:3px 6px;border-radius:3px;cursor:pointer;outline:none;
}
.steps-select option{background:#222;}
input[type=range].slider-h{-webkit-appearance:none;height:4px;background:#333;border-radius:2px;outline:none;cursor:pointer;width:68px;}
input[type=range].slider-h::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;border-radius:50%;background:var(--cyan);cursor:pointer;}
.pat-btn{
  background:rgba(0,0,0,0.4);border:1px solid #444;color:#888;
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size:9px;padding:3px 7px;border-radius:3px;cursor:pointer;transition:all 0.1s;user-select:none;
}
.pat-btn.active{background:rgba(93,212,232,0.2);border-color:var(--cyan);color:var(--cyan);}
.seq-step-headers{display:flex;align-items:center;gap:2px;padding-left:34px;user-select:none;}
.seq-step-num{flex:1;color:#444;font-size:7px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;text-align:center;}
.seq-step-num.beat{color:var(--cyan);}
.seq-grid-wrapper{
  flex:1;display:flex;flex-direction:column;gap:2px;
  overflow:auto;
  max-height: clamp(180px, calc(var(--vh, 1vh) * 35), 320px);
  scrollbar-width:thin;scrollbar-color:#333 #1a1a1a;
  -webkit-overflow-scrolling:touch;
}
.seq-row{display:flex;align-items:center;gap:2px;height:20px;}
.seq-row-label{
  width:32px;flex-shrink:0;color:#666;
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size:9px;text-align:right;padding-right:4px;user-select:none;
}
.seq-row-label.is-c{color:var(--cyan);font-weight:bold;}
.seq-row-label.is-sharp{color:#555;font-size:8px;}
.seq-cells{display:flex;gap:2px;flex:1;}
.seq-cell{
  flex:1;height:19px;border-radius:2px;background:rgba(255,255,255,0.035);
  border:1px solid rgba(255,255,255,0.055);
  cursor:pointer;transition:background 0.04s;position:relative;
}
.seq-cell.beat-gap{margin-left:4px;}
.seq-cell:hover{background:rgba(93,212,232,0.18);border-color:rgba(93,212,232,0.35);}
.seq-cell.active{background:#2a7a8a;border-color:#4dc8dc;box-shadow:0 0 4px rgba(77,200,220,0.35);}
.seq-cell.playing{outline:2px solid rgba(255,255,255,0.8);outline-offset:-1px;z-index:1;}
.seq-cell.active.playing{background:var(--cyan);border-color:#8de8f8;box-shadow:0 0 10px rgba(93,212,232,0.7);}

/* FX PANEL (hidden behind button) */
.fx-panel{
  background:linear-gradient(180deg,#1e2222 0%,#181c1c 100%);
  border:2px solid #1a1e1e;border-top:1px solid #2a2e2e;
  display:none; /* hidden by default */
  overflow:hidden;
}
.fx-panel.show{display:flex;}
.fx-unit{flex:1;display:flex;flex-direction:column;padding:11px 16px 13px;border-right:1px solid #1a1e1e;}
.fx-unit:last-child{border-right:none;}
.fx-unit-header{display:flex;align-items:center;gap:10px;margin-bottom:12px;}
.fx-unit-name{
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size:12px;font-weight:800;letter-spacing:2px;text-transform:uppercase;
}
.fx-tape .fx-unit-name{color:#e8a44a;}
.fx-echo .fx-unit-name{color:#7ab8e8;}
.fx-bypass-btn{
  background:rgba(0,0,0,0.5);border:1px solid #444;border-radius:3px;
  padding:2px 10px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  font-size:9px;font-weight:800;letter-spacing:1px;color:#888;
  cursor:pointer;transition:all 0.12s;text-transform:uppercase;user-select:none;margin-left:auto;
}
.fx-tape .fx-bypass-btn.active{background:rgba(232,164,74,0.18);border-color:#e8a44a;color:#e8a44a;}
.fx-echo .fx-bypass-btn.active{background:rgba(122,184,232,0.18);border-color:#7ab8e8;color:#7ab8e8;}
.fx-controls{display:flex;gap:16px;align-items:flex-end;}
.fx-knob-group{display:flex;flex-direction:column;align-items:center;gap:5px;}
.fx-knob-label{font-size:7px;letter-spacing:1px;text-transform:uppercase;text-align:center;line-height:1.3;}
.fx-tape .fx-knob-label{color:#b87a30;}
.fx-echo .fx-knob-label{color:#5090b8;}
.fx-knob{
  width:46px;height:46px;border-radius:50%;position:relative;cursor:pointer;user-select:none;
  box-shadow:0 4px 12px rgba(0,0,0,0.7),inset 0 1px 0 rgba(255,255,255,0.08);
}
.fx-knob-dot{
  position:absolute;width:4px;height:14px;border-radius:2px;left:50%;top:5px;
  transform-origin:50% calc(100%+9px);
  transform:translateX(-50%) rotate(-140deg);
}
.fx-tape .fx-knob{background:radial-gradient(circle at 35% 35%,#5a3a18 0%,#1e1208 100%);border:2px solid #0a0805;}
.fx-tape .fx-knob-dot{background:#e8a44a;box-shadow:0 0 4px rgba(232,164,74,0.5);}
.fx-echo .fx-knob{background:radial-gradient(circle at 35% 35%,#1a3050 0%,#080d1a 100%);border:2px solid #050810;}
.fx-echo .fx-knob-dot{background:#7ab8e8;box-shadow:0 0 4px rgba(122,184,232,0.5);}
.fx-knob-val{
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size:9px;text-align:center;
}
.fx-tape .fx-knob-val{color:#a87038;}
.fx-echo .fx-knob-val{color:#5090b8;}
.echo-viz{width:88px;height:58px;background:rgba(0,0,0,0.4);border:1px solid #1a3050;border-radius:3px;overflow:hidden;margin-left:auto;}

.synth-footer{text-align:center;color:#2a2a2a;font-size:9px;letter-spacing:2px;margin-top:5px;text-transform:uppercase;}

.hidden{display:none!important;}

/* START AUDIO overlay */
.start-overlay{
  position:fixed;inset:0;
  background:rgba(0,0,0,0.72);
  display:flex;align-items:center;justify-content:center;
  z-index:9999;
  padding:24px;
}
.start-card{
  width:min(520px,100%);
  background:linear-gradient(180deg,#2b2f2f 0%,#1a1d1d 100%);
  border:1px solid rgba(93,212,232,0.35);
  border-radius:12px;
  box-shadow:0 18px 60px rgba(0,0,0,0.55);
  padding:18px 16px;
}
.start-title{
  color:var(--cyan);
  font-weight:900;
  letter-spacing:2px;
  text-transform:uppercase;
  font-size:13px;
  margin-bottom:10px;
  text-align:center;
}
.start-text{
  color:#b9c3c3;
  font-size:12px;
  line-height:1.35;
  text-align:center;
  margin-bottom:14px;
}
.start-btn{
  width:100%;
  background:var(--cyan);
  color:#000;
  border:0;
  border-radius:10px;
  padding:12px 14px;
  font-weight:900;
  letter-spacing:1px;
  text-transform:uppercase;
  cursor:pointer;
}
.start-small{
  margin-top:10px;
  color:#7f8b8b;
  font-size:10px;
  text-align:center;
}

/* iPhone 14 / small screens */
@media (max-width: 430px){
  body{padding:12px 10px;}
  .synth-body{padding:10px 10px;}
  .top-panel{flex-wrap:wrap;}
  .pitch-mod-section{width:100%;}
  .plaits-section{flex:1;min-width:0;}
  .engine-grid{gap:4px;}
  .brand-panel{width:132px;padding:10px 10px;}
  .brand-cs01{font-size:24px;}
  .sequencer{padding:8px 10px 10px;}
  .seq-controls{gap:6px;}
  input[type=range].slider-h{width:56px;}
  .seq-grid-wrapper{max-height: clamp(180px, calc(var(--vh, 1vh) * 42), 380px);}
}

/* ─────────────────────────────────────────────
   FORCE LANDSCAPE VIEW ON MOBILE
   ───────────────────────────────────────────── */

@media screen and (orientation: portrait) and (max-width: 900px) {

  body {
    margin: 0;
    overflow: hidden;
  }

  .synth-wrapper {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 100vh;
    height: 100vw;
    transform: translate(-50%, -50%) rotate(90deg);
    transform-origin: center center;
    overflow: hidden;
  }

}
</style>
</head>
<body>

<!-- START AUDIO overlay (iOS-friendly) -->
<div class="start-overlay" id="startOverlay">
  <div class="start-card">
    <div class="start-title">Start Audio</div>
    <div class="start-text">
      iOS/Safari exige un geste utilisateur pour activer l’audio.<br/>
      Appuie sur le bouton ci-dessous, puis PLAY.
    </div>
    <button class="start-btn" id="startAudioBtn">▶ ACTIVER L’AUDIO</button>
    <div class="start-small">Tip: si tu es en mode silencieux, active le son.</div>
  </div>
</div>

<div class="synth-wrapper">

  <!-- ══ TOP SYNTH PANEL ══ -->
  <div class="synth-body">
    <div class="top-panel">

      <!-- PITCH BEND / MOD -->
      <div class="section pitch-mod-section" id="pitchModSection">
        <div class="section-label" style="display:flex;gap:6px;justify-content:center;font-size:8px;"><span>PITCH</span><span style="color:#555">|</span><span>MOD</span></div>
        <div class="pitch-mod-inner">
          <div class="ribbon-container">
            <div class="ribbon" id="pitchRibbon"></div>
            <span style="color:#888;font-size:7px;" id="pitchVal">0</span>
          </div>
          <div class="ribbon-container">
            <div class="ribbon" id="modRibbon"></div>
            <span style="color:#888;font-size:7px;" id="modVal">0</span>
          </div>
        </div>
        <div class="vco-vcf-switch">
          <div class="toggle-switch">
            <div class="toggle-opt active" id="sw-vco" onclick="setSwitch('vco')">VCO</div>
            <div class="toggle-opt" id="sw-vcf" onclick="setSwitch('vcf')">VCF</div>
          </div>
        </div>
      </div>

      <!-- LFO -->
      <div class="section" style="width:65px;">
        <div class="section-label">LFO</div>
        <div class="sliders-row" style="justify-content:center;">
          <div class="slider-col">
            <label>SPEED</label>
            <div class="vslider-track" data-param="lfoSpeed" data-min="0.1" data-max="20" data-val="3"><div class="vslider-handle"></div></div>
          </div>
        </div>
      </div>

      <!-- ◈ PLAITS OSCILLATOR SECTION ◈ -->
      <div class="section plaits-section">
        <div class="section-label" style="display:flex;align-items:center;gap:5px;justify-content:center;">
          <span style="color:#e8c44a;">◈</span> OSCILLATOR <span style="color:#888;font-size:8px;">MUTABLE INSTRUMENTS PLAITS</span> <span style="color:#e8c44a;">◈</span>
        </div>
        <div style="display:flex;gap:8px;flex:1;">
          <!-- Engine selector -->
          <div style="display:flex;flex-direction:column;gap:0;">
            <div style="color:#e8c44a;font-size:7px;letter-spacing:1px;margin-bottom:4px;text-align:center;">ENGINE</div>
            <div id="engineBtns" class="engine-grid" style="grid-template-columns:1fr 1fr;">
              <div class="eng-btn active" onclick="setEngine(0,this)" data-desc="VA dual — detuned saw/sq">VA</div>
              <div class="eng-btn" onclick="setEngine(1,this)" data-desc="Wavefolder triangle">FOLD</div>
              <div class="eng-btn" onclick="setEngine(2,this)" data-desc="2-op FM + feedback">FM</div>
              <div class="eng-btn" onclick="setEngine(3,this)" data-desc="VOSIM/Grainlet formant">GRAIN</div>
              <div class="eng-btn" onclick="setEngine(4,this)" data-desc="24 harmonics additive">ADDTV</div>
              <div class="eng-btn" onclick="setEngine(5,this)" data-desc="8×8 wavetable morph">WAVTBL</div>
              <div class="eng-btn" onclick="setEngine(6,this)" data-desc="Supersaw 7 voices">SWARM</div>
              <div class="eng-btn" onclick="setEngine(7,this)" data-desc="Chord 4-voice poly">CHORD</div>
            </div>
            <div id="engDesc" class="eng-desc">VA dual — detuned saw/sq</div>
          </div>

          <!-- Plaits params + classic params -->
          <div class="sliders-row" style="justify-content:space-around;flex:1;align-items:flex-end;">
            <div class="slider-col">
              <label>GLISS</label>
              <div class="led on" id="led-gliss" onclick="toggleGliss()"></div>
              <div class="vslider-track" data-param="glissTime" data-min="0.01" data-max="0.5" data-val="0.08"><div class="vslider-handle"></div></div>
            </div>
            <div class="slider-col">
              <label>PITCH</label>
              <div class="vslider-track" data-param="pitchSemi" data-min="-12" data-max="12" data-val="0"><div class="vslider-handle"></div></div>
            </div>
            <div class="slider-col">
              <label>FEET</label>
              <div style="display:flex;flex-direction:column;gap:3px;">
                <div class="wave-btn" onclick="setFeet(4,this)">4'</div>
                <div class="wave-btn active" onclick="setFeet(8,this)">8'</div>
                <div class="wave-btn" onclick="setFeet(16,this)">16'</div>
                <div class="wave-btn" onclick="setFeet(32,this)">32'</div>
              </div>
            </div>
            <!-- HARMONICS -->
            <div class="slider-col">
              <label id="lbl-harm" style="color:#e8c44a;">HARMO</label>
              <div class="vslider-track" data-param="harmonics" data-min="0" data-max="1" data-val="0.5"><div class="vslider-handle"></div></div>
            </div>
            <!-- TIMBRE -->
            <div class="slider-col">
              <label id="lbl-timb" style="color:#e8c44a;">TIMBRE</label>
              <div class="vslider-track" data-param="timbre" data-min="0" data-max="1" data-val="0.5"><div class="vslider-handle"></div></div>
            </div>
            <!-- MORPH -->
            <div class="slider-col">
              <label id="lbl-morph" style="color:#e8c44a;">MORPH</label>
              <div class="vslider-track" data-param="morph" data-min="0" data-max="1" data-val="0.5"><div class="vslider-handle"></div></div>
            </div>
          </div>
        </div>
      </div>

      <!-- “JUNO-ish” FILTER (POST) -->
      <div class="section" style="flex:0.75;">
        <div class="section-label">VCF (JUNO)</div>
        <div class="sliders-row" style="justify-content:space-around;">
          <div class="slider-col">
            <label>CUT</label>
            <div class="vslider-track" data-param="cutoff" data-min="20" data-max="18000" data-val="8000"><div class="vslider-handle"></div></div>
          </div>
          <div class="slider-col">
            <label>RES</label>
            <div class="vslider-track" data-param="resonance" data-min="0.01" data-max="20" data-val="1"><div class="vslider-handle"></div></div>
          </div>
          <div class="slider-col">
            <label>EG</label>
            <div class="vslider-track" data-param="filterEgDepth" data-min="0" data-max="1" data-val="0"><div class="vslider-handle"></div></div>
          </div>
        </div>
      </div>

      <!-- VCA -->
      <div class="section" style="width:65px;">
        <div class="section-label">VCA</div>
        <div class="sliders-row" style="justify-content:center;">
          <div class="slider-col">
            <label>DEPTH</label>
            <div class="vslider-track" data-param="vcaDepth" data-min="0.05" data-max="1" data-val="0.8"><div class="vslider-handle"></div></div>
          </div>
        </div>
      </div>

      <!-- EG -->
      <div class="section" style="flex:0.9;">
        <div class="section-label">EG</div>
        <div class="sliders-row" style="justify-content:space-around;">
          <div class="slider-col">
            <label>ATK</label>
            <div class="vslider-track" data-param="attack" data-min="0.001" data-max="4" data-val="0.01"><div class="vslider-handle"></div></div>
          </div>
          <div class="slider-col">
            <label>DEC</label>
            <div class="vslider-track" data-param="decay" data-min="0.001" data-max="4" data-val="0.3"><div class="vslider-handle"></div></div>
          </div>
          <div class="slider-col">
            <label>SUS</label>
            <div class="vslider-track" data-param="sustain" data-min="0" data-max="1" data-val="0.7"><div class="vslider-handle"></div></div>
          </div>
          <div class="slider-col">
            <label>REL</label>
            <div class="vslider-track" data-param="release" data-min="0.001" data-max="6" data-val="0.5"><div class="vslider-handle"></div></div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- ══ SEQUENCER ══ -->
  <div class="seq-panel">
    <div class="brand-panel">
      <div>
        <div class="brand-yamaha">BANTU Inc.</div>
        <div class="brand-synth">SYNTHESIZER</div>
        <div class="brand-cs01">miCS01</div>
      </div>
      <div class="knob-group">
        <div class="knob-label">VOLUME</div>
        <div class="knob" id="knob-vol" data-param="volume" data-min="0" data-max="1" data-val="0.7"
          style="background:radial-gradient(circle at 35% 35%,#444 0%,#111 100%);">
          <div style="position:absolute;width:6px;height:6px;background:#cc0000;border-radius:50%;top:4px;left:50%;transform:translateX(-50%);box-shadow:0 0 5px #f00;"></div>
        </div>
        <div class="note-display" id="noteDisplay">---</div>
      </div>
      <div>
        <div style="color:var(--cyan);font-size:8px;letter-spacing:1px;margin-bottom:4px;">PATTERN</div>
        <div style="display:flex;gap:4px;" id="patternBtns">
          <div class="pat-btn active" onclick="loadPattern(0,this)">A</div>
          <div class="pat-btn" onclick="loadPattern(1,this)">B</div>
          <div class="pat-btn" onclick="loadPattern(2,this)">C</div>
          <div class="pat-btn" onclick="loadPattern(3,this)">D</div>
        </div>
      </div>
    </div>

    <div class="sequencer">
      <div class="seq-controls">
        <button class="seq-btn" id="btnPlay" onclick="seqToggle()">▶ PLAY</button>
        <button class="seq-btn" onclick="seqStop()">■ STOP</button>

        <!-- NEW: FX panel toggle -->
        <button class="seq-btn" id="btnFxPanel" onclick="toggleFxPanel()">FX ▾</button>

        <!-- NEW: PITCH/MOD toggle -->
        <button class="seq-btn" id="btnPitchMod" onclick="togglePitchMod()">PITCH/MOD ▾</button>

        <div class="seq-ctrl-group">
          <span class="seq-ctrl-label">BPM</span>
          <div class="icon-btn" onmousedown="startBpmChange(-1)" onmouseup="stopBpmChange()" onmouseleave="stopBpmChange()">−</div>
          <div class="bpm-display" id="bpmDisplay">120</div>
          <div class="icon-btn" onmousedown="startBpmChange(1)" onmouseup="stopBpmChange()" onmouseleave="stopBpmChange()">+</div>
        </div>

        <div class="seq-ctrl-group">
          <span class="seq-ctrl-label">STEPS</span>
          <select class="steps-select" onchange="setNumSteps(+this.value)">
            <option value="8">8</option><option value="12">12</option>
            <option value="16" selected>16</option><option value="24">24</option><option value="32">32</option>
          </select>
        </div>

        <div class="seq-ctrl-group">
          <span class="seq-ctrl-label">SWING</span>
          <input type="range" class="slider-h" id="swingSlider" min="0" max="100" value="50" oninput="swing=this.value/100">
        </div>

        <div class="seq-ctrl-group">
          <span class="seq-ctrl-label">OCT</span>
          <div class="icon-btn" onclick="scrollOctave(1)">▲</div>
          <div style="color:#ccc;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace;font-size:10px;min-width:26px;text-align:center;" id="octLabel">C3</div>
          <div class="icon-btn" onclick="scrollOctave(-1)">▼</div>
        </div>

        <div class="seq-ctrl-group" style="margin-left:auto;gap:5px;">
          <button class="seq-btn" onclick="clearGrid()">CLEAR</button>
          <button class="seq-btn" onclick="randomize()">RAND</button>
        </div>
      </div>

      <div class="seq-step-headers" id="stepHeaders"></div>
      <div class="seq-grid-wrapper" id="seqGrid"></div>
    </div>
  </div>

  <!-- ══ FX PANEL (hidden behind FX button) ══ -->
  <div class="fx-panel" id="fxPanel">
    <!-- TAPE SATURATION -->
    <div class="fx-unit fx-tape">
      <div class="fx-unit-header">
        <div class="fx-unit-name">⊛ Tape Saturation</div>
        <!-- FX off by default -->
        <button class="fx-bypass-btn" id="tapeBypass" onclick="toggleFx('tape')">OFF</button>
      </div>
      <div class="fx-controls">
        <div class="fx-knob-group">
          <div class="fx-knob-label">DRIVE</div>
          <div class="fx-knob" data-param="tapeDrive" data-min="1" data-max="30" data-val="4"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-tapeDrive">4.0</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">TONE</div>
          <div class="fx-knob" data-param="tapeTone" data-min="200" data-max="8000" data-val="3000"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-tapeTone">3k</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">WOW<br>FLUTTER</div>
          <div class="fx-knob" data-param="tapeWow" data-min="0" data-max="1" data-val="0.2"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-tapeWow">20%</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">MIX</div>
          <div class="fx-knob" data-param="tapeMix" data-min="0" data-max="1" data-val="0.6"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-tapeMix">60%</div>
        </div>
        <canvas id="tapeReel" width="76" height="76" style="margin-left:auto;opacity:0.8;"></canvas>
      </div>
    </div>

    <!-- SPACE ECHO -->
    <div class="fx-unit fx-echo">
      <div class="fx-unit-header">
        <div class="fx-unit-name">◎ Space Echo</div>
        <!-- FX off by default -->
        <button class="fx-bypass-btn" id="echoBypass" onclick="toggleFx('echo')">OFF</button>
      </div>
      <div class="fx-controls">
        <div class="fx-knob-group">
          <div class="fx-knob-label">DELAY</div>
          <div class="fx-knob" data-param="echoTime" data-min="0.05" data-max="1.2" data-val="0.375"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-echoTime">375ms</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">FDBK</div>
          <div class="fx-knob" data-param="echoFeedback" data-min="0" data-max="0.92" data-val="0.4"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-echoFeedback">40%</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">SPACE</div>
          <div class="fx-knob" data-param="reverbSize" data-min="0.1" data-max="6" data-val="2.5"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-reverbSize">2.5s</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">REV<br>MIX</div>
          <div class="fx-knob" data-param="reverbMix" data-min="0" data-max="1" data-val="0.3"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-reverbMix">30%</div>
        </div>
        <div class="fx-knob-group">
          <div class="fx-knob-label">ECHO<br>MIX</div>
          <div class="fx-knob" data-param="echoMix" data-min="0" data-max="1" data-val="0.4"><div class="fx-knob-dot"></div></div>
          <div class="fx-knob-val" id="val-echoMix">40%</div>
        </div>
        <div class="echo-viz"><canvas id="echoCanvas" width="88" height="58"></canvas></div>
      </div>
    </div>
  </div>

  <div class="synth-footer">Bantu Inc. miCS01 · Plaits Engines · Web Audio API</div>
</div>

<script>

// iOS viewport fix: stable vh in portrait (Safari address bar)
(function setVh(){
  const set = () => {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  };
  set();
  window.addEventListener('resize', set, { passive: true });
  window.addEventListener('orientationchange', () => setTimeout(set, 120), { passive: true });
})();

// ────────────────────────────────────────────────────────
// Utilities
// ────────────────────────────────────────────────────────
function clamp(x, lo, hi) { return x < lo ? lo : x > hi ? hi : x; }
function lerp(a, b, t) { return a + (b - a) * t; }
function polyblep(phase, dt) {
  if (phase < dt) { const t = phase / dt; return t+t - t*t - 1; }
  if (phase > 1 - dt) { const t = (phase - 1) / dt; return t*t + t+t + 1; }
  return 0;
}
function noteToFreq(midi) { return 440 * Math.pow(2, (midi - 69) / 12); }
function softClip(x) { return Math.tanh(x); }

// ────────────────────────────────────────────────────────
// JUNO-ish POST FILTER (always active, after masterGain)
//  - 2 lowpass biquads in series ~ “4-pole-ish”
//  - optional HPF
//  - gentle saturation
//  - no change to PlaitsVoice
// ────────────────────────────────────────────────────────
class JunoPostFilter {
  constructor(audioCtx) {
    this.ctx = audioCtx;

    this.input = this.ctx.createGain();

    this.hpf = this.ctx.createBiquadFilter();
    this.hpf.type = 'highpass';
    this.hpf.frequency.value = 20;
    this.hpf.Q.value = 0.707;

    this.lp1 = this.ctx.createBiquadFilter();
    this.lp1.type = 'lowpass';
    this.lp1.frequency.value = 8000;
    this.lp1.Q.value = 0.707;

    this.lp2 = this.ctx.createBiquadFilter();
    this.lp2.type = 'lowpass';
    this.lp2.frequency.value = 8000;
    this.lp2.Q.value = 0.707;

    this.shaper = this.ctx.createWaveShaper();
    this.shaper.oversample = '4x';
    this.drive = 0.35;

    this.out = this.ctx.createGain();

    this.input.connect(this.hpf);
    this.hpf.connect(this.lp1);
    this.lp1.connect(this.lp2);
    this.lp2.connect(this.shaper);
    this.shaper.connect(this.out);

    this.setDrive(this.drive);
    this.setCutoff(8000);
    this.setResonance(0.2);
    this.setHpf(20);
  }

  _makeCurve(amount01) {
    const n = 512;
    const curve = new Float32Array(n);
    const k = 2 + amount01 * 18; // 2..20
    for (let i = 0; i < n; i++) {
      const x = (i * 2) / (n - 1) - 1;
      curve[i] = softClip(x * k);
    }
    return curve;
  }

  setCutoff(hz) {
    const f = Math.max(20, Math.min(hz, this.ctx.sampleRate * 0.45));
    this.lp1.frequency.setTargetAtTime(f, this.ctx.currentTime, 0.01);
    this.lp2.frequency.setTargetAtTime(f, this.ctx.currentTime, 0.01);
  }

  setResonance(amount01) {
    const a = Math.max(0, Math.min(1, amount01));
    const q = 0.707 + a * 6.5; // musical, pas trop agressif
    this.lp1.Q.setTargetAtTime(q, this.ctx.currentTime, 0.01);
    this.lp2.Q.setTargetAtTime(q, this.ctx.currentTime, 0.01);
  }

  setHpf(hz) {
    const f = Math.max(10, Math.min(hz, this.ctx.sampleRate * 0.45));
    this.hpf.frequency.setTargetAtTime(f, this.ctx.currentTime, 0.01);
  }

  setDrive(amount01) {
    this.drive = Math.max(0, Math.min(1, amount01));
    this.shaper.curve = this._makeCurve(this.drive);
  }
}

// ────────────────────────────────────────────────────────
// Engines (Plaits-inspired)
// ────────────────────────────────────────────────────────
class VirtualAnalogEngine {
  constructor(sr) { this.sr = sr; this.phase1 = 0; this.phase2 = 0; }
  reset() { this.phase1 = Math.random(); this.phase2 = Math.random(); }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const detuneSemitones = harmonics * 1.0;
    const f1 = clamp(freq / sr, 0.00001, 0.499);
    const f2 = clamp(freq * Math.pow(2, detuneSemitones / 12) / sr, 0.00001, 0.499);
    const pw = clamp(timbre, 0.05, 0.95);
    const mix = morph;
    for (let i = 0; i < size; i++) {
      this.phase1 += f1; if (this.phase1 >= 1) this.phase1 -= 1;
      this.phase2 += f2; if (this.phase2 >= 1) this.phase2 -= 1;

      let s1 = this.phase1 < pw ? 1 : -1;
      s1 += polyblep(this.phase1, f1);
      s1 -= polyblep((this.phase1 + 1 - pw) % 1, f1);
      s1 = s1 - pw * 2 + 1;

      let s2 = this.phase2 < pw ? 1 : -1;
      s2 += polyblep(this.phase2, f2);
      s2 -= polyblep((this.phase2 + 1 - pw) % 1, f2);
      s2 = s2 - pw * 2 + 1;

      out[i] += lerp(s1, s2, mix) * 0.5;
    }
  }
}

class WaveshapingEngine {
  constructor(sr) { this.sr = sr; this.phase = 0; }
  reset() { this.phase = Math.random(); }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const f = clamp(freq / sr, 0.00001, 0.499);
    for (let i = 0; i < size; i++) {
      this.phase += f;
      if (this.phase >= 1) this.phase -= 1;

      const skew = clamp(0.05 + morph * 0.9, 0.05, 0.95);
      let tri = this.phase < skew
        ? this.phase / skew * 2 - 1
        : (1 - this.phase) / (1 - skew) * 2 - 1;

      const shape = harmonics;
      const folded = shape < 0.5
        ? lerp(tri, Math.sin(Math.PI * tri), shape * 2)
        : lerp(Math.sin(Math.PI * tri), Math.sin(Math.PI * 3 * tri) * 0.33 + Math.sin(Math.PI * tri) * 0.67, (shape - 0.5) * 2);

      let fold = folded;
      const foldAmt = timbre * 4;
      fold = fold * (1 + foldAmt);
      fold = fold - 2 * Math.round(fold / 2);
      if (fold > 1) fold = 2 - fold;
      if (fold < -1) fold = -2 - fold;

      out[i] += lerp(folded, fold, timbre) * 0.7;
    }
  }
}

class FMEngine {
  constructor(sr) { this.sr = sr; this.phase_m = 0; this.phase_c = 0; this.fb = 0; }
  reset() { this.phase_m = 0; this.phase_c = 0; this.fb = 0; }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const ratios = [0.5, 1, 1.5, 2, 3, 4, 5, 7, 8];
    const ri = harmonics * (ratios.length - 1);
    const r0 = ratios[Math.floor(ri)], r1 = ratios[Math.min(Math.ceil(ri), ratios.length-1)];
    const ratio = lerp(r0, r1, ri - Math.floor(ri));

    const fc = clamp(freq / sr, 0.00001, 0.45);
    const fm = clamp(freq * ratio / sr, 0.00001, 0.49);
    const modIdx = timbre * 8;
    const fbAmt = morph;

    for (let i = 0; i < size; i++) {
      const fbSample = this.fb * fbAmt * 4;
      this.phase_m += fm;
      if (this.phase_m >= 1) this.phase_m -= 1;
      const modSin = Math.sin(2 * Math.PI * (this.phase_m + fbSample));
      this.fb = modSin;

      this.phase_c += fc;
      if (this.phase_c >= 1) this.phase_c -= 1;
      out[i] += Math.sin(2 * Math.PI * this.phase_c + modIdx * modSin) * 0.6;
    }
  }
}

class GrainletEngine {
  constructor(sr) { this.sr = sr; this.carrierPhase = 0; this.formantPhase = 0; }
  reset() { this.carrierPhase = Math.random(); this.formantPhase = 0; }
  grainlet(carrierPhase, formantPhase, shape, bleed) {
    const carrier = Math.sin(2 * Math.PI * formantPhase);
    const window_ = Math.max(0, Math.cos(Math.PI * carrierPhase - Math.PI * 0.5));
    const grain = carrier * window_ * window_;
    return lerp(carrier, grain, shape) + carrierPhase * bleed;
  }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const fc = clamp(freq / sr, 0.00001, 0.4);
    const formantRatio = 1 + harmonics * 8;
    const ff = clamp(fc * formantRatio, 0.00001, 0.499);
    const shape = timbre;
    const bleed = morph * 0.1;

    for (let i = 0; i < size; i++) {
      this.carrierPhase += fc;
      let reset = false;
      if (this.carrierPhase >= 1) { this.carrierPhase -= 1; this.formantPhase = 0; reset = true; }
      this.formantPhase += ff;
      if (this.formantPhase >= 1) this.formantPhase -= 1;

      const s = this.grainlet(this.carrierPhase, this.formantPhase, shape, bleed);
      let blep = 0;
      if (reset) blep = polyblep(this.carrierPhase, fc) * 0.5;
      out[i] += (s + blep) * 0.65;
    }
  }
}

class AdditiveEngine {
  constructor(sr) {
    this.sr = sr;
    this.phases = new Float32Array(24);
    for (let i = 0; i < 24; i++) this.phases[i] = Math.random();
  }
  reset() { for (let i = 0; i < 24; i++) this.phases[i] = 0; }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr, numH = 24;
    const centroid = 1 + harmonics * (numH - 1);
    const width = 0.5 + timbre * numH * 0.5;
    const peak = morph;

    const gains = new Float32Array(numH);
    let totalGain = 0;
    for (let h = 0; h < numH; h++) {
      const n = h + 1;
      const dist = Math.abs(n - centroid);
      const g = Math.exp(-dist * dist / (width * width + 0.1));
      gains[h] = Math.pow(g, 1 + peak * 4);
      totalGain += gains[h];
    }
    if (totalGain < 0.001) totalGain = 1;

    for (let i = 0; i < size; i++) {
      let s = 0;
      for (let h = 0; h < numH; h++) {
        if (gains[h] < 0.001) continue;
        const n = h + 1;
        const f = clamp(freq * n / sr, 0.00001, 0.499);
        this.phases[h] += f;
        if (this.phases[h] >= 1) this.phases[h] -= 1;
        s += Math.sin(2 * Math.PI * this.phases[h]) * gains[h] / totalGain;
      }
      out[i] += s * 0.7;
    }
  }
}

class WavetableEngine {
  constructor(sr) {
    this.sr = sr;
    this.phase = 0;
    this.WT_SIZE = 256;
    this.WT_COUNT = 8;
    this.tables = [];
    for (let t = 0; t < this.WT_COUNT; t++) {
      const tbl = new Float32Array(this.WT_SIZE);
      for (let s = 0; s < this.WT_SIZE; s++) {
        const ph = s / this.WT_SIZE;
        switch(t) {
          case 0: tbl[s] = Math.sin(2*Math.PI*ph); break;
          case 1: tbl[s] = ph < 0.5 ? ph*4-1 : 3-ph*4; break;
          case 2: tbl[s] = ph < 0.5 ? 1 : -1; break;
          case 3: tbl[s] = ph * 2 - 1; break;
          case 4: tbl[s] = 1 - ph * 2; break;
          case 5: tbl[s] = Math.sin(2*Math.PI*ph) + Math.sin(4*Math.PI*ph)*0.5 + Math.sin(6*Math.PI*ph)*0.25; break;
          case 6: tbl[s] = Math.sin(2*Math.PI*ph)*Math.sin(4*Math.PI*ph); break;
          case 7: tbl[s] = Math.sin(2*Math.PI*ph + Math.sin(4*Math.PI*ph)*1.5); break;
        }
      }
      let mx = 0;
      for (let s=0;s<this.WT_SIZE;s++) mx = Math.max(mx,Math.abs(tbl[s]));
      if (mx>0.001) for (let s=0;s<this.WT_SIZE;s++) tbl[s]/=mx;
      this.tables.push(tbl);
    }
  }
  reset() { this.phase = Math.random(); }
  readWT(tblIdx, phase) {
    const tbl = this.tables[Math.floor(tblIdx) % this.WT_COUNT];
    const pos = phase * this.WT_SIZE;
    const i0 = Math.floor(pos) % this.WT_SIZE;
    const i1 = (i0 + 1) % this.WT_SIZE;
    return lerp(tbl[i0], tbl[i1], pos - Math.floor(pos));
  }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const f = clamp(freq / sr, 0.00001, 0.499);
    const wtPos = timbre * (this.WT_COUNT - 1);
    const wt0 = Math.floor(wtPos);
    const wt1 = Math.min(wt0 + 1, this.WT_COUNT - 1);
    const wtFrac = wtPos - wt0;
    const distort = morph;
    const hFreq = f * (1 + Math.floor(harmonics * 3));

    for (let i = 0; i < size; i++) {
      this.phase += clamp(hFreq, 0.00001, 0.499);
      if (this.phase >= 1) this.phase -= 1;

      let ph = this.phase;
      if (distort > 0.01) {
        ph = ph < 0.5
          ? ph * (0.5 + distort * 0.5) * 2
          : 0.5 + (ph - 0.5) * (0.5 + (1 - distort) * 0.5) * 2;
        ph = clamp(ph, 0, 0.9999);
      }

      const s0 = this.readWT(wt0, ph);
      const s1 = this.readWT(wt1, ph);
      out[i] += lerp(s0, s1, wtFrac) * 0.7;
    }
  }
}

class SwarmEngine {
  constructor(sr) {
    this.sr = sr;
    this.N = 8;
    this.phases = new Float32Array(this.N);
    this.detunes = new Float32Array(this.N);
    for (let i = 0; i < this.N; i++) {
      this.phases[i] = Math.random();
      this.detunes[i] = (i / (this.N - 1) - 0.5);
    }
  }
  reset() { for (let i = 0; i < this.N; i++) this.phases[i] = Math.random(); }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const spread = harmonics * 0.5;
    const pw = clamp(0.05 + timbre * 0.9, 0.05, 0.95);
    const sqMix = morph;

    for (let i = 0; i < size; i++) {
      let s = 0;
      for (let v = 0; v < this.N; v++) {
        const detuneST = this.detunes[v] * spread * 2;
        const f = clamp(freq * Math.pow(2, detuneST / 12) / sr, 0.00001, 0.499);
        this.phases[v] += f;
        if (this.phases[v] >= 1) this.phases[v] -= 1;

        let saw = this.phases[v] * 2 - 1;
        saw -= polyblep(this.phases[v], f);

        let sq = this.phases[v] < pw ? 1 : -1;
        sq += polyblep(this.phases[v], f);
        sq -= polyblep((this.phases[v] + 1 - pw) % 1, f);

        s += lerp(saw, sq, sqMix);
      }
      out[i] += s / this.N * 0.7;
    }
  }
}

class ChordEngine {
  constructor(sr) {
    this.sr = sr;
    this.N = 4;
    this.phases = new Float32Array(this.N);
    this.chords = [
      [0, 7, 12, 19],
      [0, 4, 7, 12],
      [0, 3, 7, 12],
      [0, 4, 7, 11],
      [0, 3, 7, 10],
      [0, 4, 8, 12],
      [0, 3, 6, 12],
      [0, 5, 7, 12],
      [0, 2, 7, 12],
      [0, 4, 7, 14],
    ];
  }
  reset() { for (let i = 0; i < this.N; i++) this.phases[i] = Math.random(); }
  render(freq, harmonics, timbre, morph, out, size) {
    const sr = this.sr;
    const chordIdx = Math.floor(harmonics * (this.chords.length - 1));
    const chord = this.chords[clamp(chordIdx, 0, this.chords.length-1)];
    const pw = clamp(0.05 + timbre * 0.9, 0.05, 0.95);
    const detune = morph * 0.005;

    for (let i = 0; i < size; i++) {
      let s = 0;
      for (let v = 0; v < this.N; v++) {
        const st = chord[v];
        const f = clamp(freq * Math.pow(2, (st + (v * detune * 12)) / 12) / sr, 0.00001, 0.499);
        this.phases[v] += f;
        if (this.phases[v] >= 1) this.phases[v] -= 1;

        let sq = this.phases[v] < pw ? 1 : -1;
        sq += polyblep(this.phases[v], f);
        sq -= polyblep((this.phases[v] + 1 - pw) % 1, f);
        s += sq;
      }
      out[i] += s / this.N * 0.65;
    }
  }
}

// ────────────────────────────────────────────────────────
// PlaitsVoice (unchanged)
// ────────────────────────────────────────────────────────
class PlaitsVoice {
  constructor(sr, midi, engineIdx) {
    this.sr = sr;
    this.midi = midi;
    this.freq = noteToFreq(midi);
    this.alive = true;
    this.releasing = false;

    this.env = 0;
    this.envPhase = 'attack';
    this.filterState = 0;

    const engines = [
      VirtualAnalogEngine, WaveshapingEngine, FMEngine,
      GrainletEngine, AdditiveEngine, WavetableEngine,
      SwarmEngine, ChordEngine
    ];
    const E = engines[clamp(engineIdx, 0, engines.length-1)];
    this.engine = new E(sr);
    this.engine.reset();
  }

  noteOff() { this.releasing = true; this.envPhase = 'release'; }

  processADSR(attack, decay, sustain, release) {
    const sr = this.sr;
    switch (this.envPhase) {
      case 'attack':
        this.env += 1 / (attack * sr + 1);
        if (this.env >= 1) { this.env = 1; this.envPhase = 'decay'; }
        break;
      case 'decay':
        this.env += (sustain - this.env) / (decay * sr * 0.3 + 1);
        if (Math.abs(this.env - sustain) < 0.001) { this.env = sustain; this.envPhase = 'sustain'; }
        break;
      case 'sustain':
        this.env = sustain;
        break;
      case 'release':
        this.env *= 1 - 1 / (release * sr * 0.3 + 1);
        if (this.env < 0.0001) { this.env = 0; this.alive = false; }
        break;
    }
    return this.env;
  }

  render(params, output, size) {
    const tmpBuf = new Float32Array(size);
    const freq = this.freq * params.octaveMult * Math.pow(2, params.pitchSemi / 12);

    this.engine.render(freq, params.harmonics, params.timbre, params.morph, tmpBuf, size);

    for (let i = 0; i < size; i++) {
      const env = this.processADSR(params.attack, params.decay, params.sustain, params.release);

      const cutoffNorm = clamp(params.cutoff / (this.sr * 0.5), 0.001, 0.999);
      const cutEg = cutoffNorm * (1 + params.filterEgDepth * env * 4);
      const coeff = clamp(1 - Math.exp(-2 * Math.PI * clamp(cutEg, 0.001, 0.499)), 0, 1);
      this.filterState += coeff * (tmpBuf[i] - this.filterState);

      output[i] += this.filterState * env * params.vcaDepth;
    }
  }
}

// ────────────────────────────────────────────────────────
// Globals / Params
// ────────────────────────────────────────────────────────
const voicePool = new Map(); // midi -> PlaitsVoice[]
const DSP_PARAMS = {
  engineIdx: 0,
  harmonics: 0.5, timbre: 0.5, morph: 0.5,
  attack: 0.01, decay: 0.3, sustain: 0.7, release: 0.5,
  cutoff: 8000, resonance: 1, filterEgDepth: 0,
  vcaDepth: 0.8, octaveMult: 1, pitchSemi: 0,
};

let audioCtx = null;
let scriptNode = null;
let masterGain = null;
let fxOutputGain = null;
let junoFilter = null;

// UI params
const P = {
  engineIdx: 0,
  harmonics: 0.5, timbre: 0.5, morph: 0.5,
  attack: 0.01, decay: 0.3, sustain: 0.7, release: 0.5,
  cutoff: 8000, resonance: 1, filterEgDepth: 0,
  vcaDepth: 0.8, octaveMult: 1, pitchSemi: 0,
  lfoSpeed: 3, volume: 0.7, gliss: true, glissTime: 0.08,
};

// FX defaults OFF
const FX = {
  tapeOn: false, echoOn: false,
  tapeDrive: 4, tapeTone: 3000, tapeWow: 0.2, tapeMix: 0.6,
  echoTime: 0.375, echoFeedback: 0.4, reverbSize: 2.5, reverbMix: 0.3, echoMix: 0.4,
};

// FX nodes
let tapeInputGain, tapeWaveshaper, tapeToneFilter, tapeDryGain, tapeWetGain, tapeOutGain;
let tapeWowOsc, tapeWowGain;
let delayNode, delayFeedGain, delayWetGain, delayDryGain;
let reverbNode, reverbWetGain, reverbDryGain;

function makeSatCurve(drive) {
  const n = 512, curve = new Float32Array(n), k = drive;
  for (let i = 0; i < n; i++) {
    const x = (i * 2) / n - 1;
    curve[i] = (Math.PI + k) * x / (Math.PI + k * Math.abs(x));
  }
  return curve;
}

function buildReverbIR(duration) {
  const rate = audioCtx.sampleRate;
  const length = Math.floor(rate * duration);
  const ir = audioCtx.createBuffer(2, length, rate);
  for (let ch = 0; ch < 2; ch++) {
    const d = ir.getChannelData(ch);
    for (let i = 0; i < length; i++) {
      const env = Math.pow(1 - i / length, 2.5);
      d[i] = (Math.random() * 2 - 1) * env;
    }
  }
  return ir;
}

// Global EG “ping” for post filter
let vcfPing = 0;

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // ScriptProcessorNode: cross-browser
  scriptNode = audioCtx.createScriptProcessor(512, 0, 1);
  scriptNode.onaudioprocess = (e) => {
    const output = e.outputBuffer.getChannelData(0);
    const size = output.length;
    const buf = new Float32Array(size);

    // render voices
 for (const [midi, voices] of voicePool) {
  for (let i = voices.length - 1; i >= 0; i--) {
    const v = voices[i];
    if (!v.alive) { voices.splice(i, 1); continue; }
    v.render(DSP_PARAMS, buf, size);
  }
  if (voices.length === 0) voicePool.delete(midi);
}

    // simple post-filter EG ping (acts on juno cutoff)
    if (junoFilter) {
      vcfPing *= 0.92;
      const base = P.cutoff;
      const eg = P.filterEgDepth;
      const boosted = base * (1 + eg * vcfPing * 3.5);
      junoFilter.setCutoff(boosted);
    }

    for (let i = 0; i < size; i++) output[i] = clamp(buf[i], -1, 1);
  };

  masterGain = audioCtx.createGain();
  masterGain.gain.value = P.volume;
  scriptNode.connect(masterGain);

  // Juno filter always active (post masterGain)
  junoFilter = new JunoPostFilter(audioCtx);
  masterGain.connect(junoFilter.input);

  // Output
  fxOutputGain = audioCtx.createGain();
  fxOutputGain.connect(audioCtx.destination);

  // Tape
  tapeInputGain = audioCtx.createGain();
  tapeInputGain.gain.value = FX.tapeDrive;
  tapeWaveshaper = audioCtx.createWaveShaper();
  tapeWaveshaper.curve = makeSatCurve(FX.tapeDrive * 8);
  tapeWaveshaper.oversample = '4x';

  tapeToneFilter = audioCtx.createBiquadFilter();
  tapeToneFilter.type = 'lowpass';
  tapeToneFilter.frequency.value = FX.tapeTone;

  tapeWowOsc = audioCtx.createOscillator();
  tapeWowOsc.type = 'sine';
  tapeWowOsc.frequency.value = 0.8;

  tapeWowGain = audioCtx.createGain();
  tapeWowGain.gain.value = FX.tapeWow * 5;
  tapeWowOsc.connect(tapeWowGain);
  tapeWowGain.connect(tapeToneFilter.frequency);
  tapeWowOsc.start();

  tapeDryGain = audioCtx.createGain();
  tapeWetGain = audioCtx.createGain();
  // OFF by default
  tapeDryGain.gain.value = 1;
  tapeWetGain.gain.value = 0;

  tapeOutGain = audioCtx.createGain();
  tapeOutGain.gain.value = 0.7;

  // Delay
  delayNode = audioCtx.createDelay(2.0);
  delayNode.delayTime.value = FX.echoTime;
  delayFeedGain = audioCtx.createGain();
  delayFeedGain.gain.value = FX.echoFeedback;
  delayDryGain = audioCtx.createGain();
  delayDryGain.gain.value = 1;
  delayWetGain = audioCtx.createGain();
  // OFF by default
  delayWetGain.gain.value = 0;

  // Reverb
  reverbNode = audioCtx.createConvolver();
  reverbNode.buffer = buildReverbIR(FX.reverbSize);
  reverbDryGain = audioCtx.createGain();
  reverbWetGain = audioCtx.createGain();
  // OFF by default
  reverbDryGain.gain.value = 1;
  reverbWetGain.gain.value = 0;

  // Wire: juno -> tape -> delay -> reverb -> out
  junoFilter.out.connect(tapeDryGain);
  junoFilter.out.connect(tapeInputGain);

  tapeInputGain.connect(tapeWaveshaper);
  tapeWaveshaper.connect(tapeToneFilter);
  tapeToneFilter.connect(tapeWetGain);

  tapeDryGain.connect(tapeOutGain);
  tapeWetGain.connect(tapeOutGain);

  tapeOutGain.connect(delayNode);
  tapeOutGain.connect(delayDryGain);
  delayNode.connect(delayFeedGain);
  delayFeedGain.connect(delayNode);
  delayNode.connect(delayWetGain);

  const delayMix = audioCtx.createGain();
  delayMix.gain.value = 1;
  delayDryGain.connect(delayMix);
  delayWetGain.connect(delayMix);

  delayMix.connect(reverbNode);
  delayMix.connect(reverbDryGain);
  reverbNode.connect(reverbWetGain);

  reverbDryGain.connect(fxOutputGain);
  reverbWetGain.connect(fxOutputGain);

  sendAllParams();
}

async function ensureAudioRunning() {
  initAudio();
  if (audioCtx && audioCtx.state !== 'running') {
    try { await audioCtx.resume(); } catch(e) {}
  }
}

function sendAllParams() {
  Object.assign(DSP_PARAMS, {
    engineIdx: P.engineIdx,
    harmonics: P.harmonics, timbre: P.timbre, morph: P.morph,
    attack: P.attack, decay: P.decay, sustain: P.sustain, release: P.release,
    cutoff: P.cutoff, resonance: P.resonance, filterEgDepth: P.filterEgDepth,
    vcaDepth: P.vcaDepth, octaveMult: P.octaveMult, pitchSemi: P.pitchSemi,
  });
}

function sendParam(name, value) {
  if (name in DSP_PARAMS) DSP_PARAMS[name] = value;
}

// ────────────────────────────────────────────────────────
// Notes
// ────────────────────────────────────────────────────────
function midiToName(midi) {
  const ns = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  return ns[midi % 12] + (Math.floor(midi / 12) - 1);
}

function playNote(midi) {
  if (!audioCtx) return;

  // si une voix existe déjà sur ce midi, on la met en release (pas kill)
  const arr = voicePool.get(midi);
  if (arr && arr.length) arr.forEach(v => v.noteOff());

  const voice = new PlaitsVoice(audioCtx.sampleRate, midi, DSP_PARAMS.engineIdx);

  if (!voicePool.has(midi)) voicePool.set(midi, []);
  voicePool.get(midi).push(voice);

  document.getElementById('noteDisplay').textContent = midiToName(midi);

  // ping pour post-filter EG
  vcfPing = Math.min(1, vcfPing + 0.35);
}

function stopNote(midi, immediate = false) {
  const arr = voicePool.get(midi);
  if (!arr) return;

  if (immediate) {
    voicePool.delete(midi);
  } else {
    arr.forEach(v => v.noteOff());
  }
}

function stopAllNotes(immediate = false) {
  if (immediate) {
    voicePool.clear();
  } else {
    for (const [midi, voices] of voicePool) voices.forEach(v => v.noteOff());
  }
  document.getElementById('noteDisplay').textContent = '---';
}

// ────────────────────────────────────────────────────────
// Sequencer
// ────────────────────────────────────────────────────────
const MAX_STEPS = 32;
let NUM_ROWS = 25;
const isSmall = () => window.matchMedia && window.matchMedia('(max-width: 430px)').matches;
function setRowsForScreen(){ NUM_ROWS = isSmall() ? 15 : 25; }

let viewBase = 48;
let numSteps = 16, bpm = 120, swing = 0.5;
let seqRunning = false, currentStep = 0, stepTimer = null, bpmInterval = null;

let patterns = [new Map(), new Map(), new Map(), new Map()];
let currentPatIdx = 0;
function getGrid() { return patterns[currentPatIdx]; }

function cellOn(midi, step) {
  const g = getGrid();
  return g.has(midi) && g.get(midi)[step];
}

function toggleCell(midi, step, forceVal) {
  const g = getGrid();
  if (!g.has(midi)) g.set(midi, new Array(MAX_STEPS).fill(false));
  g.get(midi)[step] = (forceVal !== undefined) ? forceVal : !g.get(midi)[step];
  refreshCell(midi, step);
}

function getViewNotes() {
  const a=[];
  for(let i=NUM_ROWS-1;i>=0;i--) a.push(viewBase+i);
  return a;
}

function clearStepHighlights() {
  document.querySelectorAll('.seq-cell.playing').forEach(c => c.classList.remove('playing'));
}
function highlightStep(step) {
  getViewNotes().forEach(midi => {
    const el = document.getElementById(`c-${midi}-${step}`);
    if (el) el.classList.add('playing');
  });
}

const noteOffTimers = new Map(); // midi -> timeoutId
const GATE = 0.90;               // 90% de la durée du step

function tick() {
  if (!seqRunning) return;

  clearStepHighlights();
  highlightStep(currentStep);

  const now = audioCtx.currentTime;

  // durée du pas (avec swing) : on calcule d'abord s16 puis delay (ms)
  const s16 = 60000 / bpm / 4;
  const sw = (swing - 0.5) * 0.6;
  const delayMs = currentStep % 2 === 0 ? s16 * (1 + sw) : s16 * (1 - sw);
  const gateMs = Math.max(10, delayMs * GATE);

  // notes actives sur ce step
  const notesOn = [];
  getGrid().forEach((row, midi) => { if (row[currentStep]) notesOn.push(midi); });

  // si rien, on laisse juste les releases continuer
  if (!notesOn.length) {
    document.getElementById('noteDisplay').textContent = '---';
  }

  // retrigger + noteOff programmé (pour que release fonctionne)
  for (const midi of notesOn) {
    // retrigger: met l'ancienne voix en release puis crée une nouvelle
    playNote(midi);

    // refresh timer de noteOff (gate)
    if (noteOffTimers.has(midi)) clearTimeout(noteOffTimers.get(midi));
    noteOffTimers.set(midi, setTimeout(() => {
      // noteOff doux (release)
      stopNote(midi, false);
      noteOffTimers.delete(midi);
    }, gateMs));
  }

  currentStep = (currentStep + 1) % numSteps;
  stepTimer = setTimeout(tick, delayMs);
}

async function seqToggle() {
  if (seqRunning) {
    seqRunning = false;
    clearTimeout(stepTimer);
    stopAllNotes(false);
    document.getElementById('btnPlay').textContent = '▶ PLAY';
    document.getElementById('btnPlay').classList.remove('playing');
    clearStepHighlights();
  } else {
    await ensureAudioRunning();
    seqRunning = true;
    currentStep = 0;
    document.getElementById('btnPlay').textContent = '⏸ PAUSE';
    document.getElementById('btnPlay').classList.add('playing');
    tick();
  }
}

function seqStop() {
  seqRunning = false;
  clearTimeout(stepTimer);
  currentStep = 0;
  stopAllNotes(true);
  document.getElementById('btnPlay').textContent = '▶ PLAY';
  document.getElementById('btnPlay').classList.remove('playing');
  clearStepHighlights();
}

function buildGrid() {
  const gridEl = document.getElementById('seqGrid');
  const headersEl = document.getElementById('stepHeaders');
  gridEl.innerHTML = '';
  headersEl.innerHTML = '';

  for (let s = 0; s < numSteps; s++) {
    const el = document.createElement('div');
    el.className = 'seq-step-num' + (s%4===0?' beat':'') + (s%4===0&&s>0?' beat-gap':'');
    el.textContent = s%4===0 ? String(s/4+1) : '·';
    headersEl.appendChild(el);
  }

  const onPointerDown = (cell, midi, s) => {
    cell._dragVal = !cellOn(midi,s);
    toggleCell(midi,s,cell._dragVal);
  };

  getViewNotes().forEach(midi => {
    const name = midiToName(midi), isSharp = name.includes('#'), isC = name.startsWith('C') && !isSharp;

    const row = document.createElement('div'); row.className = 'seq-row';
    const lbl = document.createElement('div');
    lbl.className = 'seq-row-label' + (isC?' is-c':'') + (isSharp?' is-sharp':'');
    lbl.textContent = isSharp ? '♯' : name;
    row.appendChild(lbl);

    const cells = document.createElement('div'); cells.className = 'seq-cells';

    let dragVal = null;

    for (let s = 0; s < numSteps; s++) {
      const cell = document.createElement('div');
      cell.className = 'seq-cell' + (s%4===0&&s>0?' beat-gap':'');
      cell.id = `c-${midi}-${s}`;
      if (cellOn(midi,s)) cell.classList.add('active');

      // mouse
      cell.addEventListener('mousedown', e => { e.preventDefault(); dragVal = !cellOn(midi,s); toggleCell(midi,s,dragVal); });
      cell.addEventListener('mouseenter', e => { if(e.buttons===1 && dragVal!==null) toggleCell(midi,s,dragVal); });

      // touch (better for iPhone)
      cell.addEventListener('touchstart', e => {
        e.preventDefault();
        dragVal = !cellOn(midi,s);
        toggleCell(midi,s,dragVal);
      }, {passive:false});
      cell.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        const el = document.elementFromPoint(t.clientX, t.clientY);
        if (el && el.classList && el.classList.contains('seq-cell')) {
          const parts = el.id.split('-'); // c-midi-step
          if (parts.length === 3) {
            const mm = +parts[1], ss = +parts[2];
            toggleCell(mm, ss, dragVal);
          }
        }
      }, {passive:false});
      cell.addEventListener('touchend', () => { dragVal = null; }, {passive:true});

      cells.appendChild(cell);
    }

    window.addEventListener('mouseup', () => { dragVal = null; }, { passive: true });
    row.appendChild(cells);
    gridEl.appendChild(row);
  });

  document.getElementById('octLabel').textContent = midiToName(viewBase);
}

function refreshCell(midi, step) {
  const el = document.getElementById(`c-${midi}-${step}`);
  if (el) el.classList.toggle('active', cellOn(midi,step));
}

function scrollOctave(dir) {
  viewBase = Math.max(12, Math.min(72, viewBase + dir*12));
  buildGrid();
}

function setNumSteps(n) {
  numSteps = n;
  if (currentStep >= n) currentStep = 0;
  buildGrid();
}

function clearGrid() { getGrid().clear(); buildGrid(); }

function randomize() {
  getGrid().clear();
  const penta = [0,2,4,7,9];
  const notes = penta.map(i=>viewBase+i).concat(penta.map(i=>viewBase+12+i));
  for (let s=0;s<numSteps;s++) {
    if (Math.random()<0.38) {
      const midi = notes[Math.floor(Math.random()*notes.length)];
      const g = getGrid();
      if(!g.has(midi)) g.set(midi,new Array(MAX_STEPS).fill(false));
      g.get(midi)[s] = true;
    }
  }
  buildGrid();
}

const savedPats = [null,null,null,null];
function loadPattern(idx,el) {
  savedPats[currentPatIdx] = new Map([...patterns[currentPatIdx]].map(([k,v])=>[k,[...v]]));
  currentPatIdx = idx;
  if(savedPats[idx]) patterns[idx] = new Map([...savedPats[idx]].map(([k,v])=>[k,[...v]]));
  document.querySelectorAll('.pat-btn').forEach((b,i) => b.classList.toggle('active', i===idx));
  buildGrid();
}

function startBpmChange(d) { changeBpm(d); bpmInterval = setInterval(()=>changeBpm(d),100); }
function stopBpmChange() { clearInterval(bpmInterval); }
function changeBpm(d) {
  bpm = Math.max(20,Math.min(300,bpm+d));
  document.getElementById('bpmDisplay').textContent = bpm;
}
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('bpmDisplay').addEventListener('wheel', e => {
    e.preventDefault();
    changeBpm(e.deltaY<0?1:-1);
  }, {passive:false});
});

// ────────────────────────────────────────────────────────
// Sliders + knob
// ────────────────────────────────────────────────────────
function applyParam(param, val) {
  P[param] = val;

  // Map to DSP params
  if (param === 'engineIdx') DSP_PARAMS.engineIdx = val;
  else sendParam(param, val);

  // Juno post-filter mapping
  if (junoFilter) {
    if (param === 'cutoff') junoFilter.setCutoff(val);
    if (param === 'resonance') {
      const res01 = clamp((val - 0.01) / (20 - 0.01), 0, 1);
      junoFilter.setResonance(res01);
    }
  }

  // Volume
  if (param === 'volume' && masterGain) masterGain.gain.value = val;
}

function initSliders() {
  document.querySelectorAll('.vslider-track').forEach(track => {
    const handle = track.querySelector('.vslider-handle');
    const param = track.dataset.param;
    const min = parseFloat(track.dataset.min);
    const max = parseFloat(track.dataset.max);
    const initVal = parseFloat(track.dataset.val);
    const H = 73;

    let pos = ((initVal-min)/(max-min))*H;
    handle.style.bottom = pos + 'px';
    P[param] = initVal;
    applyParam(param, initVal);

    let dragging = false, startY = 0, startPos = pos;

    const moveTo = (clientY) => {
      pos = Math.max(0,Math.min(H, startPos+(startY-clientY)));
      handle.style.bottom = pos+'px';
      const val = min+(pos/H)*(max-min);
      applyParam(param, val);
    };

    handle.addEventListener('mousedown', e => { dragging=true; startY=e.clientY; startPos=pos; e.preventDefault(); });
    window.addEventListener('mousemove', e => { if (!dragging) return; moveTo(e.clientY); });
    window.addEventListener('mouseup', () => { dragging=false; });

    handle.addEventListener('touchstart', e => { dragging=true; startY=e.touches[0].clientY; startPos=pos; e.preventDefault(); },{passive:false});
    window.addEventListener('touchmove', e => { if (!dragging) return; moveTo(e.touches[0].clientY); },{passive:false});
    window.addEventListener('touchend', ()=>{ dragging=false; });
  });
}

function initVolumeKnob() {
  const knob = document.getElementById('knob-vol');
  let val = parseFloat(knob.dataset.val || '0.7');
  let startY = null;
  const setRot = v => { knob.style.transform = `rotate(${-140+v*280}deg)`; };
  setRot(val);
  P.volume = val;

  knob.addEventListener('mousedown', e => { startY=e.clientY; e.preventDefault(); });
  window.addEventListener('mousemove', e => {
    if (!e.buttons || startY===null) return;
    val = Math.max(0,Math.min(1,val+(startY-e.clientY)*0.006));
    startY=e.clientY; setRot(val);
    applyParam('volume', val);
  });
  window.addEventListener('mouseup', ()=>{ startY=null; });

  knob.addEventListener('touchstart', e => { startY=e.touches[0].clientY; e.preventDefault(); }, {passive:false});
  window.addEventListener('touchmove', e => {
    if (startY===null) return;
    const y = e.touches[0].clientY;
    val = Math.max(0,Math.min(1,val+(startY-y)*0.006));
    startY=y; setRot(val);
    applyParam('volume', val);
  }, {passive:false});
  window.addEventListener('touchend', ()=>{ startY=null; }, {passive:true});
}

// ────────────────────────────────────────────────────────
// Engine selection / UI labels
// ────────────────────────────────────────────────────────
const ENGINE_LABELS = {
  0: { harm:'DETUNE', timb:'PULSE W', morph:'MIX' },
  1: { harm:'SHAPE', timb:'FOLD AMT', morph:'ASYM' },
  2: { harm:'RATIO', timb:'MOD IDX', morph:'FDBK' },
  3: { harm:'FORM RAT', timb:'SHAPE', morph:'BLEED' },
  4: { harm:'CENTROID', timb:'WIDTH', morph:'PEAK' },
  5: { harm:'WT BANK', timb:'WT POS', morph:'DISTORT' },
  6: { harm:'SPREAD', timb:'PULSE W', morph:'SAW↔SQ' },
  7: { harm:'CHORD', timb:'PULSE W', morph:'DETUNE' },
};

function setEngine(idx, el) {
  P.engineIdx = idx;
  DSP_PARAMS.engineIdx = idx;
  document.querySelectorAll('.eng-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  document.getElementById('engDesc').textContent = el.dataset.desc || '';

  const lbl = ENGINE_LABELS[idx];
  if (lbl) {
    document.getElementById('lbl-harm').textContent = lbl.harm;
    document.getElementById('lbl-timb').textContent = lbl.timb;
    document.getElementById('lbl-morph').textContent = lbl.morph;
  }
  stopAllNotes(true);
}

function setFeet(feet, el) {
  P.octaveMult = {4:2, 8:1, 16:0.5, 32:0.25}[feet];
  document.querySelectorAll('[onclick*="setFeet"]').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  applyParam('octaveMult', P.octaveMult);
}

let glissOn = true;
function toggleGliss() {
  glissOn = !glissOn;
  P.gliss = glissOn;
  document.getElementById('led-gliss').classList.toggle('on', glissOn);
}
function setSwitch(sw) {
  document.getElementById('sw-vco').classList.toggle('active',sw==='vco');
  document.getElementById('sw-vcf').classList.toggle('active',sw==='vcf');
}

// ────────────────────────────────────────────────────────
// FX panel toggle + FX controls
// ────────────────────────────────────────────────────────
function toggleFxPanel() {
  const panel = document.getElementById('fxPanel');
  const btn = document.getElementById('btnFxPanel');
  const show = !panel.classList.contains('show');
  panel.classList.toggle('show', show);
  btn.textContent = show ? 'FX ▴' : 'FX ▾';
}

function togglePitchMod() {
  const sec = document.getElementById('pitchModSection');
  const btn = document.getElementById('btnPitchMod');
  const hidden = sec.classList.toggle('hidden');
  btn.textContent = hidden ? 'PITCH/MOD ▸' : 'PITCH/MOD ▾';
}

function toggleFx(type) {
  if (type==='tape') {
    FX.tapeOn = !FX.tapeOn;
    const btn = document.getElementById('tapeBypass');
    btn.textContent = FX.tapeOn ? 'ON' : 'OFF';
    btn.classList.toggle('active', FX.tapeOn);
    if (tapeDryGain) {
      tapeDryGain.gain.value = FX.tapeOn ? (1 - FX.tapeMix) : 1;
      tapeWetGain.gain.value = FX.tapeOn ? FX.tapeMix : 0;
    }
  } else {
    FX.echoOn = !FX.echoOn;
    const btn = document.getElementById('echoBypass');
    btn.textContent = FX.echoOn ? 'ON' : 'OFF';
    btn.classList.toggle('active', FX.echoOn);
    if (delayWetGain) {
      delayWetGain.gain.value = FX.echoOn ? FX.echoMix : 0;
      reverbWetGain.gain.value = FX.echoOn ? FX.reverbMix : 0;
      reverbDryGain.gain.value = FX.echoOn ? (1 - FX.reverbMix) : 1;
    }
  }
}

function fmtFxVal(p,v) {
  if (p==='tapeDrive') return v.toFixed(1);
  if (p==='tapeTone') return v>=1000 ? (v/1000).toFixed(1)+'k' : Math.round(v)+'Hz';
  if (['tapeWow','tapeMix','echoFeedback','echoMix','reverbMix'].includes(p)) return Math.round(v*100)+'%';
  if (p==='echoTime') return Math.round(v*1000)+'ms';
  if (p==='reverbSize') return v.toFixed(1)+'s';
  return v.toFixed(2);
}

function applyFxParam(p, v) {
  FX[p] = v;
  if (!audioCtx) return;
  switch(p) {
    case 'tapeDrive':
      tapeInputGain.gain.value=v;
      tapeWaveshaper.curve=makeSatCurve(v*8);
      break;
    case 'tapeTone':
      tapeToneFilter.frequency.value=v;
      break;
    case 'tapeWow':
      tapeWowGain.gain.value=v*5;
      break;
    case 'tapeMix':
      if (FX.tapeOn) { tapeDryGain.gain.value=1-v; tapeWetGain.gain.value=v; }
      break;
    case 'echoTime':
      delayNode.delayTime.setTargetAtTime(v,audioCtx.currentTime,0.05);
      break;
    case 'echoFeedback':
      delayFeedGain.gain.value=v;
      break;
    case 'echoMix':
      if (FX.echoOn) delayWetGain.gain.value=v;
      break;
    case 'reverbSize':
      reverbNode.buffer=buildReverbIR(v);
      break;
    case 'reverbMix':
      if (FX.echoOn) {
        reverbWetGain.gain.value=v;
        reverbDryGain.gain.value=1-v;
      }
      break;
  }
}

function initFxKnobs() {
  document.querySelectorAll('.fx-knob').forEach(knob => {
    const p = knob.dataset.param;
    const min = parseFloat(knob.dataset.min);
    const max = parseFloat(knob.dataset.max);
    let val = parseFloat(knob.dataset.val);
    const dot = knob.querySelector('.fx-knob-dot');
    const valEl = document.getElementById('val-'+p);
    let startY = null;

    const set = v => {
      val = Math.max(min,Math.min(max,v));
      const pct = (val-min)/(max-min);
      dot.style.transform = `translateX(-50%) rotate(${-140+pct*280}deg)`;
      if(valEl) valEl.textContent = fmtFxVal(p,val);
      applyFxParam(p,val);
    };
    set(val);

    knob.addEventListener('mousedown', e => { startY=e.clientY; e.preventDefault(); });
    window.addEventListener('mousemove', e => {
      if (!e.buttons || startY===null) return;
      set(val+(startY-e.clientY)*(max-min)/160);
      startY=e.clientY;
    });
    window.addEventListener('mouseup', ()=>{ startY=null; });

    knob.addEventListener('touchstart', e => { startY=e.touches[0].clientY; e.preventDefault(); }, {passive:false});
    window.addEventListener('touchmove', e => {
      if (startY===null) return;
      const y = e.touches[0].clientY;
      set(val+(startY-y)*(max-min)/160);
      startY=y;
    }, {passive:false});
    window.addEventListener('touchend', ()=>{ startY=null; }, {passive:true});

    knob.addEventListener('wheel', e => {
      e.preventDefault();
      set(val+(e.deltaY<0?1:-1)*(max-min)/40);
    },{passive:false});
  });
}

// Tape reel animation
function initTapeReel() {
  const cv = document.getElementById('tapeReel'); if(!cv) return;
  const ctx = cv.getContext('2d'); let angle = 0;
  function draw() {
    const w=cv.width, h=cv.height, cx=w/2, cy=h/2, r=w*0.38;
    ctx.clearRect(0,0,w,h);
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.strokeStyle = seqRunning?'#a07030':'#4a3a20'; ctx.lineWidth=2; ctx.stroke();
    for (let i=0;i<6;i++) {
      const a = angle+(i/6)*Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(cx+Math.cos(a)*r*0.25, cy+Math.sin(a)*r*0.25);
      ctx.lineTo(cx+Math.cos(a)*r*0.85, cy+Math.sin(a)*r*0.85);
      ctx.strokeStyle = seqRunning?'#c08040':'#3a2a10'; ctx.lineWidth=2; ctx.stroke();
    }
    ctx.beginPath(); ctx.arc(cx,cy,r*0.22,0,Math.PI*2);
    ctx.fillStyle = seqRunning?'#8a5820':'#2a1a08'; ctx.fill();
    if(seqRunning && FX.tapeOn) angle+=0.04;
    requestAnimationFrame(draw);
  }
  draw();
}

// Echo visualizer
function initEchoViz() {
  const cv = document.getElementById('echoCanvas'); if(!cv) return;
  const ctx = cv.getContext('2d'); let phase=0;
  function draw() {
    const w=cv.width, h=cv.height;
    ctx.clearRect(0,0,w,h);
    if(FX.echoOn) {
      for (let e=0;e<4;e++) {
        const x = ((phase*20+e*w/4)%w);
        const alpha = (1-e/4)*0.7*FX.echoMix;
        const ht = h*0.5*(1-e/4)*(seqRunning?1:0.2);
        ctx.beginPath(); ctx.moveTo(x,h/2-ht); ctx.lineTo(x,h/2+ht);
        ctx.strokeStyle = `rgba(122,184,232,${alpha})`; ctx.lineWidth=2; ctx.stroke();
      }
      const g = ctx.createLinearGradient(0,0,w,0);
      g.addColorStop(0,'rgba(122,184,232,0)');
      g.addColorStop(0.5,`rgba(122,184,232,${FX.reverbMix*0.15})`);
      g.addColorStop(1,'rgba(122,184,232,0)');
      ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
    }
    if(seqRunning && FX.echoOn) phase+=0.015;
    requestAnimationFrame(draw);
  }
  draw();
}

// ────────────────────────────────────────────────────────
// Ribbon (Pitch/Mod) - simple UI only (no actual modulation wired here)
// ────────────────────────────────────────────────────────
function initRibbons() {
  const pitch = document.getElementById('pitchRibbon');
  const mod = document.getElementById('modRibbon');
  const pitchVal = document.getElementById('pitchVal');
  const modVal = document.getElementById('modVal');

  const attach = (el, outEl) => {
    let dragging = false;
    const setFromY = (clientY) => {
      const r = el.getBoundingClientRect();
      const t = clamp(1 - (clientY - r.top) / r.height, 0, 1);
      const v = Math.round((t*2 - 1) * 100) / 100;
      outEl.textContent = v.toFixed(2);
    };
    el.addEventListener('mousedown', e => { dragging=true; setFromY(e.clientY); e.preventDefault(); });
    window.addEventListener('mousemove', e => { if(!dragging) return; setFromY(e.clientY); });
    window.addEventListener('mouseup', ()=>{ dragging=false; });

    el.addEventListener('touchstart', e => { dragging=true; setFromY(e.touches[0].clientY); e.preventDefault(); }, {passive:false});
    window.addEventListener('touchmove', e => { if(!dragging) return; setFromY(e.touches[0].clientY); }, {passive:false});
    window.addEventListener('touchend', ()=>{ dragging=false; }, {passive:true});
  };

  attach(pitch, pitchVal);
  attach(mod, modVal);
}

// ────────────────────────────────────────────────────────
// Start overlay wiring (iOS)
// ────────────────────────────────────────────────────────
function hideStartOverlay() {
  const o = document.getElementById('startOverlay');
  if (o) o.style.display = 'none';
}
document.getElementById('startAudioBtn').addEventListener('click', async () => {
  await ensureAudioRunning();
  hideStartOverlay();
}, {passive:true});

// ────────────────────────────────────────────────────────
// INIT
// ────────────────────────────────────────────────────────
window.addEventListener('DOMContentLoaded', () => {
  setRowsForScreen();
  buildGrid();
  initSliders();
  initVolumeKnob();
  initFxKnobs();
  initTapeReel();
  initEchoViz();
  initRibbons();

  // default engine label
  const lbl = ENGINE_LABELS[0];
  document.getElementById('lbl-harm').textContent = lbl.harm;
  document.getElementById('lbl-timb').textContent = lbl.timb;
  document.getElementById('lbl-morph').textContent = lbl.morph;

  // FX buttons reflect defaults OFF
  document.getElementById('tapeBypass').classList.toggle('active', FX.tapeOn);
  document.getElementById('echoBypass').classList.toggle('active', FX.echoOn);

  // Adapt rows on resize (iphone rotate)
  window.addEventListener('resize', () => {
    const before = NUM_ROWS;
    setRowsForScreen();
    if (before !== NUM_ROWS) buildGrid();
  }, {passive:true});
});
</script>

</body>
</html>
