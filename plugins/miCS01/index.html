<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />
<title>Bantu Ins. miCS01 — Elektron Minimal</title>

<style>
/* ─────────────────────────────────────────────
   BASE (structure)
───────────────────────────────────────────── */
*{box-sizing:border-box;margin:0;padding:0;}
:root{
  --vh: 1vh;

  /* Elektron minimal palette */
  --bg:#0b0c0d;
  --panel:#111315;
  --panel2:#0f1112;
  --line:#24282b;
  --line2:#1b1f22;
  --text:#c8ced3;
  --muted:#7b848c;
  --accent:#5dd4e8;
  --accent2:#9be9f6;
  --danger:#ff4d4d;
  --radius:8px;
}

html,body{height:100%;}
body{
  background:var(--bg);
  display:flex;
  justify-content:center;
  align-items:flex-start;
  min-height:100dvh;
  padding: max(18px, env(safe-area-inset-top)) 12px max(18px, env(safe-area-inset-bottom));
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--text);
  overflow-x:hidden;
  overscroll-behavior-y:none;
}

.synth-wrapper{
  width:100%;
  max-width:1100px;
  display:flex;
  flex-direction:column;
  gap:12px;
}

.block{
  background:var(--panel);
  border-radius:var(--radius);
  padding:12px;
  border:1px solid var(--line);
  box-shadow:none;
}

.block-title{
  text-align:center;
  color:var(--accent);
  font-size:12px;
  font-weight:900;
  letter-spacing:1.6px;
  margin-bottom:8px;
  text-transform:uppercase;
}

.hidden{ display:none !important; }

/* ─────────────────────────────────────────────
   START OVERLAY
───────────────────────────────────────────── */
.start-overlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,0.78);
  display:flex;
  justify-content:center;
  align-items:center;
  z-index:9999;
  padding:20px;
}
.start-card{
  width:min(520px, 92vw);
  background:var(--panel);
  border:1px solid var(--line);
  border-radius:12px;
  padding:18px;
  box-shadow:none;
}
.start-title{
  color:var(--accent);
  font-weight:900;
  letter-spacing:2px;
  text-transform:uppercase;
  font-size:13px;
  text-align:center;
  margin-bottom:10px;
}
.start-text{
  color:#cfcfcf;
  font-size:13px;
  line-height:1.35;
  text-align:center;
  margin-bottom:14px;
}
.start-btn{
  width:100%;
  padding:12px 14px;
  border-radius:10px;
  border:1px solid var(--line);
  background:rgba(93,212,232,0.92);
  color:#000;
  font-weight:900;
  letter-spacing:1px;
  cursor:pointer;
}
.start-small{
  color:#999;
  font-size:11px;
  text-align:center;
  margin-top:10px;
}

/* ─────────────────────────────────────────────
   QUICK BAR (sticky filter)
───────────────────────────────────────────── */
.quick-bar{
  position:sticky;
  top:0;
  z-index:1200;
  display:flex;
  gap:10px;
  padding:6px 10px;
  background:#0a0b0c;
  border-bottom:1px solid var(--line);
  border-radius:10px;
  margin-bottom:10px;
}
.quick-item{ flex:1; display:flex; flex-direction:column; gap:3px; }
.quick-item span{
  font-size:10px;
  color:var(--accent);
  font-weight:900;
  letter-spacing:1px;
  text-transform:uppercase;
}
.quick-item input[type="range"]{ width:100%; }

/* ─────────────────────────────────────────────
   CONTROLS: buttons & sliders (minimal)
───────────────────────────────────────────── */
.eng-btn, .wave-btn, .seq-btn, .icon-btn, .fx-bypass-btn{
  border-radius:7px;
  border:1px solid var(--line);
  background:rgba(255,255,255,0.03);
  color:var(--text);
  cursor:pointer;
  user-select:none;
}

.eng-btn:hover, .wave-btn:hover, .seq-btn:hover, .icon-btn:hover, .fx-bypass-btn:hover{
  border-color:rgba(93,212,232,0.35);
}

.eng-btn{
  padding:7px 4px;
  font-size:10px;
  font-weight:800;
  text-align:center;
  text-transform:uppercase;
}
.eng-btn.active{
  background:rgba(93,212,232,0.16);
  border-color:rgba(93,212,232,0.65);
  color:var(--accent2);
}

.wave-btn{
  font-size:10px;
  padding:5px 7px;
  font-weight:800;
}
.wave-btn.active{
  background:rgba(93,212,232,0.92);
  color:#000;
}

/* sliders */
.vslider-track{
  width:20px;
  height:84px;
  background:#0c0e0f;
  border-radius:6px;
  border:1px solid var(--line2);
  position:relative;
  cursor:pointer;
  box-shadow:none;
}
.vslider-handle{
  position:absolute;
  left:-6px; right:-6px;
  height:16px;
  background:#c9d0d6;
  border-radius:4px;
  border:1px solid #6b737a;
  box-shadow:none;
}
.vslider-handle::after{
  content:'';
  position:absolute;
  left:3px; right:3px; top:50%;
  transform:translateY(-50%);
  height:3px;
  background:var(--accent);
  border-radius:2px;
}
.slider-col{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:3px;
}
.slider-col label{
  font-size:10px;
  letter-spacing:0.6px;
  color:var(--muted);
  text-transform:uppercase;
  font-weight:800;
}

.note-display{
  background:#070809;
  border:1px solid rgba(93,212,232,0.55);
  border-radius:8px;
  padding:6px 10px;
  font-size:14px;
  color:var(--accent2);
  text-align:center;
  font-weight:900;
}

/* ─────────────────────────────────────────────
   OSC layout
───────────────────────────────────────────── */
.osc-top{
  display:flex;
  gap:14px;
  align-items:flex-start;
}
.engine-grid{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:6px;
}
.osc-params{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:10px;
  justify-items:center;
  align-items:start;
}
#engDesc{
  color:#6c747b;
  font-size:11px;
  text-align:center;
  margin-top:6px;
  font-style:italic;
}

/* ─────────────────────────────────────────────
   SOUND layout (compact)
───────────────────────────────────────────── */
.sound-grid{
  display:grid;
  grid-template-columns:1fr;
  gap:10px;
}
.sound-section-title{
  text-align:center;
  color:var(--accent);
  font-size:11px;
  letter-spacing:1px;
  font-weight:900;
  margin-bottom:8px;
  text-transform:uppercase;
  cursor:pointer;
}
.compact-row{
  display:flex;
  gap:10px;
  justify-content:space-around;
  align-items:flex-start;
}
.env-grid{
  display:grid;
  grid-template-columns:repeat(2,1fr);
  gap:8px 10px;
  justify-items:center;
}
.vca-stack{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:6px;
}

/* volume knob */
.knob{
  width:54px;height:54px;
  border-radius:50%;
  background:#0c0e0f;
  border:1px solid var(--line);
  position:relative;
  cursor:pointer;
  user-select:none;
}
.knob .dot{
  position:absolute;
  width:6px;height:6px;
  background:var(--danger);
  border-radius:50%;
  top:5px; left:50%;
  transform:translateX(-50%);
}

/* ─────────────────────────────────────────────
   PITCH/MOD (hidden by default)
───────────────────────────────────────────── */
.pm-wrap{
  display:flex;
  gap:10px;
  justify-content:space-between;
  align-items:flex-start;
  margin-top:10px;
}
.pm-col{ flex:1; }
.pm-title{
  text-align:center;
  color:#aab3ba;
  font-size:11px;
  letter-spacing:1.4px;
  font-weight:900;
  margin-bottom:8px;
  text-transform:uppercase;
}
.ribbon{
  height:96px;
  border-radius:10px;
  border:1px solid var(--line);
  background:linear-gradient(180deg, rgba(93,212,232,0.12), rgba(255,255,255,0.02));
  position:relative;
  touch-action:none;
}
.ribbon::after{
  content:'';
  position:absolute;
  left:6px; right:6px;
  top:50%;
  height:2px;
  background:rgba(255,255,255,0.10);
}
.pm-val{
  margin-top:6px;
  text-align:center;
  font-size:12px;
  color:var(--accent2);
  font-weight:900;
}

/* ─────────────────────────────────────────────
   SEQUENCER
───────────────────────────────────────────── */
.seq-panel{
  background:var(--panel);
  border-radius:var(--radius);
  border:1px solid var(--line);
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:12px;
}
.seq-controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center;
}
.seq-btn{
  padding:7px 12px;
  text-transform:uppercase;
  font-weight:900;
  font-size:11px;
}
.seq-btn.playing{
  color:var(--accent2);
  border-color:rgba(93,212,232,0.75);
  background:rgba(93,212,232,0.10);
}

.icon-btn{
  width:28px;height:28px;
  display:inline-flex;
  justify-content:center;
  align-items:center;
  font-weight:900;
  font-size:12px;
}
.bpm-display{
  min-width:46px;
  text-align:center;
  padding:6px 8px;
  border-radius:7px;
  background:rgba(255,255,255,0.03);
  border:1px solid var(--line);
  color:var(--accent2);
  font-weight:900;
}
.steps-select{
  background:rgba(255,255,255,0.03);
  border:1px solid var(--line);
  color:var(--text);
  border-radius:7px;
  padding:6px 8px;
}

.seq-step-headers{ display:flex; gap:4px; }
.seq-step-num{
  flex:1;
  text-align:center;
  color:#5e666d;
  font-size:9px;
  padding:2px 0;
}
.seq-step-num.beat{ color:#7f8a93; font-weight:900; }
.seq-step-num.beat-gap{ margin-left:4px; }

.seq-grid-wrapper{
  border:1px solid var(--line);
  background:var(--panel2);
  border-radius:10px;
  overflow:auto;
  max-height:48vh;
}

.seq-row{
  display:flex;
  align-items:stretch;
  border-bottom:1px solid rgba(255,255,255,0.05);
}
.seq-row-label{
  width:38px;
  font-size:9px;
  padding:6px 6px;
  display:flex;
  align-items:center;
  justify-content:center;
  color:var(--muted);
  background:#0c0e0f;
  border-right:1px solid var(--line);
}
.seq-row-label.is-c{ color:var(--accent2); font-weight:900; }
.seq-row-label.is-sharp{ color:#7a838a; }
.seq-cells{ flex:1; display:flex; gap:4px; padding:6px; }
.seq-cell{
  flex:1;
  height:16px;
  border-radius:3px;
  background:rgba(255,255,255,0.03);
  border:1px solid rgba(255,255,255,0.06);
}
.seq-cell.beat-gap{ margin-left:4px; }
.seq-cell.active{
  background:rgba(93,212,232,0.22);
  border-color:rgba(93,212,232,0.65);
}
.seq-cell.playing{
  outline:2px solid rgba(93,212,232,0.65);
  outline-offset:1px;
}

/* ─────────────────────────────────────────────
   FX PANEL
───────────────────────────────────────────── */
.fx-panel{
  background:var(--panel);
  border-radius:var(--radius);
  padding:12px;
  border:1px solid var(--line);
  display:none;
}
.fx-panel.show{ display:block; }

.fx-bypass-btn{
  padding:6px 12px;
  border-radius:8px;
  font-weight:900;
}
.fx-bypass-btn.active{
  border-color:rgba(93,212,232,0.75);
  color:var(--accent2);
  background:rgba(93,212,232,0.10);
}

.fx-knob-group{ display:flex; flex-direction:column; align-items:center; gap:6px; }
.fx-knob-label{ font-size:10px; color:var(--muted); font-weight:900; letter-spacing:1px; text-transform:uppercase; }
.fx-knob{
  width:46px;height:46px;
  border-radius:50%;
  background:#0c0e0f;
  border:1px solid var(--line);
  position:relative;
  cursor:pointer;
  user-select:none;
}
.fx-knob-dot{
  position:absolute;
  width:6px;height:6px;
  border-radius:50%;
  background:var(--accent2);
  top:4px;
  left:50%;
  transform:translateX(-50%) rotate(-140deg);
  transform-origin:50% 190%;
}
.fx-knob-val{ font-size:10px; color:#b7c0c7; font-weight:800; min-width:48px; text-align:center; }

/* hide engine desc on small for pure Elektron */
@media (max-width: 520px){
  #engDesc{ display:none; }
  .block{ padding:10px; }
  .seq-grid-wrapper{ max-height:52vh; }
}
</style>
</head>

<body>

<!-- QUICK BAR (always visible) -->
<div class="quick-bar">
  <div class="quick-item">
    <span>Cut</span>
    <input id="quickCut" type="range" min="20" max="18000" value="8000" step="1"
      oninput="applyParam('cutoff', +this.value)">
  </div>
  <div class="quick-item">
    <span>Res</span>
    <input id="quickRes" type="range" min="0.01" max="20" value="1" step="0.01"
      oninput="applyParam('resonance', +this.value)">
  </div>
  <div class="quick-item">
    <span>EG</span>
    <input id="quickEg" type="range" min="0" max="1" value="0" step="0.01"
      oninput="applyParam('filterEgDepth', +this.value)">
  </div>
</div>

<!-- START AUDIO OVERLAY -->
<div class="start-overlay" id="startOverlay">
  <div class="start-card">
    <div class="start-title">Start Audio</div>
    <div class="start-text">
      iOS/Safari exige un geste utilisateur pour activer l’audio.<br>
      Appuie sur le bouton ci-dessous, puis PLAY.
    </div>
    <button class="start-btn" id="startAudioBtn">▶ ACTIVER L’AUDIO</button>
    <div class="start-small">Tip: si tu es en mode silencieux, active le son.</div>
  </div>
</div>

<div class="synth-wrapper">

  <!-- BLOCK 1 : OSC -->
  <div class="block">
    <div class="block-title">Oscillator</div>

    <div class="osc-top">

      <div style="flex:1;">
        <div id="engineBtns" class="engine-grid">
          <div class="eng-btn active" onclick="setEngine(0,this)" data-desc="VA dual">VA</div>
          <div class="eng-btn" onclick="setEngine(1,this)" data-desc="Fold">FOLD</div>
          <div class="eng-btn" onclick="setEngine(2,this)" data-desc="FM">FM</div>
          <div class="eng-btn" onclick="setEngine(3,this)" data-desc="Grain">GRAIN</div>
          <div class="eng-btn" onclick="setEngine(4,this)" data-desc="Additive">ADD</div>
          <div class="eng-btn" onclick="setEngine(5,this)" data-desc="Wavetable">WT</div>
          <div class="eng-btn" onclick="setEngine(6,this)" data-desc="Swarm">SWARM</div>
          <div class="eng-btn" onclick="setEngine(7,this)" data-desc="Chord">CHORD</div>
        </div>

        <div id="engDesc">VA dual</div>

        <!-- OSC PARAMETERS (under engine) -->
        <div class="osc-params" style="margin-top:10px;">

          <div class="slider-col">
            <label id="lbl-harm">HARM</label>
            <div class="vslider-track" data-param="harmonics" data-min="0" data-max="1" data-val="0.5">
              <div class="vslider-handle"></div>
            </div>
          </div>

          <div class="slider-col">
            <label id="lbl-timb">TIMB</label>
            <div class="vslider-track" data-param="timbre" data-min="0" data-max="1" data-val="0.5">
              <div class="vslider-handle"></div>
            </div>
          </div>

          <div class="slider-col">
            <label id="lbl-morph">MORP</label>
            <div class="vslider-track" data-param="morph" data-min="0" data-max="1" data-val="0.5">
              <div class="vslider-handle"></div>
            </div>
          </div>

          <div class="slider-col">
            <label>FEET</label>
            <div style="display:flex; flex-direction:column; gap:4px;">
              <div class="wave-btn" onclick="setFeet(4,this)">4'</div>
              <div class="wave-btn active" onclick="setFeet(8,this)">8'</div>
              <div class="wave-btn" onclick="setFeet(16,this)">16'</div>
              <div class="wave-btn" onclick="setFeet(32,this)">32'</div>
            </div>
          </div>

        </div>
      </div>

    </div>
  </div>

  <!-- BLOCK 2 : SOUND -->
  <div class="block">
    <div class="block-title">Sound</div>

    <!-- VCF (collapsible) -->
    <div class="sound-section-title" onclick="toggleSection('vcfSection')">VCF ▾</div>
    <div id="vcfSection">
      <div class="compact-row">
        <div class="slider-col">
          <label>CUT</label>
          <div class="vslider-track" data-param="cutoff" data-min="20" data-max="18000" data-val="8000">
            <div class="vslider-handle"></div>
          </div>
        </div>

        <div class="slider-col">
          <label>RES</label>
          <div class="vslider-track" data-param="resonance" data-min="0.01" data-max="20" data-val="1">
            <div class="vslider-handle"></div>
          </div>
        </div>

        <div class="slider-col">
          <label>EG</label>
          <div class="vslider-track" data-param="filterEgDepth" data-min="0" data-max="1" data-val="0">
            <div class="vslider-handle"></div>
          </div>
        </div>
      </div>
    </div>

    <div style="height:10px;"></div>

    <!-- ENV (collapsible) -->
    <div class="sound-section-title" onclick="toggleSection('envSection')">ENV ▾</div>
    <div id="envSection">
      <div class="env-grid">
        <div class="slider-col">
          <label>ATK</label>
          <div class="vslider-track" data-param="attack" data-min="0.001" data-max="4" data-val="0.01">
            <div class="vslider-handle"></div>
          </div>
        </div>
        <div class="slider-col">
          <label>DEC</label>
          <div class="vslider-track" data-param="decay" data-min="0.001" data-max="4" data-val="0.3">
            <div class="vslider-handle"></div>
          </div>
        </div>
        <div class="slider-col">
          <label>SUS</label>
          <div class="vslider-track" data-param="sustain" data-min="0" data-max="1" data-val="0.7">
            <div class="vslider-handle"></div>
          </div>
        </div>
        <div class="slider-col">
          <label>REL</label>
          <div class="vslider-track" data-param="release" data-min="0.001" data-max="6" data-val="0.5">
            <div class="vslider-handle"></div>
          </div>
        </div>
      </div>
    </div>

    <div style="height:10px;"></div>

    <!-- VCA -->
    <div class="sound-section-title" onclick="toggleSection('vcaSection')">VCA ▾</div>
    <div id="vcaSection">
      <div class="vca-stack">
        <div class="slider-col">
          <label>DEP</label>
          <div class="vslider-track" data-param="vcaDepth" data-min="0.05" data-max="1" data-val="0.8">
            <div class="vslider-handle"></div>
          </div>
        </div>
        <div class="note-display" id="noteDisplay">---</div>
      </div>
    </div>

    <!-- VOLUME at the very end -->
    <div style="display:flex; justify-content:center; margin-top:12px;">
      <div class="slider-col">
        <label style="color:var(--accent);">VOL</label>
        <div class="knob" id="knob-vol" data-param="volume" data-min="0" data-max="1" data-val="0.7">
          <div class="dot"></div>
        </div>
      </div>
    </div>

    <!-- PITCH/MOD (hidden by default) -->
    <div id="pitchModSection" class="hidden" style="margin-top:12px;">
      <div class="block-title" style="margin-bottom:6px; font-size:12px;">Pitch / Mod</div>

      <div class="pm-wrap">
        <div class="pm-col">
          <div class="pm-title">Pitch (±2 st)</div>
          <div id="pitchRibbon" class="ribbon"></div>
          <div id="pitchVal" class="pm-val">0.00</div>
        </div>
        <div class="pm-col">
          <div class="pm-title">Mod (vib+cut)</div>
          <div id="modRibbon" class="ribbon"></div>
          <div id="modVal" class="pm-val">0.00</div>
        </div>
      </div>
    </div>
  </div>

  <!-- BLOCK 3 : SEQ -->
  <div class="seq-panel">
    <div class="seq-controls">
      <button class="seq-btn" id="btnPlay" onclick="seqToggle()">▶ PLAY</button>
      <button class="seq-btn" onclick="seqStop()">■ STOP</button>

      <button class="seq-btn" id="btnPitchMod" onclick="togglePitchMod()">PITCH/MOD ▸</button>
      <button class="seq-btn" id="btnFxPanel" onclick="toggleFxPanel()">FX ▾</button>

      <div style="display:flex;align-items:center;gap:6px;">
        <span style="color:var(--accent);font-size:11px;font-weight:900;letter-spacing:1px;">BPM</span>
        <div class="icon-btn" onmousedown="startBpmChange(-1)" onmouseup="stopBpmChange()"
             ontouchstart="startBpmChange(-1)" ontouchend="stopBpmChange()">−</div>
        <div class="bpm-display" id="bpmDisplay">120</div>
        <div class="icon-btn" onmousedown="startBpmChange(1)" onmouseup="stopBpmChange()"
             ontouchstart="startBpmChange(1)" ontouchend="stopBpmChange()">+</div>
      </div>

      <div style="display:flex;align-items:center;gap:6px;">
        <span style="color:var(--accent);font-size:11px;font-weight:900;letter-spacing:1px;">STEPS</span>
        <select class="steps-select" onchange="setNumSteps(+this.value)">
          <option value="8">8</option>
          <option value="12">12</option>
          <option value="16" selected>16</option>
          <option value="24">24</option>
          <option value="32">32</option>
        </select>
      </div>

      <div style="display:flex;align-items:center;gap:6px;">
        <span style="color:var(--accent);font-size:11px;font-weight:900;letter-spacing:1px;">OCT</span>
        <div class="icon-btn" onclick="scrollOctave(1)">▲</div>
        <div id="octLabel" style="color:#cfd6db;font-size:12px;min-width:30px;text-align:center;font-weight:900;">C3</div>
        <div class="icon-btn" onclick="scrollOctave(-1)">▼</div>
      </div>

      <div style="display:flex;gap:6px;margin-left:auto;">
        <button class="seq-btn" onclick="clearGrid()">CLEAR</button>
        <button class="seq-btn" onclick="randomize()">RAND</button>
      </div>
    </div>

    <div class="seq-step-headers" id="stepHeaders"></div>
    <div class="seq-grid-wrapper" id="seqGrid"></div>
  </div>

  <!-- BLOCK 4 : FX -->
  <div class="fx-panel" id="fxPanel">
    <div style="display:flex;align-items:center;margin-bottom:10px;">
      <div style="color:#b7c0c7;font-weight:900;font-size:12px;letter-spacing:2px;text-transform:uppercase;">Tape</div>
      <button class="fx-bypass-btn" id="tapeBypass" onclick="toggleFx('tape')" style="margin-left:auto;">OFF</button>
    </div>

    <div style="display:flex;gap:18px;align-items:flex-end;flex-wrap:wrap;margin-bottom:16px;">
      <div class="fx-knob-group">
        <div class="fx-knob-label">Drive</div>
        <div class="fx-knob" data-param="tapeDrive" data-min="1" data-max="30" data-val="4"><div class="fx-knob-dot"></div></div>
        <div id="val-tapeDrive" class="fx-knob-val">4.0</div>
      </div>
      <div class="fx-knob-group">
        <div class="fx-knob-label">Tone</div>
        <div class="fx-knob" data-param="tapeTone" data-min="200" data-max="8000" data-val="3000"><div class="fx-knob-dot"></div></div>
        <div id="val-tapeTone" class="fx-knob-val">3k</div>
      </div>
      <div class="fx-knob-group">
        <div class="fx-knob-label">Wow</div>
        <div class="fx-knob" data-param="tapeWow" data-min="0" data-max="1" data-val="0.2"><div class="fx-knob-dot"></div></div>
        <div id="val-tapeWow" class="fx-knob-val">20%</div>
      </div>
      <div class="fx-knob-group">
        <div class="fx-knob-label">Mix</div>
        <div class="fx-knob" data-param="tapeMix" data-min="0" data-max="1" data-val="0.6"><div class="fx-knob-dot"></div></div>
        <div id="val-tapeMix" class="fx-knob-val">60%</div>
      </div>
    </div>

    <div style="display:flex;align-items:center;margin-bottom:10px;">
      <div style="color:#b7c0c7;font-weight:900;font-size:12px;letter-spacing:2px;text-transform:uppercase;">Echo</div>
      <button class="fx-bypass-btn" id="echoBypass" onclick="toggleFx('echo')" style="margin-left:auto;">OFF</button>
    </div>

    <div style="display:flex;gap:18px;align-items:flex-end;flex-wrap:wrap;">
      <div class="fx-knob-group">
        <div class="fx-knob-label">Time</div>
        <div class="fx-knob" data-param="echoTime" data-min="0.05" data-max="1.2" data-val="0.375"><div class="fx-knob-dot"></div></div>
        <div id="val-echoTime" class="fx-knob-val">375ms</div>
      </div>
      <div class="fx-knob-group">
        <div class="fx-knob-label">Fdbk</div>
        <div class="fx-knob" data-param="echoFeedback" data-min="0" data-max="0.92" data-val="0.4"><div class="fx-knob-dot"></div></div>
        <div id="val-echoFeedback" class="fx-knob-val">40%</div>
      </div>
      <div class="fx-knob-group">
        <div class="fx-knob-label">Size</div>
        <div class="fx-knob" data-param="reverbSize" data-min="0.1" data-max="6" data-val="2.5"><div class="fx-knob-dot"></div></div>
        <div id="val-reverbSize" class="fx-knob-val">2.5s</div>
      </div>
      <div class="fx-knob-group">
        <div class="fx-knob-label">Rev</div>
        <div class="fx-knob" data-param="reverbMix" data-min="0" data-max="1" data-val="0.3"><div class="fx-knob-dot"></div></div>
        <div id="val-reverbMix" class="fx-knob-val">30%</div>
      </div>
      <div class="fx-knob-group">
        <div class="fx-knob-label">Mix</div>
        <div class="fx-knob" data-param="echoMix" data-min="0" data-max="1" data-val="0.4"><div class="fx-knob-dot"></div></div>
        <div id="val-echoMix" class="fx-knob-val">40%</div>
      </div>
    </div>
  </div>

  <div style="text-align:center;color:#3a4046;font-size:10px;margin-top:4px;">
    miCS01 · Elektron minimal · Web Audio
  </div>
</div>

<script>
/* iOS viewport fix */
(function setVh(){
  const set = () => {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  };
  set();
  window.addEventListener('resize', set, { passive: true });
  window.addEventListener('orientationchange', () => setTimeout(set, 120), { passive: true });
})();

/* Utilities */
function clamp(x, lo, hi){ return x < lo ? lo : x > hi ? hi : x; }
function lerp(a, b, t){ return a + (b - a) * t; }
function polyblep(phase, dt){
  if (phase < dt){ const t = phase / dt; return t+t - t*t - 1; }
  if (phase > 1 - dt){ const t = (phase - 1) / dt; return t*t + t+t + 1; }
  return 0;
}
function noteToFreq(midi){ return 440 * Math.pow(2, (midi - 69) / 12); }
function softClip(x){ return Math.tanh(x); }

/* Juno Post-Filter */
class JunoPostFilter {
  constructor(audioCtx){
    this.ctx = audioCtx;
    this.input = this.ctx.createGain();

    this.hpf = this.ctx.createBiquadFilter();
    this.hpf.type = 'highpass';
    this.hpf.frequency.value = 20;
    this.hpf.Q.value = 0.707;

    this.lp1 = this.ctx.createBiquadFilter();
    this.lp1.type = 'lowpass';
    this.lp1.frequency.value = 8000;
    this.lp1.Q.value = 0.707;

    this.lp2 = this.ctx.createBiquadFilter();
    this.lp2.type = 'lowpass';
    this.lp2.frequency.value = 8000;
    this.lp2.Q.value = 0.707;

    this.shaper = this.ctx.createWaveShaper();
    this.shaper.oversample = '4x';
    this.drive = 0.35;

    this.out = this.ctx.createGain();

    this.input.connect(this.hpf);
    this.hpf.connect(this.lp1);
    this.lp1.connect(this.lp2);
    this.lp2.connect(this.shaper);
    this.shaper.connect(this.out);

    this.setDrive(this.drive);
    this.setCutoff(8000);
    this.setResonance(0.2);
    this.setHpf(20);
  }
  _makeCurve(amount01){
    const n = 512;
    const curve = new Float32Array(n);
    const k = 2 + amount01 * 18;
    for (let i=0;i<n;i++){
      const x = (i * 2) / (n - 1) - 1;
      curve[i] = softClip(x * k);
    }
    return curve;
  }
  setCutoff(hz){
    const f = Math.max(20, Math.min(hz, this.ctx.sampleRate * 0.45));
    this.lp1.frequency.setTargetAtTime(f, this.ctx.currentTime, 0.01);
    this.lp2.frequency.setTargetAtTime(f, this.ctx.currentTime, 0.01);
  }
  setResonance(amount01){
    const a = Math.max(0, Math.min(1, amount01));
    const q = 0.707 + a * 6.5;
    this.lp1.Q.setTargetAtTime(q, this.ctx.currentTime, 0.01);
    this.lp2.Q.setTargetAtTime(q, this.ctx.currentTime, 0.01);
  }
  setHpf(hz){
    const f = Math.max(10, Math.min(hz, this.ctx.sampleRate * 0.45));
    this.hpf.frequency.setTargetAtTime(f, this.ctx.currentTime, 0.01);
  }
  setDrive(amount01){
    this.drive = Math.max(0, Math.min(1, amount01));
    this.shaper.curve = this._makeCurve(this.drive);
  }
}

/* Engines */
class VirtualAnalogEngine {
  constructor(sr){ this.sr=sr; this.phase1=0; this.phase2=0; }
  reset(){ this.phase1=Math.random(); this.phase2=Math.random(); }
  render(freq, harmonics, timbre, morph, out, size){
    const sr=this.sr;
    const detuneSemitones = harmonics * 1.0;
    const f1 = clamp(freq / sr, 0.00001, 0.499);
    const f2 = clamp(freq * Math.pow(2, detuneSemitones / 12) / sr, 0.00001, 0.499);
    const pw = clamp(timbre, 0.05, 0.95);
    const mix = morph;
    for(let i=0;i<size;i++){
      this.phase1 += f1; if(this.phase1>=1) this.phase1-=1;
      this.phase2 += f2; if(this.phase2>=1) this.phase2-=1;

      let s1 = this.phase1 < pw ? 1:-1;
      s1 += polyblep(this.phase1, f1);
      s1 -= polyblep((this.phase1 + 1 - pw) % 1, f1);
      s1 = s1 - pw*2 + 1;

      let s2 = this.phase2 < pw ? 1:-1;
      s2 += polyblep(this.phase2, f2);
      s2 -= polyblep((this.phase2 + 1 - pw) % 1, f2);
      s2 = s2 - pw*2 + 1;

      out[i] += lerp(s1, s2, mix) * 0.5;
    }
  }
}
class WaveshapingEngine {
  constructor(sr){ this.sr=sr; this.phase=0; }
  reset(){ this.phase=Math.random(); }
  render(freq, harmonics, timbre, morph, out, size){
    const sr=this.sr;
    const f=clamp(freq/sr,0.00001,0.499);
    for(let i=0;i<size;i++){
      this.phase += f; if(this.phase>=1) this.phase-=1;
      const skew = clamp(0.05 + morph*0.9, 0.05, 0.95);
      let tri = this.phase < skew ? this.phase/skew*2 - 1 : (1 - this.phase)/(1 - skew)*2 - 1;

      const shape = harmonics;
      const folded = shape < 0.5
        ? lerp(tri, Math.sin(Math.PI*tri), shape*2)
        : lerp(Math.sin(Math.PI*tri),
               Math.sin(Math.PI*3*tri)*0.33 + Math.sin(Math.PI*tri)*0.67,
               (shape-0.5)*2);

      let fold = folded;
      const foldAmt=timbre*4;
      fold = fold*(1 + foldAmt);
      fold = fold - 2 * Math.round(fold/2);
      if(fold>1) fold=2-fold;
      if(fold<-1) fold=-2-fold;

      out[i] += lerp(folded, fold, timbre) * 0.7;
    }
  }
}
class FMEngine {
  constructor(sr){ this.sr=sr; this.phase_m=0; this.phase_c=0; this.fb=0; }
  reset(){ this.phase_m=0; this.phase_c=0; this.fb=0; }
  render(freq, harmonics, timbre, morph, out, size){
    const sr=this.sr;
    const ratios=[0.5,1,1.5,2,3,4,5,7,8];
    const ri=harmonics*(ratios.length-1);
    const r0=ratios[Math.floor(ri)];
    const r1=ratios[Math.min(Math.ceil(ri), ratios.length-1)];
    const ratio=lerp(r0,r1, ri - Math.floor(ri));
    const fc = clamp(freq/sr,0.00001,0.45);
    const fm = clamp(freq*ratio/sr,0.00001,0.49);
    const modIdx=timbre*8;
    const fbAmt=morph;
    for(let i=0;i<size;i++){
      const fbSample=this.fb * fbAmt * 4;
      this.phase_m += fm; if(this.phase_m>=1) this.phase_m-=1;
      const modSin = Math.sin(2*Math.PI*(this.phase_m + fbSample));
      this.fb = modSin;
      this.phase_c += fc; if(this.phase_c>=1) this.phase_c-=1;
      out[i] += Math.sin(2*Math.PI*this.phase_c + modIdx*modSin) * 0.6;
    }
  }
}
class GrainletEngine {
  constructor(sr){ this.sr=sr; this.carrierPhase=0; this.formantPhase=0; }
  reset(){ this.carrierPhase=Math.random(); this.formantPhase=0; }
  grainlet(carrierPhase, formantPhase, shape, bleed){
    const carrier = Math.sin(2*Math.PI*formantPhase);
    const window_ = Math.max(0, Math.cos(Math.PI*carrierPhase - Math.PI*0.5));
    const grain = carrier * window_*window_;
    return lerp(carrier, grain, shape) + carrierPhase*bleed;
  }
  render(freq, harmonics, timbre, morph, out, size){
    const sr=this.sr;
    const fc=clamp(freq/sr,0.00001,0.4);
    const formantRatio=1 + harmonics*8;
    const ff=clamp(fc*formantRatio,0.00001,0.499);
    const shape=timbre;
    const bleed=morph*0.1;
    for(let i=0;i<size;i++){
      this.carrierPhase += fc;
      let reset=false;
      if(this.carrierPhase>=1){ this.carrierPhase-=1; this.formantPhase=0; reset=true; }
      this.formantPhase += ff; if(this.formantPhase>=1) this.formantPhase-=1;
      const s=this.grainlet(this.carrierPhase, this.formantPhase, shape, bleed);
      let blep=0; if(reset) blep = polyblep(this.carrierPhase, fc)*0.5;
      out[i] += (s + blep) * 0.65;
    }
  }
}
class AdditiveEngine {
  constructor(sr){
    this.sr=sr;
    this.phases=new Float32Array(24);
    for(let i=0;i<24;i++) this.phases[i]=Math.random();
  }
  reset(){ for(let i=0;i<24;i++) this.phases[i]=0; }
  render(freq, harmonics, timbre, morph, out, size){
    const sr=this.sr, numH=24;
    const centroid=1 + harmonics*(numH-1);
    const width=0.5 + timbre * numH*0.5;
    const peak=morph;
    const gains=new Float32Array(numH);
    let totalGain=0;
    for(let h=0;h<numH;h++){
      const n=h+1;
      const dist=Math.abs(n-centroid);
      const g=Math.exp(-dist*dist/(width*width + 0.1));
      gains[h]=Math.pow(g, 1 + peak*4);
      totalGain += gains[h];
    }
    if(totalGain<0.001) totalGain=1;
    for(let i=0;i<size;i++){
      let s=0;
      for(let h=0;h<numH;h++){
        if(gains[h]<0.001) continue;
        const n=h+1;
        const f=clamp(freq*n/sr,0.00001,0.499);
        this.phases[h]+=f; if(this.phases[h]>=1) this.phases[h]-=1;
        s += Math.sin(2*Math.PI*this.phases[h]) * gains[h] / totalGain;
      }
      out[i] += s*0.7;
    }
  }
}
class WavetableEngine {
  constructor(sr){
    this.sr=sr;
    this.phase=0;
    this.WT_SIZE=256;
    this.WT_COUNT=8;
    this.tables=[];
    for(let t=0;t<this.WT_COUNT;t++){
      const tbl=new Float32Array(this.WT_SIZE);
      for(let s=0;s<this.WT_SIZE;s++){
        const ph=s/this.WT_SIZE;
        switch(t){
          case 0: tbl[s]=Math.sin(2*Math.PI*ph); break;
          case 1: tbl[s]=ph<0.5?ph*4-1:3-ph*4; break;
          case 2: tbl[s]=ph<0.5?1:-1; break;
          case 3: tbl[s]=ph*2-1; break;
          case 4: tbl[s]=1 - ph*2; break;
          case 5: tbl[s]=Math.sin(2*Math.PI*ph)+Math.sin(4*Math.PI*ph)*0.5+Math.sin(6*Math.PI*ph)*0.25; break;
          case 6: tbl[s]=Math.sin(2*Math.PI*ph)*Math.sin(4*Math.PI*ph); break;
          case 7: tbl[s]=Math.sin(2*Math.PI*ph + Math.sin(4*Math.PI*ph)*1.5); break;
        }
      }
      let mx=0;
      for(let s=0;s<this.WT_SIZE;s++) mx=Math.max(mx,Math.abs(tbl[s]));
      if(mx>0.001) for(let s=0;s<this.WT_SIZE;s++) tbl[s]/=mx;
      this.tables.push(tbl);
    }
  }
  reset(){ this.phase=Math.random(); }
  readWT(idx, phase){
    const tbl=this.tables[Math.floor(idx)%this.WT_COUNT];
    const pos=phase*this.WT_SIZE;
    const i0=Math.floor(pos)%this.WT_SIZE;
    const i1=(i0+1)%this.WT_SIZE;
    return lerp(tbl[i0], tbl[i1], pos - Math.floor(pos));
  }
  render(freq, harmonics, timbre, morph, out, size){
    const sr=this.sr;
    const wtPos=timbre*(this.WT_COUNT-1);
    const wt0=Math.floor(wtPos);
    const wt1=Math.min(wt0+1, this.WT_COUNT-1);
    const wtFrac=wtPos-wt0;
    const distort=morph;
    const f=clamp(freq/sr,0.00001,0.499);
    const hFreq=f*(1 + Math.floor(harmonics*3));
    for(let i=0;i<size;i++){
      this.phase += clamp(hFreq,0.00001,0.499);
      if(this.phase>=1) this.phase-=1;
      let ph=this.phase;
      if(distort>0.01){
        ph = ph<0.5 ? ph*(0.5+distort*0.5)*2 : 0.5+(ph-0.5)*(0.5+(1-distort)*0.5)*2;
        ph = clamp(ph,0,0.9999);
      }
      const s0=this.readWT(wt0,ph);
      const s1=this.readWT(wt1,ph);
      out[i] += lerp(s0,s1,wtFrac)*0.7;
    }
  }
}
class SwarmEngine {
  constructor(sr){
    this.sr=sr; this.N=8;
    this.phases=new Float32Array(this.N);
    this.detunes=new Float32Array(this.N);
    for(let i=0;i<this.N;i++){ this.phases[i]=Math.random(); this.detunes[i]=(i/(this.N-1)-0.5); }
  }
  reset(){ for(let i=0;i<this.N;i++) this.phases[i]=Math.random(); }
  render(freq, harmonics, timbre, morph, out, size){
    const sr=this.sr;
    const spread=harmonics*0.5;
    const pw=clamp(0.05+timbre*0.9,0.05,0.95);
    const sqMix=morph;
    for(let i=0;i<size;i++){
      let s=0;
      for(let v=0;v<this.N;v++){
        const detuneST=this.detunes[v]*spread*2;
        const f=clamp(freq*Math.pow(2,detuneST/12)/sr,0.00001,0.499);
        this.phases[v]+=f; if(this.phases[v]>=1) this.phases[v]-=1;
        let saw=this.phases[v]*2-1;
        saw -= polyblep(this.phases[v],f);
        let sq=this.phases[v]<pw?1:-1;
        sq += polyblep(this.phases[v],f);
        sq -= polyblep((this.phases[v]+1-pw)%1,f);
        s += lerp(saw,sq,sqMix);
      }
      out[i] += s/this.N * 0.7;
    }
  }
}
class ChordEngine {
  constructor(sr){
    this.sr=sr; this.N=4;
    this.phases=new Float32Array(this.N);
    this.chords=[[0,7,12,19],[0,4,7,12],[0,3,7,12],[0,4,7,11],[0,3,7,10],[0,4,8,12],[0,3,6,12],[0,5,7,12],[0,2,7,12],[0,4,7,14]];
  }
  reset(){ for(let i=0;i<this.N;i++) this.phases[i]=Math.random(); }
  render(freq, harmonics, timbre, morph, out, size){
    const sr=this.sr;
    const chordIdx=Math.floor(harmonics*(this.chords.length-1));
    const chord=this.chords[clamp(chordIdx,0,this.chords.length-1)];
    const pw=clamp(0.05+timbre*0.9,0.05,0.95);
    const detune=morph*0.005;
    for(let i=0;i<size;i++){
      let s=0;
      for(let v=0;v<this.N;v++){
        const st=chord[v];
        const f=clamp(freq*Math.pow(2,(st + v*detune*12)/12)/sr,0.00001,0.499);
        this.phases[v]+=f; if(this.phases[v]>=1) this.phases[v]-=1;
        let sq=this.phases[v]<pw?1:-1;
        sq += polyblep(this.phases[v],f);
        sq -= polyblep((this.phases[v]+1-pw)%1,f);
        s += sq;
      }
      out[i] += s/this.N * 0.65;
    }
  }
}

/* PlaitsVoice */
class PlaitsVoice {
  constructor(sr, midi, engineIdx){
    this.sr=sr;
    this.midi=midi;
    this.freq=noteToFreq(midi);
    this.alive=true;
    this.env=0;
    this.envPhase='attack';
    this.filterState=0;

    const engines=[VirtualAnalogEngine,WaveshapingEngine,FMEngine,GrainletEngine,AdditiveEngine,WavetableEngine,SwarmEngine,ChordEngine];
    const E=engines[clamp(engineIdx,0,engines.length-1)];
    this.engine=new E(sr);
    this.engine.reset();
  }
  noteOff(){ this.envPhase='release'; }
  processADSR(attack,decay,sustain,release){
    const sr=this.sr;
    switch(this.envPhase){
      case 'attack':
        this.env += 1/(attack*sr+1);
        if(this.env>=1){ this.env=1; this.envPhase='decay'; }
        break;
      case 'decay':
        this.env += (sustain - this.env)/(decay*sr*0.3+1);
        if(Math.abs(this.env-sustain)<0.001){ this.env=sustain; this.envPhase='sustain'; }
        break;
      case 'sustain':
        this.env=sustain;
        break;
      case 'release':
        this.env *= 1 - 1/(release*sr*0.3+1);
        if(this.env<0.0001){ this.env=0; this.alive=false; }
        break;
    }
    return this.env;
  }
  render(params, output, size, pitchSemiAdd){
    const tmp=new Float32Array(size);
    const freq=this.freq * params.octaveMult * Math.pow(2, (params.pitchSemi + pitchSemiAdd)/12);
    this.engine.render(freq, params.harmonics, params.timbre, params.morph, tmp, size);

    for(let i=0;i<size;i++){
      const env=this.processADSR(params.attack, params.decay, params.sustain, params.release);
      const cutoffNorm=clamp(params.cutoff/(this.sr*0.5),0.001,0.999);
      const cutEg = cutoffNorm*(1 + params.filterEgDepth*env*4);
      const coeff=clamp(1 - Math.exp(-2*Math.PI*clamp(cutEg,0.001,0.499)),0,1);
      this.filterState += coeff * (tmp[i] - this.filterState);
      output[i] += this.filterState * env * params.vcaDepth;
    }
  }
}

/* Globals */
const voicePool=new Map();

const DSP_PARAMS={
  engineIdx:0,
  harmonics:0.5, timbre:0.5, morph:0.5,
  attack:0.01, decay:0.3, sustain:0.7, release:0.5,
  cutoff:8000, resonance:1, filterEgDepth:0,
  vcaDepth:0.8, octaveMult:1, pitchSemi:0,
};

let audioCtx=null;
let scriptNode=null;
let masterGain=null;
let junoFilter=null;

/* FX nodes */
let fxInputGain=null, fxOutputGain=null;
let tapeInputGain=null, tapeToneFilter=null, tapeWaveshaper=null, tapeWowOsc=null, tapeWowGain=null, tapeWowDepth=null;
let tapeDryGain=null, tapeWetGain=null;
let delayNode=null, delayFeedGain=null, delayWetGain=null;
let reverbNode=null, reverbWetGain=null, reverbDryGain=null;

let vcfPing = 0;

/* Pitch/Mod wired */
let pitchBendSemi = 0;
let modAmt = 0;
let lfoPhase = 0;

const P={
  engineIdx:0,
  harmonics:0.5, timbre:0.5, morph:0.5,
  attack:0.01, decay:0.3, sustain:0.7, release:0.5,
  cutoff:8000, resonance:1, filterEgDepth:0,
  vcaDepth:0.8, octaveMult:1, pitchSemi:0,
  lfoSpeed:4.5, volume:0.7
};

const FX={
  tapeOn:false, echoOn:false,
  tapeDrive:4, tapeTone:3000, tapeWow:0.2, tapeMix:0.6,
  echoTime:0.375, echoFeedback:0.4,
  reverbSize:2.5, reverbMix:0.3, echoMix:0.4,
};

function sendParam(param, val){ if (param in DSP_PARAMS) DSP_PARAMS[param] = val; }
function sendAllParams(){ Object.keys(DSP_PARAMS).forEach(k => { if (k in P) DSP_PARAMS[k] = P[k]; }); }

function makeSatCurve(amount){
  const n = 1024;
  const curve = new Float32Array(n);
  const k = Math.max(0.001, amount);
  for(let i=0;i<n;i++){
    const x = (i * 2) / (n - 1) - 1;
    curve[i] = Math.tanh(x * k);
  }
  return curve;
}

function buildReverbIR(seconds){
  const sr = audioCtx.sampleRate;
  const len = Math.max(1, Math.floor(sr * clamp(seconds, 0.1, 10)));
  const ir = audioCtx.createBuffer(2, len, sr);
  for (let ch=0; ch<2; ch++){
    const data = ir.getChannelData(ch);
    for (let i=0;i<len;i++){
      const t = i / len;
      const decay = Math.pow(1 - t, 2.7);
      data[i] = (Math.random()*2 - 1) * decay;
    }
  }
  return ir;
}

function setFxStateFromFlags(){
  if(!tapeDryGain) return;
  tapeDryGain.gain.value = FX.tapeOn ? (1 - FX.tapeMix) : 1;
  tapeWetGain.gain.value = FX.tapeOn ? FX.tapeMix : 0;

  delayWetGain.gain.value = FX.echoOn ? FX.echoMix : 0;
  reverbWetGain.gain.value = FX.echoOn ? FX.reverbMix : 0;
  reverbDryGain.gain.value = FX.echoOn ? (1 - FX.reverbMix) : 1;
}

/* Audio init */
function initAudio(){
  if(audioCtx) return;
  audioCtx=new (window.AudioContext||window.webkitAudioContext)();

  scriptNode=audioCtx.createScriptProcessor(512,0,1);
  scriptNode.onaudioprocess=e=>{
    const output=e.outputBuffer.getChannelData(0);
    const size=output.length;
    const buf=new Float32Array(size);

    const vibDepthSemi = 0.35 * modAmt;
    const cutoffWobble = 1200 * modAmt;
    const lfoInc = (P.lfoSpeed / audioCtx.sampleRate);
    const lfoNow = Math.sin(2*Math.PI*lfoPhase);
    const pitchSemiAdd = pitchBendSemi + (lfoNow * vibDepthSemi);

    for(const [midi,voices] of voicePool){
      for(let i=voices.length-1;i>=0;i--){
        const v=voices[i];
        if(!v.alive){ voices.splice(i,1); continue; }
        v.render(DSP_PARAMS, buf, size, pitchSemiAdd);
      }
      if(voices.length===0) voicePool.delete(midi);
    }

    lfoPhase += lfoInc * size;
    lfoPhase -= Math.floor(lfoPhase);

    if(junoFilter){
      vcfPing*=0.92;
      const base=P.cutoff;
      const eg=P.filterEgDepth;
      const wob = Math.sin(2*Math.PI*lfoPhase) * cutoffWobble;
      junoFilter.setCutoff(base*(1 + eg*vcfPing*3.5) + wob);
    }

    for(let i=0;i<size;i++) output[i]=clamp(buf[i],-1,1);
  };

  masterGain=audioCtx.createGain();
  masterGain.gain.value=P.volume;
  scriptNode.connect(masterGain);

  junoFilter=new JunoPostFilter(audioCtx);
  masterGain.connect(junoFilter.input);

  fxInputGain = audioCtx.createGain();
  junoFilter.out.connect(fxInputGain);

  /* Tape */
  tapeInputGain = audioCtx.createGain();
  tapeInputGain.gain.value = FX.tapeDrive;

  tapeToneFilter = audioCtx.createBiquadFilter();
  tapeToneFilter.type = 'lowpass';
  tapeToneFilter.frequency.value = FX.tapeTone;
  tapeToneFilter.Q.value = 0.6;

  tapeWaveshaper = audioCtx.createWaveShaper();
  tapeWaveshaper.oversample = '4x';
  tapeWaveshaper.curve = makeSatCurve(FX.tapeDrive*8);

  tapeWowOsc = audioCtx.createOscillator();
  tapeWowOsc.type = 'sine';
  tapeWowOsc.frequency.value = 0.35;

  tapeWowGain = audioCtx.createGain();
  tapeWowGain.gain.value = FX.tapeWow * 5;

  tapeWowDepth = audioCtx.createGain();
  tapeWowDepth.gain.value = 1200;

  tapeWowOsc.connect(tapeWowGain);
  tapeWowGain.connect(tapeWowDepth);
  tapeWowDepth.connect(tapeToneFilter.frequency);
  tapeWowOsc.start();

  tapeDryGain = audioCtx.createGain();
  tapeWetGain = audioCtx.createGain();

  /* Echo + verb */
  delayNode = audioCtx.createDelay(2.0);
  delayNode.delayTime.value = FX.echoTime;

  delayFeedGain = audioCtx.createGain();
  delayFeedGain.gain.value = FX.echoFeedback;

  delayWetGain = audioCtx.createGain();
  delayWetGain.gain.value = 0;

  reverbNode = audioCtx.createConvolver();
  reverbNode.buffer = buildReverbIR(FX.reverbSize);

  reverbWetGain = audioCtx.createGain();
  reverbWetGain.gain.value = 0;

  reverbDryGain = audioCtx.createGain();
  reverbDryGain.gain.value = 1;

  /* wiring */
  fxInputGain.connect(tapeDryGain);

  fxInputGain.connect(tapeInputGain);
  tapeInputGain.connect(tapeToneFilter);
  tapeToneFilter.connect(tapeWaveshaper);
  tapeWaveshaper.connect(tapeWetGain);

  const postTape = audioCtx.createGain();
  tapeDryGain.connect(postTape);
  tapeWetGain.connect(postTape);

  postTape.connect(delayNode);
  delayNode.connect(delayFeedGain);
  delayFeedGain.connect(delayNode);

  delayNode.connect(delayWetGain);
  delayNode.connect(reverbNode);
  reverbNode.connect(reverbWetGain);

  postTape.connect(reverbDryGain);

  fxOutputGain = audioCtx.createGain();
  reverbDryGain.connect(fxOutputGain);
  delayWetGain.connect(fxOutputGain);
  reverbWetGain.connect(fxOutputGain);
  fxOutputGain.connect(audioCtx.destination);

  setFxStateFromFlags();
  sendAllParams();
}

function ensureAudioRunning(){
  initAudio();
  if(audioCtx && audioCtx.state!=='running'){
    return audioCtx.resume().catch(()=>{});
  }
}

/* Notes */
function midiToName(midi) {
  const ns = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  return ns[midi % 12] + (Math.floor(midi / 12) - 1);
}
function playNote(midi) {
  if (!audioCtx) return;

  const arr = voicePool.get(midi);
  if (arr && arr.length) arr.forEach(v => v.noteOff());

  const voice = new PlaitsVoice(audioCtx.sampleRate, midi, DSP_PARAMS.engineIdx);
  if (!voicePool.has(midi)) voicePool.set(midi, []);
  voicePool.get(midi).push(voice);

  document.getElementById('noteDisplay').textContent = midiToName(midi);
  vcfPing = Math.min(1, vcfPing + 0.35);
}
function stopNote(midi, immediate = false) {
  const arr = voicePool.get(midi);
  if (!arr) return;
  if (immediate) voicePool.delete(midi);
  else arr.forEach(v => v.noteOff());
}
function stopAllNotes(immediate = false) {
  if (immediate) voicePool.clear();
  else for (const [midi, voices] of voicePool) voices.forEach(v => v.noteOff());
  document.getElementById('noteDisplay').textContent = '---';
}

/* Sequencer */
const MAX_STEPS = 32;
let NUM_ROWS = 25;
const isSmall = () => window.matchMedia && window.matchMedia('(max-width: 430px)').matches;
function setRowsForScreen(){ NUM_ROWS = isSmall() ? 15 : 25; }

let viewBase = 48;
let numSteps = 16, bpm = 120, swing = 0.5;
let seqRunning = false, currentStep = 0, stepTimer = null, bpmInterval = null;

let patterns = [new Map(), new Map(), new Map(), new Map()];
let currentPatIdx = 0;
function getGrid() { return patterns[currentPatIdx]; }

function cellOn(midi, step) {
  const g = getGrid();
  return g.has(midi) && g.get(midi)[step];
}

function toggleCell(midi, step, forceVal) {
  const g = getGrid();
  if (!g.has(midi)) g.set(midi, new Array(MAX_STEPS).fill(false));
  g.get(midi)[step] = (forceVal !== undefined) ? forceVal : !g.get(midi)[step];
  refreshCell(midi, step);
}

function getViewNotes() {
  const a=[];
  for(let i=NUM_ROWS-1;i>=0;i--) a.push(viewBase+i);
  return a;
}

function clearStepHighlights() {
  document.querySelectorAll('.seq-cell.playing').forEach(c => c.classList.remove('playing'));
}
function highlightStep(step) {
  getViewNotes().forEach(midi => {
    const el = document.getElementById(`c-${midi}-${step}`);
    if (el) el.classList.add('playing');
  });
}

const noteOffTimers = new Map();
const GATE = 0.90;

function tick() {
  if (!seqRunning) return;

  clearStepHighlights();
  highlightStep(currentStep);

  const s16 = 60000 / bpm / 4;
  const sw = (swing - 0.5) * 0.6;
  const delayMs = currentStep % 2 === 0 ? s16 * (1 + sw) : s16 * (1 - sw);
  const gateMs = Math.max(10, delayMs * GATE);

  const notesOn = [];
  getGrid().forEach((row, midi) => { if (row[currentStep]) notesOn.push(midi); });

  if (!notesOn.length) {
    document.getElementById('noteDisplay').textContent = '---';
  }

  for (const midi of notesOn) {
    playNote(midi);
    if (noteOffTimers.has(midi)) clearTimeout(noteOffTimers.get(midi));
    noteOffTimers.set(midi, setTimeout(() => {
      stopNote(midi, false);
      noteOffTimers.delete(midi);
    }, gateMs));
  }

  currentStep = (currentStep + 1) % numSteps;
  stepTimer = setTimeout(tick, delayMs);
}

async function seqToggle() {
  if (seqRunning) {
    seqRunning = false;
    clearTimeout(stepTimer);
    stopAllNotes(false);
    document.getElementById('btnPlay').textContent = '▶ PLAY';
    document.getElementById('btnPlay').classList.remove('playing');
    clearStepHighlights();
  } else {
    await ensureAudioRunning();
    seqRunning = true;
    currentStep = 0;
    document.getElementById('btnPlay').textContent = '⏸ PAUSE';
    document.getElementById('btnPlay').classList.add('playing');
    tick();
  }
}

function seqStop() {
  seqRunning = false;
  clearTimeout(stepTimer);
  currentStep = 0;
  stopAllNotes(true);
  document.getElementById('btnPlay').textContent = '▶ PLAY';
  document.getElementById('btnPlay').classList.remove('playing');
  clearStepHighlights();
}

function buildGrid() {
  const gridEl = document.getElementById('seqGrid');
  const headersEl = document.getElementById('stepHeaders');
  gridEl.innerHTML = '';
  headersEl.innerHTML = '';

  for (let s = 0; s < numSteps; s++) {
    const el = document.createElement('div');
    el.className = 'seq-step-num' + (s%4===0?' beat':'') + (s%4===0&&s>0?' beat-gap':'');
    el.textContent = s%4===0 ? String(s/4+1) : '·';
    headersEl.appendChild(el);
  }

  getViewNotes().forEach(midi => {
    const name = midiToName(midi), isSharp = name.includes('#'), isC = name.startsWith('C') && !isSharp;

    const row = document.createElement('div'); row.className = 'seq-row';
    const lbl = document.createElement('div');
    lbl.className = 'seq-row-label' + (isC?' is-c':'') + (isSharp?' is-sharp':'');
    lbl.textContent = isSharp ? '♯' : name;
    row.appendChild(lbl);

    const cells = document.createElement('div'); cells.className = 'seq-cells';
    let dragVal = null;

    for (let s = 0; s < numSteps; s++) {
      const cell = document.createElement('div');
      cell.className = 'seq-cell' + (s%4===0&&s>0?' beat-gap':'');
      cell.id = `c-${midi}-${s}`;
      if (cellOn(midi,s)) cell.classList.add('active');

      cell.addEventListener('mousedown', e => { e.preventDefault(); dragVal = !cellOn(midi,s); toggleCell(midi,s,dragVal); });
      cell.addEventListener('mouseenter', e => { if(e.buttons===1 && dragVal!==null) toggleCell(midi,s,dragVal); });

      cell.addEventListener('touchstart', e => {
        e.preventDefault();
        dragVal = !cellOn(midi,s);
        toggleCell(midi,s,dragVal);
      }, {passive:false});
      cell.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        const el = document.elementFromPoint(t.clientX, t.clientY);
        if (el && el.classList && el.classList.contains('seq-cell')) {
          const parts = el.id.split('-');
          if (parts.length === 3) {
            const mm = +parts[1], ss = +parts[2];
            toggleCell(mm, ss, dragVal);
          }
        }
      }, {passive:false});
      cell.addEventListener('touchend', () => { dragVal = null; }, {passive:true});

      cells.appendChild(cell);
    }

    window.addEventListener('mouseup', () => { dragVal = null; }, { passive: true });
    row.appendChild(cells);
    gridEl.appendChild(row);
  });

  document.getElementById('octLabel').textContent = midiToName(viewBase);
}

function refreshCell(midi, step) {
  const el = document.getElementById(`c-${midi}-${step}`);
  if (el) el.classList.toggle('active', cellOn(midi,step));
}

function scrollOctave(dir) {
  viewBase = Math.max(12, Math.min(72, viewBase + dir*12));
  buildGrid();
}

function setNumSteps(n) {
  numSteps = n;
  if (currentStep >= n) currentStep = 0;
  buildGrid();
}

function clearGrid() { getGrid().clear(); buildGrid(); }

function randomize() {
  getGrid().clear();
  const penta = [0,2,4,7,9];
  const notes = penta.map(i=>viewBase+i).concat(penta.map(i=>viewBase+12+i));
  for (let s=0;s<numSteps;s++) {
    if (Math.random()<0.38) {
      const midi = notes[Math.floor(Math.random()*notes.length)];
      const g = getGrid();
      if(!g.has(midi)) g.set(midi,new Array(MAX_STEPS).fill(false));
      g.get(midi)[s] = true;
    }
  }
  buildGrid();
}

function startBpmChange(d) { changeBpm(d); bpmInterval = setInterval(()=>changeBpm(d),100); }
function stopBpmChange() { clearInterval(bpmInterval); }
function changeBpm(d) {
  bpm = Math.max(20,Math.min(300,bpm+d));
  document.getElementById('bpmDisplay').textContent = bpm;
}
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('bpmDisplay').addEventListener('wheel', e => {
    e.preventDefault();
    changeBpm(e.deltaY<0?1:-1);
  }, {passive:false});
});

/* Param application */
function applyParam(param, val) {
  P[param] = val;
  if (param === 'engineIdx') DSP_PARAMS.engineIdx = val;
  else sendParam(param, val);

  if (junoFilter) {
    if (param === 'cutoff') junoFilter.setCutoff(val);
    if (param === 'resonance') {
      const res01 = clamp((val - 0.01) / (20 - 0.01), 0, 1);
      junoFilter.setResonance(res01);
    }
  }
  if (param === 'volume' && masterGain) masterGain.gain.value = val;
}

/* Slider UI init */
function initSliders() {
  document.querySelectorAll('.vslider-track').forEach(track => {
    const handle = track.querySelector('.vslider-handle');
    const param = track.dataset.param;
    const min = parseFloat(track.dataset.min);
    const max = parseFloat(track.dataset.max);
    const initVal = parseFloat(track.dataset.val);
    const H = 67;

    let pos = ((initVal-min)/(max-min))*H;
    handle.style.bottom = pos + 'px';
    applyParam(param, initVal);

    let dragging = false, startY = 0, startPos = pos;

    const moveTo = (clientY) => {
      pos = Math.max(0,Math.min(H, startPos+(startY-clientY)));
      handle.style.bottom = pos+'px';
      const val = min+(pos/H)*(max-min);
      applyParam(param, val);

      // keep quick bar synced for key params
      if(param==='cutoff') document.getElementById('quickCut').value = String(Math.round(val));
      if(param==='resonance') document.getElementById('quickRes').value = String(val);
      if(param==='filterEgDepth') document.getElementById('quickEg').value = String(val);
    };

    handle.addEventListener('mousedown', e => { dragging=true; startY=e.clientY; startPos=pos; e.preventDefault(); });
    window.addEventListener('mousemove', e => { if (!dragging) return; moveTo(e.clientY); });
    window.addEventListener('mouseup', () => { dragging=false; });

    handle.addEventListener('touchstart', e => { dragging=true; startY=e.touches[0].clientY; startPos=pos; e.preventDefault(); },{passive:false});
    window.addEventListener('touchmove', e => { if (!dragging) return; moveTo(e.touches[0].clientY); },{passive:false});
    window.addEventListener('touchend', ()=>{ dragging=false; });
  });
}

function initVolumeKnob() {
  const knob = document.getElementById('knob-vol');
  let val = parseFloat(knob.dataset.val || '0.7');
  let startY = null;
  const setRot = v => { knob.style.transform = `rotate(${-140+v*280}deg)`; };
  setRot(val);
  applyParam('volume', val);

  knob.addEventListener('mousedown', e => { startY=e.clientY; e.preventDefault(); });
  window.addEventListener('mousemove', e => {
    if (!e.buttons || startY===null) return;
    val = Math.max(0,Math.min(1,val+(startY-e.clientY)*0.006));
    startY=e.clientY; setRot(val);
    applyParam('volume', val);
  });
  window.addEventListener('mouseup', ()=>{ startY=null; });

  knob.addEventListener('touchstart', e => { startY=e.touches[0].clientY; e.preventDefault(); }, {passive:false});
  window.addEventListener('touchmove', e => {
    if (startY===null) return;
    const y = e.touches[0].clientY;
    val = Math.max(0,Math.min(1,val+(startY-y)*0.006));
    startY=y; setRot(val);
    applyParam('volume', val);
  }, {passive:false});
  window.addEventListener('touchend', ()=>{ startY=null; }, {passive:true});
}

/* Engine labels */
const ENGINE_LABELS = {
  0: { harm:'DET',  timb:'PW',    morph:'MIX' },
  1: { harm:'SHP',  timb:'FOLD',  morph:'ASYM' },
  2: { harm:'RAT',  timb:'IDX',   morph:'FDBK' },
  3: { harm:'FORM', timb:'SHP',   morph:'BLD' },
  4: { harm:'CENT', timb:'WID',   morph:'PEAK' },
  5: { harm:'BANK', timb:'POS',   morph:'DST' },
  6: { harm:'SPR',  timb:'PW',    morph:'XFADE' },
  7: { harm:'CHRD', timb:'PW',    morph:'DET' },
};

function setEngine(idx, el) {
  P.engineIdx = idx;
  DSP_PARAMS.engineIdx = idx;
  document.querySelectorAll('.eng-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');

  const d = el.dataset.desc || '';
  const ed = document.getElementById('engDesc');
  if (ed) ed.textContent = d;

  const lbl = ENGINE_LABELS[idx];
  if (lbl) {
    document.getElementById('lbl-harm').textContent = lbl.harm;
    document.getElementById('lbl-timb').textContent = lbl.timb;
    document.getElementById('lbl-morph').textContent = lbl.morph;
  }
  stopAllNotes(true);
}

function setFeet(feet, el) {
  P.octaveMult = {4:2, 8:1, 16:0.5, 32:0.25}[feet];
  document.querySelectorAll('[onclick*="setFeet"]').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  applyParam('octaveMult', P.octaveMult);
}

/* Toggles */
function toggleFxPanel() {
  const panel = document.getElementById('fxPanel');
  const btn = document.getElementById('btnFxPanel');
  const show = !panel.classList.contains('show');
  panel.classList.toggle('show', show);
  btn.textContent = show ? 'FX ▴' : 'FX ▾';
}
function togglePitchMod() {
  const sec = document.getElementById('pitchModSection');
  const btn = document.getElementById('btnPitchMod');
  const hidden = sec.classList.toggle('hidden');
  btn.textContent = hidden ? 'PITCH/MOD ▸' : 'PITCH/MOD ▾';
}
function toggleSection(id){
  const el = document.getElementById(id);
  if(!el) return;
  el.style.display = (el.style.display==='none') ? 'block' : 'none';
}

/* FX */
function toggleFx(type) {
  if (type==='tape') {
    FX.tapeOn = !FX.tapeOn;
    const btn = document.getElementById('tapeBypass');
    btn.textContent = FX.tapeOn ? 'ON' : 'OFF';
    btn.classList.toggle('active', FX.tapeOn);
  } else {
    FX.echoOn = !FX.echoOn;
    const btn = document.getElementById('echoBypass');
    btn.textContent = FX.echoOn ? 'ON' : 'OFF';
    btn.classList.toggle('active', FX.echoOn);
  }
  if (audioCtx) setFxStateFromFlags();
}
function fmtFxVal(p,v) {
  if (p==='tapeDrive') return v.toFixed(1);
  if (p==='tapeTone') return v>=1000 ? (v/1000).toFixed(1)+'k' : Math.round(v)+'Hz';
  if (['tapeWow','tapeMix','echoFeedback','echoMix','reverbMix'].includes(p)) return Math.round(v*100)+'%';
  if (p==='echoTime') return Math.round(v*1000)+'ms';
  if (p==='reverbSize') return v.toFixed(1)+'s';
  return v.toFixed(2);
}
function applyFxParam(p, v) {
  FX[p] = v;
  if (!audioCtx) return;
  switch(p) {
    case 'tapeDrive':
      tapeInputGain.gain.value=v;
      tapeWaveshaper.curve=makeSatCurve(v*8);
      break;
    case 'tapeTone':
      tapeToneFilter.frequency.value=v;
      break;
    case 'tapeWow':
      tapeWowGain.gain.value=v*5;
      break;
    case 'tapeMix':
      break;
    case 'echoTime':
      delayNode.delayTime.setTargetAtTime(v,audioCtx.currentTime,0.05);
      break;
    case 'echoFeedback':
      delayFeedGain.gain.value=v;
      break;
    case 'echoMix':
      break;
    case 'reverbSize':
      reverbNode.buffer=buildReverbIR(v);
      break;
    case 'reverbMix':
      break;
  }
  setFxStateFromFlags();
}
function initFxKnobs() {
  document.querySelectorAll('.fx-knob').forEach(knob => {
    const p = knob.dataset.param;
    const min = parseFloat(knob.dataset.min);
    const max = parseFloat(knob.dataset.max);
    let val = parseFloat(knob.dataset.val);
    const dot = knob.querySelector('.fx-knob-dot');
    const valEl = document.getElementById('val-'+p);
    let startY = null;

    const set = v => {
      val = Math.max(min,Math.min(max,v));
      const pct = (val-min)/(max-min);
      dot.style.transform = `translateX(-50%) rotate(${-140+pct*280}deg)`;
      if(valEl) valEl.textContent = fmtFxVal(p,val);
      applyFxParam(p,val);
    };
    set(val);

    knob.addEventListener('mousedown', e => { startY=e.clientY; e.preventDefault(); });
    window.addEventListener('mousemove', e => {
      if (!e.buttons || startY===null) return;
      set(val+(startY-e.clientY)*(max-min)/160);
      startY=e.clientY;
    });
    window.addEventListener('mouseup', ()=>{ startY=null; });

    knob.addEventListener('touchstart', e => { startY=e.touches[0].clientY; e.preventDefault(); }, {passive:false});
    window.addEventListener('touchmove', e => {
      if (startY===null) return;
      const y = e.touches[0].clientY;
      set(val+(startY-y)*(max-min)/160);
      startY=y;
    }, {passive:false});
    window.addEventListener('touchend', ()=>{ startY=null; }, {passive:true});

    knob.addEventListener('wheel', e => {
      e.preventDefault();
      set(val+(e.deltaY<0?1:-1)*(max-min)/40);
    },{passive:false});
  });
}

/* Ribbons wired */
function initRibbons() {
  const pitch = document.getElementById('pitchRibbon');
  const mod = document.getElementById('modRibbon');
  const pitchValEl = document.getElementById('pitchVal');
  const modValEl = document.getElementById('modVal');
  if(!pitch || !mod || !pitchValEl || !modValEl) return;

  const attach = (el, onVal) => {
    let dragging = false;
    const setFromY = (clientY) => {
      const r = el.getBoundingClientRect();
      const t = clamp(1 - (clientY - r.top) / r.height, 0, 1);
      const v = (t*2 - 1); // -1..+1
      onVal(v);
    };
    el.addEventListener('mousedown', e => { dragging=true; setFromY(e.clientY); e.preventDefault(); });
    window.addEventListener('mousemove', e => { if(!dragging) return; setFromY(e.clientY); });
    window.addEventListener('mouseup', ()=>{ dragging=false; });

    el.addEventListener('touchstart', e => { dragging=true; setFromY(e.touches[0].clientY); e.preventDefault(); }, {passive:false});
    window.addEventListener('touchmove', e => { if(!dragging) return; setFromY(e.touches[0].clientY); }, {passive:false});
    window.addEventListener('touchend', ()=>{ dragging=false; }, {passive:true});
  };

  attach(pitch, (v)=>{
    const semi = clamp(v, -1, 1) * 2;
    pitchBendSemi = semi;
    pitchValEl.textContent = semi.toFixed(2);
  });

  attach(mod, (v)=>{
    const a = clamp((v + 1) * 0.5, 0, 1);
    modAmt = a;
    modValEl.textContent = a.toFixed(2);
  });
}

/* Start overlay */
function hideStartOverlay() {
  const o = document.getElementById('startOverlay');
  if (o) o.style.display = 'none';
}
document.getElementById('startAudioBtn').addEventListener('click', async () => {
  await ensureAudioRunning();
  hideStartOverlay();
}, {passive:true});

/* INIT */
window.addEventListener('DOMContentLoaded', () => {
  setRowsForScreen();
  buildGrid();
  initSliders();
  initVolumeKnob();
  initFxKnobs();
  initRibbons();

  const lbl = ENGINE_LABELS[0];
  document.getElementById('lbl-harm').textContent = lbl.harm;
  document.getElementById('lbl-timb').textContent = lbl.timb;
  document.getElementById('lbl-morph').textContent = lbl.morph;

  document.getElementById('tapeBypass').classList.toggle('active', FX.tapeOn);
  document.getElementById('echoBypass').classList.toggle('active', FX.echoOn);

  // quick bar default sync
  document.getElementById('quickCut').value = String(P.cutoff);
  document.getElementById('quickRes').value = String(P.resonance);
  document.getElementById('quickEg').value = String(P.filterEgDepth);

  window.addEventListener('resize', () => {
    const before = NUM_ROWS;
    setRowsForScreen();
    if (before !== NUM_ROWS) buildGrid();
  }, {passive:true});
});
</script>

</body>
</html>
