<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<title>SamPtu 303 — LoFi Sampler</title>

<style>
:root{
  --bg:#0b0d12;
  --ink:#eef1f6;
  --muted:rgba(238,241,246,.68);
  --panel:#121621;
  --panel2:#0f1320;
  --line:rgba(255,255,255,.16);
  --line2:rgba(255,255,255,.10);
  --shadow:rgba(0,0,0,.55);

  --stepOff:rgba(255,255,255,.08);
  --playHead:rgba(255,255,255,.12);
  --danger:#ff4b4b;
}

body{ color-scheme: dark; }

.knob input[type="range"],
.sctl input[type="range"]{
  accent-color: #e6e9ef;
}

*{ box-sizing:border-box; }
html,body{ height:100%; }
body{
  margin:0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
  background:var(--bg);
  color:var(--ink);
}

.wrap{
  max-width:1160px;
  margin:0 auto;
  padding:16px 14px 22px;
  padding-bottom: calc(22px + env(safe-area-inset-bottom));
}

.panel{
  border:1px solid var(--line);
  background:linear-gradient(180deg, var(--panel), var(--panel2));
  border-radius:14px;
  box-shadow:0 10px 26px var(--shadow);
}

.topbar{
  display:flex;
  gap:12px;
  align-items:flex-start;
  justify-content:space-between;
  flex-wrap:wrap;
  margin-bottom:12px;
}
.title{
  display:flex;
  flex-direction:column;
  gap:4px;
  min-width:260px;
}
.title h1{
  margin:0;
  font-size:16px;
  letter-spacing:.08em;
  text-transform:uppercase;
}
.title .sub{
  font-size:12px;
  color:var(--muted);
  letter-spacing:.04em;
}

.subRow{
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}

.badge{
  border:1px solid var(--line);
  background:rgba(255,255,255,.05);
  color:var(--muted);
  padding:6px 10px;
  border-radius:999px;
  font-size:11px;
  font-weight:900;
  letter-spacing:.10em;
  text-transform:uppercase;
  user-select:none;
}

.badge.on{
  color:rgba(230,233,239,.95);
  border-color:rgba(80,160,255,.55);
  background:rgba(80,160,255,.16);
  box-shadow: 0 0 0 2px rgba(80,160,255,.10);
}

.controls{
  display:flex;
  align-items:center;
  gap:10px;
  padding:10px;
  flex-wrap:wrap;
}
.btn{
  border:1px solid var(--line);
  background:transparent;
  color:var(--ink);
  padding:10px 12px;
  border-radius:12px;
  font-weight:800;
  letter-spacing:.04em;
  text-transform:uppercase;
  font-size:12px;
  cursor:pointer;
  user-select:none;
  touch-action:manipulation;
}
.btn:active{ transform:translateY(1px); }
.btn.primary{ background:rgba(0,0,0,.06); }
.btn.danger{ border-color:rgba(192,24,24,.35); color:var(--danger); }
.btn.on{ background:rgba(0,0,0,.08); }

/* ✅ CORRECTION #2: style visible quand FX sont affichés */
.btn.fx-on{
  color: rgba(230,233,239,.95);
  border-color: rgba(80,160,255,.55);
  background: rgba(80,160,255,.16);
  box-shadow: 0 0 0 2px rgba(80,160,255,.10);
}

.led{
  display:flex;
  align-items:center;
  gap:10px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid var(--line);
  background:rgba(255,255,255,.35);
  min-height:42px;
}
.led .digits{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
  font-weight:900;
  letter-spacing:.12em;
  background:rgba(0,0,0,.06);
  border:1px solid var(--line2);
  padding:8px 10px;
  border-radius:10px;
  min-width:78px;
  text-align:center;
}
.led .label{
  font-size:12px;
  color:var(--muted);
  letter-spacing:.06em;
  text-transform:uppercase;
  white-space:nowrap;
}

.knobs{
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}
.knob{
  display:flex;
  flex-direction:column;
  gap:6px;
  padding:8px 10px;
  border:1px solid var(--line);
  border-radius:12px;
  background:rgba(255,255,255,.25);
  min-width:170px;
}
.knob label{
  font-size:11px;
  letter-spacing:.08em;
  text-transform:uppercase;
  color:var(--muted);
  display:flex;
  justify-content:space-between;
  gap:10px;
}
.knob input[type="range"]{ width:100%; accent-color:#111; }
.knob .val{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
  font-size:11px;
  color:var(--ink);
  opacity:.85;
}

.main{ padding:12px; }

/* --- TRACK ROWS (pad + steps aligned) --- */
.tracks{
  display:flex;
  flex-direction:column;
  gap:10px;
}

.track{
  --trk: rgba(0,0,0,.85); /* fallback */
  border:1px solid var(--line);
  border-radius:14px;
  background:rgba(255,255,255,.18);
  padding:10px;
}

.trackRow{
  display:grid;
  grid-template-columns: 300px 1fr;
  gap:10px;
  align-items:stretch;
}

.padBox{
  border:1px solid var(--line);
  border-radius:14px;
  background:rgba(255,255,255,.22);
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:8px;
  position:relative;
}
.padBox::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:14px;
  border:2px solid color-mix(in srgb, var(--trk) 55%, transparent);
  pointer-events:none;
  opacity:.65;
}

.padTop{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:10px;
}
.padMeta{
  display:flex;
  flex-direction:column;
  gap:4px;
}
.padType{
  font-size:11px;
  letter-spacing:.12em;
  text-transform:uppercase;
  color:var(--muted);
}
.padName{
  font-weight:900;
  letter-spacing:.08em;
  text-transform:uppercase;
  font-size:12px;
}
.pill{
  border:1px solid var(--line);
  border-radius:999px;
  padding:6px 8px;
  background:rgba(255,255,255,.22);
  white-space:nowrap;
  font-size:11px;
  letter-spacing:.06em;
  text-transform:uppercase;
  color:var(--muted);
}

.padBtn{
  width:100%;
  border:1px solid var(--line);
  background:transparent;
  border-radius:14px;
  padding:12px 10px;
  font-weight:900;
  letter-spacing:.08em;
  text-transform:uppercase;
  font-size:12px;
  cursor:pointer;
  user-select:none;
  touch-action:manipulation;
  position:relative;
}
.padBtn:active{ transform:translateY(1px); }
.padBtn.on{ background: color-mix(in srgb, var(--trk) 12%, transparent); }

.padBtn .small{
  display:block;
  font-size:11px;
  font-weight:800;
  letter-spacing:.04em;
  opacity:.75;
  margin-top:4px;
  text-transform:none;
}

.miniRow{
  display:flex;
  gap:8px;
  align-items:flex-start;
  flex-wrap:wrap;
}
.tinyBtn{
  border:1px solid var(--line);
  background:transparent;
  padding:8px 10px;
  border-radius:12px;
  font-size:11px;
  font-weight:900;
  letter-spacing:.06em;
  text-transform:uppercase;
  cursor:pointer;
  touch-action:manipulation;
}
.tinyBtn.on{ background:rgba(0,0,0,.08); }

.sctl{
  flex:1;
  min-width: 120px;
  border:1px solid var(--line);
  border-radius:12px;
  padding:8px 10px;
  background:rgba(255,255,255,.20);
}
.sctl .row{
  display:flex;
  justify-content:space-between;
  gap:10px;
  align-items:baseline;
  margin-bottom:6px;
}
.sctl .lab{
  font-size:11px;
  letter-spacing:.08em;
  text-transform:uppercase;
  color:var(--muted);
}
.sctl .v{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
  font-size:11px;
  color:var(--ink);
  opacity:.85;
}
.sctl input[type="range"]{
  width:100%;
  accent-color:#111;
  touch-action: pan-y;
}

.wave{
  width:100%;
  height:20px;
  border-radius:10px;
  border:1px solid var(--line2);
  background:rgba(0,0,0,.03);
  overflow:hidden;
}
canvas.waveform-canvas{
  width:100%;
  height:100%;
  display:block;
}

/* Steps */
.stepsWrap{
  border:1px solid var(--line);
  border-radius:14px;
  background:rgba(255,255,255,.18);
  padding:10px;
  display:flex;
  flex-direction:column;
  gap:8px;
}

.stepsHeader{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}
.trackLabel{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
  font-size:11px;
  color:var(--muted);
  letter-spacing:.04em;
}
.swatch{
  width:12px; height:12px;
  border-radius:4px;
  background: var(--trk);
  opacity:.85;
  border:1px solid rgba(0,0,0,.25);
}

.steps{
  display:grid;
  grid-template-columns: repeat(16, 1fr);
  gap:6px;
}
.step{
  height:34px;
  border-radius:10px;
  border:1px solid var(--line2);
  background:var(--stepOff);
  cursor:pointer;
  position:relative;
  touch-action:none;
  user-select:none;
}
.step.on{
  background: color-mix(in srgb, var(--trk) 90%, #000);
  border-color: color-mix(in srgb, var(--trk) 45%, rgba(0,0,0,.2));
}
.step.ph::after{
  content:"";
  position:absolute;
  inset:-2px;
  border-radius:12px;
  outline:2px solid color-mix(in srgb, var(--trk) 55%, rgba(0,0,0,.15));
  background:var(--playHead);
  pointer-events:none;
}
.step.beat::before{
  content:"";
  position:absolute;
  bottom:4px;
  left:50%;
  transform:translateX(-50%);
  width:4px; height:4px;
  border-radius:50%;
  background:rgba(0,0,0,.20);
}
.step.on.beat::before{ background:rgba(255,255,255,.35); }

/* FX panel */
.fxPanel{ margin-top:12px; overflow:hidden; }
.fxHeader{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  padding:10px;
  border-bottom:1px solid var(--line);
}
.fxHeader .sectionTitle{
  margin:0;
  font-size:11px;
  letter-spacing:.14em;
  text-transform:uppercase;
  color:var(--muted);
}
.fxBody{ padding:10px; display:none; }
.fxBody.open{ display:block; }

.fxGrid{
  display:grid;
  grid-template-columns: repeat(3, minmax(220px, 1fr));
  gap:10px;
}
.fxCard{
  border:1px solid var(--line);
  border-radius:14px;
  background:rgba(255,255,255,.20);
  padding:10px;
}
.fxCardTop{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  margin-bottom:10px;
}
.fxName{
  font-weight:900;
  letter-spacing:.08em;
  text-transform:uppercase;
  font-size:12px;
}
.fxSub{
  font-size:11px;
  color:var(--muted);
  letter-spacing:.04em;
}
.fxRow{
  display:flex;
  flex-direction:column;
  gap:6px;
  margin-top:8px;
}

/* Bottom */
.bottomBar{
  margin-top:12px;
  display:flex;
  justify-content:space-between;
  gap:10px;
  flex-wrap:wrap;
  padding:10px;
  border:1px solid var(--line);
  border-radius:14px;
  background:rgba(255,255,255,.18);
}
.patBtns{ display:flex; gap:6px; align-items:center; flex-wrap:wrap; }
.patLabel{ font-size:11px; color:var(--muted); letter-spacing:.08em; text-transform:uppercase; }
.patBtn{
  border:1px solid var(--line);
  background:transparent;
  padding:8px 10px;
  border-radius:12px;
  font-size:11px;
  font-weight:900;
  letter-spacing:.08em;
  text-transform:uppercase;
  cursor:pointer;
  touch-action:manipulation;
}
.patBtn.active{ background:rgba(0,0,0,.08); }

.sectionTitle{
  font-size:11px;
  letter-spacing:.14em;
  text-transform:uppercase;
  color:var(--muted);
  margin:0;
}

.loading-msg{
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.55);
  display:flex; align-items:center; justify-content:center;
  z-index: 9000;
  font-weight:900;
  letter-spacing:.14em;
  text-transform:uppercase;
  color:#fff;
  opacity: 0;
  pointer-events:none;
  transition: opacity 0.2s;
}
.loading-msg.show{ opacity:1; pointer-events:auto; }

@media (max-width: 980px){
  .trackRow{ grid-template-columns: 1fr; }
}
@media (max-width: 420px){
  .knob{ min-width: 150px; }
  .steps{ gap:5px; }
  .step{ height:28px; border-radius:9px; }
  .padBtn{ padding:11px 10px; }
  .sctl{ min-width: 110px; }
}
</style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>SamPtu 303 — LoFi Sampler · Drum Machine</h1>
        <div class="subRow">
          <span class="sub">1 track = 1 row · pad + controls aligned with sequencer · color-coded</span>
          <span id="fxBadge" class="badge">FX Hidden</span>
        </div>
      </div>

      <div class="panel controls" aria-label="Transport">
        <button id="btnPlay" class="btn primary">Play</button>
        <button id="btnStop" class="btn">Stop</button>
        <button id="btnClear" class="btn danger">Clear</button>

        <div class="led" title="Position">
          <div class="digits" id="ledDisplay">---</div>
          <div class="label">Step</div>
        </div>

        <button id="tsToggleBtn" class="btn on" title="Pitch sans changer la durée (time-stretch)">Time-Stretch</button>

        <div class="knobs">
          <div class="knob">
            <label><span>BPM</span><span class="val" id="bpmVal">120</span></label>
            <input id="bpm" type="range" min="40" max="280" value="120" />
          </div>
          <div class="knob">
            <label><span>Master</span><span class="val" id="masterVal">0.75</span></label>
            <input id="master" type="range" min="0" max="1" step="0.01" value="0.75" />
          </div>
          <div class="knob">
            <label><span>Filter</span><span class="val" id="filterVal">18.0k</span></label>
            <input id="filter" type="range" min="200" max="18000" step="1" value="18000" />
          </div>
          <div class="knob">
            <label><span>Swing</span><span class="val" id="swingValDisplay">50%</span></label>
            <input id="swingRange" type="range" min="0" max="100" value="50" />
          </div>
        </div>

        <button id="fxToggleBtn" class="btn" aria-expanded="false">FX</button>
      </div>
    </div>

    <div class="panel main">
      <div style="display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:10px;">
        <p class="sectionTitle">Tracks</p>
        <div style="font-size:11px; color:var(--muted); letter-spacing:.04em;">
          Tap steps · drag paint (touch OK) · Space = play/pause
        </div>
      </div>

      <div id="tracks" class="tracks"></div>

      <div class="panel fxPanel">
        <div class="fxHeader">
          <p class="sectionTitle">Global FX</p>
          <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            <span style="font-size:11px; color:var(--muted); letter-spacing:.06em; text-transform:uppercase;">Off by default</span>
            <button id="fxAllBypassBtn" class="btn">Bypass</button>
          </div>
        </div>

        <div id="fxBody" class="fxBody">
          <div class="fxGrid">
            <div class="fxCard">
              <div class="fxCardTop">
                <div>
                  <div class="fxName">LOFI</div>
                  <div class="fxSub">MPC60-ish bitcrush + SR</div>
                </div>
                <button id="lofi-bypass" class="btn">Off</button>
              </div>
              <div class="fxRow knob">
                <label><span>Bits</span><span class="val" id="bitsVal">12</span></label>
                <input id="bits" type="range" min="4" max="16" step="1" value="12" />
              </div>
              <div class="fxRow knob">
                <label><span>Sample Rate</span><span class="val" id="srateVal">26000</span></label>
                <input id="srate" type="range" min="4000" max="44100" step="100" value="26000" />
              </div>
              <div class="fxRow knob">
                <label><span>Mix</span><span class="val" id="lofimixVal">0.50</span></label>
                <input id="lofimix" type="range" min="0" max="1" step="0.01" value="0.50" />
              </div>
            </div>

            <div class="fxCard">
              <div class="fxCardTop">
                <div>
                  <div class="fxName">Tape</div>
                  <div class="fxSub">Saturation + wow</div>
                </div>
                <button id="tape-bypass" class="btn">Off</button>
              </div>
              <div class="fxRow knob">
                <label><span>Drive</span><span class="val" id="tapedriveVal">3</span></label>
                <input id="tapedrive" type="range" min="1" max="20" step="0.1" value="3" />
              </div>
              <div class="fxRow knob">
                <label><span>Wow</span><span class="val" id="tapewowVal">0.15</span></label>
                <input id="tapewow" type="range" min="0" max="1" step="0.01" value="0.15" />
              </div>
              <div class="fxRow knob">
                <label><span>Mix</span><span class="val" id="tapemixVal">0.45</span></label>
                <input id="tapemix" type="range" min="0" max="1" step="0.01" value="0.45" />
              </div>
            </div>

            <div class="fxCard">
              <div class="fxCardTop">
                <div>
                  <div class="fxName">Vinyl</div>
                  <div class="fxSub">Crackle + warp (wow+flutter)</div>
                </div>
                <button id="vinyl-bypass" class="btn">Off</button>
              </div>
              <div class="fxRow knob">
                <label><span>Crackle</span><span class="val" id="vinylcrackleVal">0.25</span></label>
                <input id="vinylcrackle" type="range" min="0" max="1" step="0.01" value="0.25" />
              </div>
              <div class="fxRow knob">
                <label><span>Warp</span><span class="val" id="vinylwarpVal">0.20</span></label>
                <input id="vinylwarp" type="range" min="0" max="1" step="0.01" value="0.20" />
              </div>
              <div class="fxRow knob">
                <label><span>Mix</span><span class="val" id="vinylmixVal">0.40</span></label>
                <input id="vinylmix" type="range" min="0" max="1" step="0.01" value="0.40" />
              </div>
            </div>
          </div>

          <div style="margin-top:10px; color:var(--muted); font-size:12px; line-height:1.35;">
            Les FX sont globales. Active un FX via son bouton <strong>On</strong>, ou utilise <strong>Bypass</strong> pour tout couper.
          </div>
        </div>
      </div>

      <div class="bottomBar">
        <div class="patBtns">
          <span class="patLabel">Bank</span>
          <button class="patBtn active" data-pat="0">A</button>
          <button class="patBtn" data-pat="1">B</button>
          <button class="patBtn" data-pat="2">C</button>
          <button class="patBtn" data-pat="3">D</button>
        </div>
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <button id="btnRand" class="btn">Rand</button>
          <button id="btnFill" class="btn">Fill</button>
        </div>
      </div>
    </div>
  </div>

  <div class="loading-msg" id="loadingMsg">Loading sample…</div>

<script>
/* =========================================================================
   CONFIG
   ========================================================================= */
const NUM_PADS = 6;
const NUM_STEPS = 16;
const MAX_PATTERNS = 4;

const PAD_CONFIG = [
  { id: 0, type: 'sample', label: 'SMPL 1', name: 'SAMPLE A', color: '#2a7bd6' },
  { id: 1, type: 'sample', label: 'SMPL 2', name: 'SAMPLE B', color: '#7a5cff' },
  { id: 2, type: 'sample', label: 'SMPL 3', name: 'SAMPLE C', color: '#00a3a3' },
  { id: 3, type: 'drum',   label: 'KICK',   name: 'BD 808',   drumType: 0, color: '#d12b2b' },
  { id: 4, type: 'drum',   label: 'SNARE',  name: 'SD 808',   drumType: 1, color: '#1a6fe3' },
  { id: 5, type: 'drum',   label: 'HI-HAT', name: 'HH 808',   drumType: 2, color: '#12a150' },
];

/* =========================================================================
   PER-SAMPLE PARAMS
   ========================================================================= */
const SAMPLE_PARAMS = [
  { vol: 0.90, semi: 0 },
  { vol: 0.90, semi: 0 },
  { vol: 0.90, semi: 0 },
];
function semiToRate(semi){ return Math.pow(2, semi / 12); }

/* =========================================================================
   TIME-STRETCH PITCH (Jungle)
   ========================================================================= */
class Jungle {
  constructor(context) {
    this.context = context;
    this.input = context.createGain();
    this.output = context.createGain();

    this.delay1 = context.createDelay();
    this.delay2 = context.createDelay();
    this.gain1 = context.createGain();
    this.gain2 = context.createGain();

    this.mod1 = context.createBufferSource();
    this.mod2 = context.createBufferSource();
    this.modGain1 = context.createGain();
    this.modGain2 = context.createGain();

    this.windowTime = 0.1;
    this.delayTime = 0.1;

    this.delay1.delayTime.value = this.delayTime;
    this.delay2.delayTime.value = this.delayTime;

    const fadeBuffer = Jungle._createFadeBuffer(context, this.windowTime);
    const shiftBuffer = Jungle._createShiftBuffer(context, this.windowTime);

    this.mod1.buffer = shiftBuffer;
    this.mod2.buffer = shiftBuffer;
    this.mod1.loop = true;
    this.mod2.loop = true;

    this.modGain1.gain.value = 0.0;
    this.modGain2.gain.value = 0.0;

    this.mod1.connect(this.modGain1);
    this.mod2.connect(this.modGain2);
    this.modGain1.connect(this.delay1.delayTime);
    this.modGain2.connect(this.delay2.delayTime);

    this.fade1 = context.createBufferSource();
    this.fade2 = context.createBufferSource();
    this.fadeGain1 = context.createGain();
    this.fadeGain2 = context.createGain();

    this.fade1.buffer = fadeBuffer;
    this.fade2.buffer = fadeBuffer;
    this.fade1.loop = true;
    this.fade2.loop = true;

    this.input.connect(this.delay1);
    this.input.connect(this.delay2);
    this.delay1.connect(this.gain1);
    this.delay2.connect(this.gain2);
    this.gain1.connect(this.output);
    this.gain2.connect(this.output);

    this.fade1.connect(this.fadeGain1.gain);
    this.fade2.connect(this.fadeGain2.gain);
    this.fadeGain1.connect(this.gain1.gain);
    this.fadeGain2.connect(this.gain2.gain);

    this.mod1.start(0);
    this.mod2.start(0, this.windowTime / 2);
    this.fade1.start(0);
    this.fade2.start(0, this.windowTime / 2);

    this.setPitchOffset(1.0);
  }

  static _createFadeBuffer(context, windowTime) {
    const length = Math.floor(windowTime * context.sampleRate);
    const buffer = context.createBuffer(1, length, context.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < length; i++) data[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (length - 1)));
    return buffer;
  }

  static _createShiftBuffer(context, windowTime) {
    const length = Math.floor(windowTime * context.sampleRate);
    const buffer = context.createBuffer(1, length, context.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < length; i++) data[i] = i / (length - 1);
    return buffer;
  }

  setPitchOffset(pitch) {
    const maxDelay = this.windowTime;
    const shift = (pitch - 1);
    const depth = Math.min(maxDelay * 0.95, Math.abs(shift) * maxDelay * 1.2);
    const sign = shift >= 0 ? -1 : 1;
    this.modGain1.gain.value = sign * depth;
    this.modGain2.gain.value = sign * depth;
    this.delay1.delayTime.value = this.delayTime;
    this.delay2.delayTime.value = this.delayTime;
  }
}

/* =========================================================================
   AUDIO ENGINE
   ========================================================================= */
let audioCtx = null;
let masterGain, filterNode, masterOut;

let lofiScriptNode, tapeWaveshaper, tapeInputGain, tapeDryGain, tapeWetGain;
let tapeWowOsc, tapeWowGain, tapeToneFilter;

// Vinyl (realistic): crackle + wow+flutter => micro-delay modulation (NOT gain)
let vinylCrackleNode, vinylCrackleGain;
let vinylWowOsc, vinylWowGain;
let vinylFlutterOsc, vinylFlutterGain;
let vinylWarpDelay;
let vinylDryGain, vinylWetGain;

const FX = {
  lofiOn: false, tapeOn: false, vinylOn: false,
  bits: 12, srate: 26000, lofimix: 0.5,
  tapedrive: 3, tapewow: 0.15, tapemix: 0.45,
  vinylcrackle: 0.25, vinylwarp: 0.2, vinylmix: 0.4,
};

const sampleBuffers = [null, null, null];
let TIME_STRETCH_ON = true;
const jungleNodes = [null, null, null];

function makeSatCurve(drive) {
  const n = 512, curve = new Float32Array(n);
  for (let i = 0; i < n; i++) {
    const x = (i * 2) / n - 1;
    curve[i] = (Math.PI + drive) * x / (Math.PI + drive * Math.abs(x));
  }
  return curve;
}

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sr = audioCtx.sampleRate;

  masterGain = audioCtx.createGain();
  masterGain.gain.value = +document.getElementById('master').value;

  filterNode = audioCtx.createBiquadFilter();
  filterNode.type = 'lowpass';
  filterNode.frequency.value = +document.getElementById('filter').value;
  filterNode.Q.value = 0.5;

  masterOut = audioCtx.createGain();
  masterOut.gain.value = 0.85;

  // --- LOFI (ScriptProcessor) ---
  lofiScriptNode = audioCtx.createScriptProcessor(512, 1, 1);
  lofiScriptNode.onaudioprocess = (e) => {
    const inp = e.inputBuffer.getChannelData(0);
    const out = e.outputBuffer.getChannelData(0);
    if (!FX.lofiOn) { out.set(inp); return; }

    const bits = FX.bits;
    const srateFactor = Math.max(1, Math.floor(sr / FX.srate));
    const levels = Math.pow(2, bits);
    const mix = FX.lofimix;
    let held = 0;

    for (let i = 0; i < inp.length; i++) {
      if (i % srateFactor === 0) held = inp[i];
      const crushed = Math.round(held * levels) / levels;
      out[i] = inp[i] * (1 - mix) + crushed * mix;
    }
  };

  // --- TAPE ---
  tapeInputGain = audioCtx.createGain();
  tapeWaveshaper = audioCtx.createWaveShaper();
  tapeWaveshaper.oversample = '4x';
  tapeToneFilter = audioCtx.createBiquadFilter();
  tapeToneFilter.type = 'lowpass';
  tapeToneFilter.frequency.value = 5000;

  tapeWowOsc = audioCtx.createOscillator();
  tapeWowOsc.frequency.value = 0.7;
  tapeWowOsc.type = 'sine';

  tapeWowGain = audioCtx.createGain();
  tapeWowOsc.connect(tapeWowGain);
  tapeWowGain.connect(tapeToneFilter.frequency);
  tapeWowOsc.start();

  tapeDryGain = audioCtx.createGain();
  tapeWetGain = audioCtx.createGain();

  // --- VINYL: crackle source ---
  const crackleBuffer = audioCtx.createBuffer(1, sr * 2, sr);
  const cbd = crackleBuffer.getChannelData(0);
  for (let i = 0; i < cbd.length; i++) {
    cbd[i] = Math.random() < 0.002 ? (Math.random() * 2 - 1) * 0.8 : (Math.random() * 2 - 1) * 0.003;
  }
  vinylCrackleNode = audioCtx.createBufferSource();
  vinylCrackleNode.buffer = crackleBuffer;
  vinylCrackleNode.loop = true;

  vinylCrackleGain = audioCtx.createGain();
  vinylCrackleGain.gain.value = 0; // OFF by default
  vinylCrackleNode.connect(vinylCrackleGain);

  // --- VINYL: wow + flutter -> micro delay time modulation ---
  vinylWarpDelay = audioCtx.createDelay(0.05);   // max 50ms
  vinylWarpDelay.delayTime.value = 0.0075;       // base ~7.5ms

  vinylWowOsc = audioCtx.createOscillator();
  vinylWowOsc.type = 'sine';
  vinylWowOsc.frequency.value = 0.35;

  vinylWowGain = audioCtx.createGain();
  vinylWowGain.gain.value = 0;
  vinylWowOsc.connect(vinylWowGain);

  vinylFlutterOsc = audioCtx.createOscillator();
  vinylFlutterOsc.type = 'sine';
  vinylFlutterOsc.frequency.value = 6.0;

  vinylFlutterGain = audioCtx.createGain();
  vinylFlutterGain.gain.value = 0;
  vinylFlutterOsc.connect(vinylFlutterGain);

  vinylWowGain.connect(vinylWarpDelay.delayTime);
  vinylFlutterGain.connect(vinylWarpDelay.delayTime);

  vinylWowOsc.start();
  vinylFlutterOsc.start();

  vinylDryGain = audioCtx.createGain();
  vinylWetGain = audioCtx.createGain();

  // --- ROUTING ---
  const tapeOut = audioCtx.createGain();
  tapeOut.gain.value = 0.7;

  masterGain.connect(filterNode);
  filterNode.connect(lofiScriptNode);

  lofiScriptNode.connect(tapeDryGain);
  lofiScriptNode.connect(tapeInputGain);
  tapeInputGain.connect(tapeWaveshaper);
  tapeWaveshaper.connect(tapeToneFilter);
  tapeToneFilter.connect(tapeWetGain);

  tapeDryGain.connect(tapeOut);
  tapeWetGain.connect(tapeOut);

  // Vinyl mix stage
  const vinylOut = audioCtx.createGain();
  tapeOut.connect(vinylDryGain);
  tapeOut.connect(vinylWetGain);

  vinylDryGain.connect(vinylOut);
  vinylWetGain.connect(vinylWarpDelay);
  vinylWarpDelay.connect(vinylOut);

  vinylCrackleGain.connect(vinylOut);

  vinylOut.connect(masterOut);
  masterOut.connect(audioCtx.destination);

  vinylCrackleNode.start();

  for (let i = 0; i < 3; i++) jungleNodes[i] = new Jungle(audioCtx);
  updateFxGains();
}

function updateFxGains() {
  if (!tapeDryGain) return;

  // TAPE
  if (FX.tapeOn) { tapeDryGain.gain.value = 1 - FX.tapemix; tapeWetGain.gain.value = FX.tapemix; }
  else { tapeDryGain.gain.value = 1; tapeWetGain.gain.value = 0; }

  tapeInputGain.gain.value = FX.tapedrive;
  tapeWaveshaper.curve = makeSatCurve(FX.tapedrive * 6);
  tapeWowGain.gain.value = FX.tapewow * 300;

  // VINYL (realistic)
  if (FX.vinylOn) {
    vinylDryGain.gain.value = 1 - FX.vinylmix;
    vinylWetGain.gain.value = FX.vinylmix;

    const w = Math.max(0, Math.min(1, FX.vinylwarp));
    const warp = Math.pow(w, 1.2);

    vinylWowGain.gain.value = warp * 0.0022;
    vinylFlutterGain.gain.value = warp * 0.00035;

    if (vinylCrackleGain) vinylCrackleGain.gain.value = FX.vinylcrackle * 0.04;
  } else {
    vinylDryGain.gain.value = 1;
    vinylWetGain.gain.value = 0;
    if (vinylCrackleGain) vinylCrackleGain.gain.value = 0;

    vinylWowGain.gain.value = 0;
    vinylFlutterGain.gain.value = 0;
  }
}

/* =========================================================================
   DRUMS
   ========================================================================= */
function playKick808(time) {
  const ac = audioCtx;
  const osc = ac.createOscillator(); osc.type = 'sine';
  osc.frequency.setValueAtTime(160, time);
  osc.frequency.exponentialRampToValueAtTime(40, time + 0.08);
  const env = ac.createGain();
  env.gain.setValueAtTime(1.0, time);
  env.gain.exponentialRampToValueAtTime(0.001, time + 0.55);

  const clickBuf = ac.createBuffer(1, Math.floor(ac.sampleRate * 0.003), ac.sampleRate);
  const cd = clickBuf.getChannelData(0);
  for (let i = 0; i < cd.length; i++) cd[i] = (Math.random() * 2 - 1) * (1 - i / cd.length);
  const click = ac.createBufferSource(); click.buffer = clickBuf;
  const clickEnv = ac.createGain(); clickEnv.gain.value = 0.4;
  click.connect(clickEnv); clickEnv.connect(masterGain);
  click.start(time);

  osc.connect(env); env.connect(masterGain);
  osc.start(time); osc.stop(time + 0.6);
}
function playSnare808(time) {
  const ac = audioCtx;
  const osc = ac.createOscillator(); osc.type = 'triangle';
  osc.frequency.setValueAtTime(180, time);
  osc.frequency.exponentialRampToValueAtTime(80, time + 0.1);
  const toneEnv = ac.createGain();
  toneEnv.gain.setValueAtTime(0.6, time);
  toneEnv.gain.exponentialRampToValueAtTime(0.001, time + 0.2);

  const noiseLen = Math.floor(ac.sampleRate * 0.25);
  const noiseBuf = ac.createBuffer(1, noiseLen, ac.sampleRate);
  const nd = noiseBuf.getChannelData(0);
  for (let i = 0; i < noiseLen; i++) nd[i] = Math.random() * 2 - 1;
  const noise = ac.createBufferSource(); noise.buffer = noiseBuf;
  const noiseFilter = ac.createBiquadFilter(); noiseFilter.type = 'bandpass'; noiseFilter.frequency.value = 4000; noiseFilter.Q.value = 0.8;
  const noiseEnv = ac.createGain();
  noiseEnv.gain.setValueAtTime(0.7, time);
  noiseEnv.gain.exponentialRampToValueAtTime(0.001, time + 0.18);

  osc.connect(toneEnv); toneEnv.connect(masterGain);
  noise.connect(noiseFilter); noiseFilter.connect(noiseEnv); noiseEnv.connect(masterGain);
  osc.start(time); osc.stop(time + 0.25);
  noise.start(time);
}
function playHihat808(time, open = false) {
  const ac = audioCtx;
  const dur = open ? 0.35 : 0.08;
  const noiseLen = Math.floor(ac.sampleRate * (open ? 0.4 : 0.1));
  const noiseBuf = ac.createBuffer(1, noiseLen, ac.sampleRate);
  const nd = noiseBuf.getChannelData(0);
  for (let i = 0; i < noiseLen; i++) nd[i] = Math.random() * 2 - 1;
  const noise = ac.createBufferSource(); noise.buffer = noiseBuf;
  const hpf = ac.createBiquadFilter(); hpf.type = 'highpass'; hpf.frequency.value = 7000;
  const bpf = ac.createBiquadFilter(); bpf.type = 'bandpass'; bpf.frequency.value = 10000; bpf.Q.value = 1.2;
  const env = ac.createGain();
  env.gain.setValueAtTime(0.45, time);
  env.gain.exponentialRampToValueAtTime(0.001, time + dur);
  noise.connect(hpf); hpf.connect(bpf); bpf.connect(env); env.connect(masterGain);
  noise.start(time);
}
function playDrum(drumType, time) {
  if (drumType === 0) playKick808(time);
  else if (drumType === 1) playSnare808(time);
  else if (drumType === 2) playHihat808(time);
}

/* =========================================================================
   SAMPLES
   ========================================================================= */
function playSample(padIdx, time) {
  const buf = sampleBuffers[padIdx];
  if (!buf) return;

  const p = SAMPLE_PARAMS[padIdx] || { vol: 1, semi: 0 };
  const t = time || audioCtx.currentTime;

  const src = audioCtx.createBufferSource();
  src.buffer = buf;

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(p.vol, t);

  if (TIME_STRETCH_ON) {
    src.playbackRate.setValueAtTime(1.0, t);
    const j = jungleNodes[padIdx];
    if (j) j.setPitchOffset(semiToRate(p.semi));

    src.connect(j.input);
    j.output.connect(g);
    g.connect(masterGain);

    const stopAt = t + buf.duration + 0.2;
    src.start(t);
    src.stop(stopAt);
    src.onended = () => {
      try { src.disconnect(); } catch {}
      try { j.output.disconnect(g); } catch {}
      try { g.disconnect(); } catch {}
    };
  } else {
    src.playbackRate.setValueAtTime(semiToRate(p.semi), t);
    src.connect(g).connect(masterGain);
    src.start(t);
  }
}

function setDisplay(txt) {
  document.getElementById('ledDisplay').textContent = String(txt).padStart(3, ' ');
}

async function loadSampleFile(file, padIdx) {
  document.getElementById('loadingMsg').classList.add('show');
  try {
    initAudio();
    if (audioCtx.state !== "running") await audioCtx.resume();
    const arrayBuf = await file.arrayBuffer();
    const decoded = await audioCtx.decodeAudioData(arrayBuf);
    sampleBuffers[padIdx] = decoded;
    drawWaveform(padIdx, decoded);

    const label = document.querySelector(`[data-sample-label="${padIdx}"]`);
    if (label) label.textContent = file.name.length > 26 ? file.name.slice(0,26) + "…" : file.name;

    setDisplay(file.name.substring(0, 6).toUpperCase());
  } catch(e) { console.error('Sample load error:', e); }
  document.getElementById('loadingMsg').classList.remove('show');
}

function drawWaveform(padIdx, buffer) {
  const canvas = document.getElementById(`waveform-${padIdx}`);
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0, 0, w, h);

  const data = buffer.getChannelData(0);
  const step = Math.max(1, Math.floor(data.length / w));

  ctx.strokeStyle = "rgba(0,0,0,.55)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x = 0; x < w; x++) {
    let max = 0;
    for (let j = 0; j < step; j++) max = Math.max(max, Math.abs(data[x * step + j] || 0));
    const y = (1 - max) * h / 2;
    x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  }
  ctx.stroke();
}

/* =========================================================================
   SEQUENCER
   ========================================================================= */
let bpm = 120, swing = 0.5;
let seqRunning = false, currentStep = 0, stepTimer = null;
let currentPatIdx = 0;

const patterns = Array.from({length: MAX_PATTERNS}, () =>
  Array.from({length: NUM_PADS}, () => new Array(NUM_STEPS).fill(false))
);

function getPattern(){ return patterns[currentPatIdx]; }
function cellOn(pad, step){ return getPattern()[pad][step]; }

function refreshCell(pad, step) {
  const el = document.getElementById(`step-${pad}-${step}`);
  if (!el) return;
  el.classList.toggle('on', cellOn(pad, step));
}

function refreshAllCells(){
  for (let p=0;p<NUM_PADS;p++) for (let s=0;s<NUM_STEPS;s++) refreshCell(p,s);
}

function clearHighlights() {
  document.querySelectorAll('.step.ph').forEach(s => s.classList.remove('ph'));
}

function highlightStep(s) {
  for (let p = 0; p < NUM_PADS; p++) {
    const el = document.getElementById(`step-${p}-${s}`);
    if (el) el.classList.add('ph');
  }
}

function flashPad(padIdx) {
  const el = document.getElementById(`padbtn-${padIdx}`);
  if (!el) return;
  el.classList.add('on');
  setTimeout(() => el.classList.remove('on'), 90);
}

function toggleCell(pad, step) {
  getPattern()[pad][step] = !getPattern()[pad][step];
  refreshCell(pad, step);
}

function tick() {
  if (!seqRunning) return;

  clearHighlights();
  highlightStep(currentStep);
  setDisplay(String(currentStep + 1).padStart(3, '0'));

  const now = audioCtx.currentTime;
  for (let pad = 0; pad < NUM_PADS; pad++) {
    if (!getPattern()[pad][currentStep]) continue;
    const cfg = PAD_CONFIG[pad];
    if (cfg.type === 'drum') playDrum(cfg.drumType, now);
    else playSample(pad, now);
    flashPad(pad);
  }

  const s16 = 60000 / bpm / 4;
  const swingAmt = (swing - 0.5) * 0.5;
  const delay = currentStep % 2 === 0 ? s16 * (1 + swingAmt) : s16 * (1 - swingAmt);

  currentStep = (currentStep + 1) % NUM_STEPS;
  stepTimer = setTimeout(tick, delay);
}

function seqToggle() {
  initAudio();
  if (audioCtx.state !== "running") audioCtx.resume();

  if (seqRunning) {
    seqRunning = false;
    clearTimeout(stepTimer);
    document.getElementById('btnPlay').textContent = 'Play';
    document.getElementById('btnPlay').classList.remove('on');
    clearHighlights();
    setDisplay('---');
  } else {
    seqRunning = true;
    currentStep = 0;
    document.getElementById('btnPlay').textContent = 'Pause';
    document.getElementById('btnPlay').classList.add('on');
    tick();
  }
}

function seqStop() {
  seqRunning = false;
  clearTimeout(stepTimer);
  currentStep = 0;
  document.getElementById('btnPlay').textContent = 'Play';
  document.getElementById('btnPlay').classList.remove('on');
  clearHighlights();
  setDisplay('---');
}

/* =========================================================================
   PATTERNS
   ========================================================================= */
function loadPattern(idx) {
  currentPatIdx = idx;
  document.querySelectorAll('.patBtn').forEach(b => b.classList.toggle('active', +b.dataset.pat === idx));
  refreshAllCells();
}

function clearPattern() {
  for (let p=0;p<NUM_PADS;p++) getPattern()[p].fill(false);
  refreshAllCells();
}

function randomize() {
  clearPattern();
  [0,4,8,12].forEach(s => { if (Math.random() > 0.25) getPattern()[3][s] = true; });
  [2,6,10,14].forEach(s => { if (Math.random() > 0.7) getPattern()[3][s] = true; });
  [4,12].forEach(s => { getPattern()[4][s] = true; });
  [2,6,10,14].forEach(s => { if (Math.random() > 0.75) getPattern()[4][s] = true; });
  for (let s=0;s<16;s++){
    if (s % 2 === 0 || Math.random() > 0.55) getPattern()[5][s] = true;
  }
  for (let p=0;p<3;p++){
    for (let s=0;s<16;s++){
      if (Math.random() > 0.82) getPattern()[p][s] = true;
    }
  }
  refreshAllCells();
}

function fillKick() {
  for (let s=0;s<16;s+=4) getPattern()[3][s] = true;
  refreshAllCells();
}

/* =========================================================================
   FX UI
   ========================================================================= */
let fxAllBypass = false;
function setFxButtonState(id, on){
  const b = document.getElementById(id);
  if (!b) return;
  b.textContent = on ? "On" : "Off";
  b.classList.toggle("on", on);
}

function setFxUiOpen(isOpen){
  const btn = document.getElementById('fxToggleBtn');
  const body = document.getElementById('fxBody');
  const badge = document.getElementById('fxBadge');
  if (!btn || !body) return;

  body.classList.toggle('open', isOpen);

  btn.classList.toggle('on', isOpen);
  btn.classList.toggle('fx-on', isOpen);
  btn.setAttribute('aria-expanded', String(isOpen));
  btn.textContent = isOpen ? 'FX On-Screen' : 'FX';

  if (badge){
    badge.classList.toggle('on', isOpen);
    badge.textContent = isOpen ? 'FX Shown' : 'FX Hidden';
  }
}

function applyFxFromUI(){
  FX.bits = +document.getElementById('bits').value;
  FX.srate = +document.getElementById('srate').value;
  FX.lofimix = +document.getElementById('lofimix').value;

  FX.tapedrive = +document.getElementById('tapedrive').value;
  FX.tapewow = +document.getElementById('tapewow').value;
  FX.tapemix = +document.getElementById('tapemix').value;

  FX.vinylcrackle = +document.getElementById('vinylcrackle').value;
  FX.vinylwarp = +document.getElementById('vinylwarp').value;
  FX.vinylmix = +document.getElementById('vinylmix').value;

  document.getElementById('bitsVal').textContent = FX.bits.toFixed(0);
  document.getElementById('srateVal').textContent = FX.srate.toFixed(0);
  document.getElementById('lofimixVal').textContent = FX.lofimix.toFixed(2);

  document.getElementById('tapedriveVal').textContent = FX.tapedrive.toFixed(1);
  document.getElementById('tapewowVal').textContent = FX.tapewow.toFixed(2);
  document.getElementById('tapemixVal').textContent = FX.tapemix.toFixed(2);

  document.getElementById('vinylcrackleVal').textContent = FX.vinylcrackle.toFixed(2);
  document.getElementById('vinylwarpVal').textContent = FX.vinylwarp.toFixed(2);
  document.getElementById('vinylmixVal').textContent = FX.vinylmix.toFixed(2);

  if (audioCtx) updateFxGains();
}
function toggleFx(type){
  if (type === 'lofi') FX.lofiOn = !FX.lofiOn;
  if (type === 'tape') FX.tapeOn = !FX.tapeOn;
  if (type === 'vinyl') FX.vinylOn = !FX.vinylOn;

  if (fxAllBypass){
    setFxButtonState('lofi-bypass', false);
    setFxButtonState('tape-bypass', false);
    setFxButtonState('vinyl-bypass', false);
    if (audioCtx) updateFxGains();
    return;
  }
  setFxButtonState('lofi-bypass', FX.lofiOn);
  setFxButtonState('tape-bypass', FX.tapeOn);
  setFxButtonState('vinyl-bypass', FX.vinylOn);
  if (audioCtx) updateFxGains();
}

/* =========================================================================
   BUILD TRACK UI (pad + steps aligned)
   ========================================================================= */
function buildTracks(){
  const root = document.getElementById('tracks');
  root.innerHTML = '';

  PAD_CONFIG.forEach((cfg, padIdx) => {
    const track = document.createElement('div');
    track.className = 'track';
    track.style.setProperty('--trk', cfg.color);

    const row = document.createElement('div');
    row.className = 'trackRow';

    const padBox = document.createElement('div');
    padBox.className = 'padBox';

    const padTop = document.createElement('div');
    padTop.className = 'padTop';
    const meta = document.createElement('div');
    meta.className = 'padMeta';
    const nm = document.createElement('div');
    nm.className = 'padName';
    nm.textContent = cfg.name;
    const tp = document.createElement('div');
    tp.className = 'padType';
    tp.textContent = cfg.type === 'sample' ? 'Sample' : 'Drum 808';
    meta.appendChild(nm);
    meta.appendChild(tp);

    const pill = document.createElement('div');
    pill.className = 'pill';
    pill.textContent = cfg.label;

    padTop.appendChild(meta);
    padTop.appendChild(pill);

    const padBtn = document.createElement('button');
    padBtn.className = 'padBtn';
    padBtn.id = `padbtn-${padIdx}`;
    padBtn.innerHTML = `
      Pad ${padIdx+1}
      <span class="small" data-sample-label="${cfg.type==='sample' ? padIdx : ''}">
        ${cfg.type==='sample' ? 'no sample' : (cfg.label + ' · ' + cfg.name)}
      </span>
    `;

    padBox.appendChild(padTop);
    padBox.appendChild(padBtn);

    if (cfg.type === 'sample'){
      const wave = document.createElement('div');
      wave.className = 'wave';
      const canvas = document.createElement('canvas');
      canvas.id = `waveform-${padIdx}`;
      canvas.className = 'waveform-canvas';
      canvas.width = 260;
      canvas.height = 40;
      wave.appendChild(canvas);
      padBox.appendChild(wave);

      const mini = document.createElement('div');
      mini.className = 'miniRow';

      const loadBtn = document.createElement('button');
      loadBtn.className = 'tinyBtn';
      loadBtn.textContent = 'Load';
      loadBtn.type = 'button';

      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'audio/*, .wav, .mp3, .m4a, .aif, .aiff';
      input.style.display = 'none';

      loadBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        initAudio();
        input.click();
      });

      input.addEventListener('change', async () => {
        if (!input.files || !input.files[0]) return;
        await loadSampleFile(input.files[0], padIdx);
        input.value = '';
      });

      const volBox = document.createElement('div');
      volBox.className = 'sctl';
      volBox.innerHTML = `
        <div class="row"><span class="lab">Vol</span><span class="v" id="svolv-${padIdx}">${Math.round(SAMPLE_PARAMS[padIdx].vol*100)}%</span></div>
        <input id="svol-${padIdx}" type="range" min="0" max="1" step="0.01" value="${SAMPLE_PARAMS[padIdx].vol}">
      `;

      const pitBox = document.createElement('div');
      pitBox.className = 'sctl';
      pitBox.innerHTML = `
        <div class="row"><span class="lab">Pitch</span><span class="v" id="spitv-${padIdx}">${SAMPLE_PARAMS[padIdx].semi >= 0 ? '+' : ''}${SAMPLE_PARAMS[padIdx].semi} st</span></div>
        <input id="spit-${padIdx}" type="range" min="-24" max="24" step="1" value="${SAMPLE_PARAMS[padIdx].semi}">
      `;

      mini.appendChild(loadBtn);
      mini.appendChild(input);
      mini.appendChild(volBox);
      mini.appendChild(pitBox);
      padBox.appendChild(mini);

      volBox.querySelector(`#svol-${padIdx}`).addEventListener('input', (e) => {
        SAMPLE_PARAMS[padIdx].vol = +e.target.value;
        const lab = document.getElementById(`svolv-${padIdx}`);
        if (lab) lab.textContent = `${Math.round(SAMPLE_PARAMS[padIdx].vol*100)}%`;
      });

      pitBox.querySelector(`#spit-${padIdx}`).addEventListener('input', (e) => {
        SAMPLE_PARAMS[padIdx].semi = +e.target.value;
        const lab = document.getElementById(`spitv-${padIdx}`);
        const s = SAMPLE_PARAMS[padIdx].semi;
        if (lab) lab.textContent = `${s >= 0 ? '+' : ''}${s} st`;
      });

      padBtn.addEventListener('pointerdown', async (e) => {
        e.preventDefault();
        initAudio();
        if (audioCtx.state !== "running") await audioCtx.resume();
        playSample(padIdx, audioCtx.currentTime);
        flashPad(padIdx);
      }, { passive:false });

    } else {
      padBtn.addEventListener('pointerdown', async (e) => {
        e.preventDefault();
        initAudio();
        if (audioCtx.state !== "running") await audioCtx.resume();
        playDrum(cfg.drumType, audioCtx.currentTime);
        flashPad(padIdx);
      }, { passive:false });
    }

    const stepsWrap = document.createElement('div');
    stepsWrap.className = 'stepsWrap';

    const header = document.createElement('div');
    header.className = 'stepsHeader';

    const label = document.createElement('div');
    label.className = 'trackLabel';
    label.innerHTML = `<span class="swatch"></span><span>${cfg.type === 'sample' ? 'Sample track' : 'Drum track'}</span>`;

    header.appendChild(label);
    stepsWrap.appendChild(header);

    const steps = document.createElement('div');
    steps.className = 'steps';

    let painting = false;
    let paintTo = null;

    const applyPaint = (sIdx) => {
      if (paintTo === null) return;
      if (cellOn(padIdx, sIdx) !== paintTo) toggleCell(padIdx, sIdx);
    };

    for (let s=0;s<NUM_STEPS;s++){
      const st = document.createElement('div');
      st.className = 'step' + ((s % 4 === 0) ? ' beat' : '');
      st.id = `step-${padIdx}-${s}`;

      st.addEventListener('pointerdown', async (e) => {
        e.preventDefault();
        st.setPointerCapture(e.pointerId);

        painting = true;
        paintTo = !cellOn(padIdx, s);
        toggleCell(padIdx, s);

        initAudio();
        if (audioCtx.state !== "running") await audioCtx.resume();

        if (cfg.type === 'drum') playDrum(cfg.drumType, audioCtx.currentTime);
        else playSample(padIdx, audioCtx.currentTime);

        flashPad(padIdx);
      }, { passive:false });

      st.addEventListener('pointermove', (e) => {
        if (!painting) return;
        const el = document.elementFromPoint(e.clientX, e.clientY);
        if (!el || !el.id) return;
        if (!el.id.startsWith(`step-${padIdx}-`)) return;
        const sIdx = parseInt(el.id.split('-')[2], 10);
        if (Number.isFinite(sIdx)) applyPaint(sIdx);
      });

      st.addEventListener('pointerup', () => { painting = false; paintTo = null; });
      st.addEventListener('pointercancel', () => { painting = false; paintTo = null; });

      steps.appendChild(st);
    }

    stepsWrap.appendChild(steps);

    row.appendChild(padBox);
    row.appendChild(stepsWrap);
    track.appendChild(row);
    root.appendChild(track);
  });

  refreshAllCells();
}

/* =========================================================================
   UI WIRING
   ========================================================================= */
function fmtHz(v){
  const n = +v;
  return n >= 1000 ? (n/1000).toFixed(1) + "k" : String(Math.round(n));
}

function wireUI(){
  document.getElementById('btnPlay').addEventListener('click', seqToggle);
  document.getElementById('btnStop').addEventListener('click', seqStop);

  document.getElementById('btnClear').addEventListener('click', () => {
    clearPattern();
    seqStop();
  });

  // ✅ CORRECTION #1: utiliser setFxUiOpen() (sync bouton + badge)
  const fxToggleBtn = document.getElementById('fxToggleBtn');
  const fxBody = document.getElementById('fxBody');

  setFxUiOpen(false); // état initial fermé + badge/button sync

  fxToggleBtn.addEventListener('click', () => {
    const open = !fxBody.classList.contains('open');
    setFxUiOpen(open);
  });

  const tsBtn = document.getElementById('tsToggleBtn');
  const syncTsBtn = () => {
    tsBtn.classList.toggle('on', TIME_STRETCH_ON);
    tsBtn.textContent = TIME_STRETCH_ON ? 'Time-Stretch' : 'Rate Pitch';
    tsBtn.title = TIME_STRETCH_ON
      ? 'Pitch sans changer la durée (time-stretch)'
      : 'Pitch via playbackRate (durée change)';
  };
  syncTsBtn();
  tsBtn.addEventListener('click', () => {
    TIME_STRETCH_ON = !TIME_STRETCH_ON;
    syncTsBtn();
  });

  const bpmEl = document.getElementById('bpm');
  const bpmValEl = document.getElementById('bpmVal');
  bpmEl.addEventListener('input', () => {
    bpm = +bpmEl.value;
    bpmValEl.textContent = String(bpm);
  });
  bpm = +bpmEl.value; bpmValEl.textContent = String(bpm);

  const masterEl = document.getElementById('master');
  const masterValEl = document.getElementById('masterVal');
  masterEl.addEventListener('input', () => {
    const v = +masterEl.value;
    masterValEl.textContent = v.toFixed(2);
    if (masterGain) masterGain.gain.value = v;
  });
  masterValEl.textContent = (+masterEl.value).toFixed(2);

  const filterEl = document.getElementById('filter');
  const filterValEl = document.getElementById('filterVal');
  filterEl.addEventListener('input', () => {
    const v = +filterEl.value;
    filterValEl.textContent = fmtHz(v);
    if (filterNode) filterNode.frequency.value = v;
  });
  filterValEl.textContent = fmtHz(+filterEl.value);

  const swingEl = document.getElementById('swingRange');
  const swingValEl = document.getElementById('swingValDisplay');
  swingEl.addEventListener('input', () => {
    swing = (+swingEl.value)/100;
    swingValEl.textContent = swingEl.value + "%";
  });
  swing = (+swingEl.value)/100;
  swingValEl.textContent = swingEl.value + "%";

  document.querySelectorAll('.patBtn').forEach(btn => {
    btn.addEventListener('click', () => loadPattern(+btn.dataset.pat));
  });

  document.getElementById('btnRand').addEventListener('click', randomize);
  document.getElementById('btnFill').addEventListener('click', fillKick);

  document.getElementById('lofi-bypass').addEventListener('click', () => toggleFx('lofi'));
  document.getElementById('tape-bypass').addEventListener('click', () => toggleFx('tape'));
  document.getElementById('vinyl-bypass').addEventListener('click', () => toggleFx('vinyl'));

  document.getElementById('fxAllBypassBtn').addEventListener('click', () => {
    fxAllBypass = !fxAllBypass;
    const b = document.getElementById('fxAllBypassBtn');
    b.classList.toggle('on', fxAllBypass);
    b.textContent = fxAllBypass ? "Bypassed" : "Bypass";
    if (audioCtx) updateFxGains();

    setFxButtonState('lofi-bypass', !fxAllBypass && FX.lofiOn);
    setFxButtonState('tape-bypass', !fxAllBypass && FX.tapeOn);
    setFxButtonState('vinyl-bypass', !fxAllBypass && FX.vinylOn);
  });

  const fxInputs = ['bits','srate','lofimix','tapedrive','tapewow','tapemix','vinylcrackle','vinylwarp','vinylmix'];
  fxInputs.forEach(id => document.getElementById(id).addEventListener('input', applyFxFromUI));

  applyFxFromUI();
  setFxButtonState('lofi-bypass', FX.lofiOn);
  setFxButtonState('tape-bypass', FX.tapeOn);
  setFxButtonState('vinyl-bypass', FX.vinylOn);

  const keyPadMap = { 'q':3, 'w':4, 'e':5, 'a':0, 's':1, 'd':2 };
  document.addEventListener('keydown', async (e) => {
    if (e.key === ' ') { e.preventDefault(); seqToggle(); return; }
    const padIdx = keyPadMap[e.key.toLowerCase()];
    if (padIdx !== undefined) {
      initAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();
      const cfg = PAD_CONFIG[padIdx];
      if (cfg.type === 'drum') playDrum(cfg.drumType, audioCtx.currentTime);
      else playSample(padIdx, audioCtx.currentTime);
      flashPad(padIdx);
    }
  });
}

/* =========================================================================
   INIT
   ========================================================================= */
window.addEventListener('DOMContentLoaded', () => {
  buildTracks();
  wireUI();
  setDisplay('---');

  // default groove
  getPattern()[3][0] = true; getPattern()[3][8] = true;
  getPattern()[4][4] = true; getPattern()[4][12] = true;
  for (let s = 0; s < 16; s += 2) getPattern()[5][s] = true;
  refreshAllCells();
});
</script>
</body>
</html>
